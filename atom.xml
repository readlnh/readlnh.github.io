<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://readlnh.github.io/atom.xml" rel="self"/>
  
  <link href="http://readlnh.github.io/"/>
  <updated>2022-10-27T19:58:23.769Z</updated>
  <id>http://readlnh.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="http://readlnh.github.io/2022/10/27/hello-world/"/>
    <id>http://readlnh.github.io/2022/10/27/hello-world/</id>
    <published>2022-10-27T19:58:23.769Z</published>
    <updated>2022-10-27T19:58:23.769Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Opengl初学</title>
    <link href="http://readlnh.github.io/2022/10/27/OpenGL/openl_learning01/"/>
    <id>http://readlnh.github.io/2022/10/27/OpenGL/openl_learning01/</id>
    <published>2022-10-27T19:58:23.769Z</published>
    <updated>2022-10-27T19:58:23.769Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GLFW"><a href="#GLFW" class="headerlink" title="GLFW"></a>GLFW</h2><p>GLFW是一个专门针对OpenGL的C语言库，它提供了一些渲染物体所需的最低限度的接口。它允许用户创建OpenGL上下文，定义窗口参数以及处理用户输入，这正是我们需要的。</p><h2 id="GLAD"><a href="#GLAD" class="headerlink" title="GLAD"></a>GLAD</h2><p>因为OpenGL只是一个标准&#x2F;规范，具体的实现是由驱动开发商针对特定显卡实现的。由于OpenGL驱动版本众多，它大多数函数的位置都无法在编译时确定下来，需要在运行时查询。所以任务就落在了开发者身上，开发者需要在运行时获取函数地址并将其保存在一个函数指针中供以后使用。取得地址的方法因平台而异，在Windows上会是类似这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义函数原型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*GL_GENBUFFERS)</span> <span class="params">(GLsizei, GLuint*)</span></span>;</span><br><span class="line"><span class="comment">// 找到正确的函数并赋值给函数指针</span></span><br><span class="line">GL_GENBUFFERS glGenBuffers  = (GL_GENBUFFERS)<span class="built_in">wglGetProcAddress</span>(<span class="string">&quot;glGenBuffers&quot;</span>);</span><br><span class="line"><span class="comment">// 现在函数可以被正常调用了</span></span><br><span class="line">GLuint buffer;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;buffer);</span><br></pre></td></tr></table></figure><p>你可以看到代码非常复杂，而且很繁琐，我们需要对每个可能使用的函数都要重复这个过程。幸运的是，有些库能简化此过程，其中GLAD是目前最新，也是最流行的库。</p><p>GLAD是用来管理OpenGL的函数指针的，所以在调用任何OpenGL的函数之前我们需要初始化GLAD。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们给GLAD传入了用来加载系统相关的OpenGL函数指针地址的函数。GLFW给我们的是glfwGetProcAddress，它根据我们编译的系统定义了正确的函数。</p><h2 id="Viewport"><a href="#Viewport" class="headerlink" title="Viewport"></a>Viewport</h2><p>在我们开始渲染之前还有一件重要的事情要做，我们必须告诉OpenGL渲染窗口的尺寸大小，即视口(Viewport)，这样OpenGL才只能知道怎样根据窗口大小显示数据和坐标。我们可以通过调用glViewport函数来设置窗口的维度(Dimension)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glViewport(0, 0, 800, 600);</span><br></pre></td></tr></table></figure><p>glViewport函数前两个参数控制窗口左下角的位置。第三个和第四个参数控制渲染窗口的宽度和高度（像素）。</p><p>OpenGL幕后使用glViewport中定义的位置和宽高进行2D坐标的转换，将OpenGL中的位置坐标转换为你的屏幕坐标。例如，OpenGL中的坐标(-0.5, 0.5)有可能（最终）被映射为屏幕中的坐标(200,450)。注意，处理过的OpenGL坐标范围只为-1到1，因此我们事实上将(-1到1)范围内的坐标映射到(0, 800)和(0, 600)。</p><p>然而，当用户改变窗口的大小的时候，视口也应该被调整。我们可以对窗口注册一个回调函数(Callback Function)，它会在每次窗口大小被调整的时候被调用。这个回调函数的原型如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span>;</span><br></pre></td></tr></table></figure><p>这个帧缓冲大小函数需要一个GLFWwindow作为它的第一个参数，以及两个整数表示窗口的新维度。每当窗口改变大小，GLFW会调用这个函数并填充相应的参数供你处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还需要注册这个函数，告诉GLFW我们希望每当窗口调整大小的时候调用这个函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glfwSetFramebufferSizeCallback</span>(window, framebuffer_size_callback);</span><br></pre></td></tr></table></figure><p>当窗口被第一次显示的时候framebuffer_size_callback也会被调用。对于视网膜(Retina)显示屏，width和height都会明显比原输入值更高一点。</p><p>我们还可以将我们的函数注册到其它很多的回调函数中。比如说，我们可以创建一个回调函数来处理手柄输入变化，处理错误消息等。我们会在创建窗口之后，渲染循环初始化之前注册这些回调函数。<br>渲染循环</p><p>主要作用就是让程序不要只绘制一个图像就退出。我们希望在我们主动关闭程序之前，它能不断绘制图像并接受用户输入。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!<span class="built_in">glfwWindowShouldClose</span>(window)) &#123;</span><br><span class="line">       <span class="built_in">processInput</span>(window);</span><br><span class="line">       </span><br><span class="line">       <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">       <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>glfwWindowShouldClose函数在我们每次循环的开始前检查一次GLFW是否被要求退出，如果是的话该函数返回true然后渲染循环便结束了，之后为我们就可以关闭应用程序了。<br>glfwPollEvents函数检查有没有触发什么事件（比如键盘输入、鼠标移动等）、更新窗口状态，并调用对应的回调函数（可以通过回调方法手动设置）。<br>glfwSwapBuffers函数会交换颜色缓冲（它是一个储存着GLFW窗口每一个像素颜色值的大缓冲），它在这一迭代中被用来绘制，并且将会作为输出显示在屏幕上。</p><h2 id="cmakelist"><a href="#cmakelist" class="headerlink" title="cmakelist"></a>cmakelist</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required (VERSION 2.8)</span><br><span class="line">cmake_policy(VERSION 2.8)</span><br><span class="line"></span><br><span class="line">project (LearnOpenGL)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">link_directories($&#123;CMAKE_SOURCE_DIR&#125;/lib)</span><br><span class="line"></span><br><span class="line">list(APPEND CMAKE_CXX_FLAGS &quot;-std=c++11&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">find_package(OpenGL)</span><br><span class="line">find_package(glfw3 REQUIRED)</span><br><span class="line"></span><br><span class="line">include_directories($&#123;CMAKE_SOURCE_DIR&#125;/includes)</span><br><span class="line">include_directories($&#123;OPENGL_INCLUDE_DIR&#125;)</span><br><span class="line"></span><br><span class="line">add_library(GLAD SHARED &quot;src/glad.c&quot;)</span><br><span class="line">TARGET_LINK_LIBRARIES(GLAD dl)</span><br><span class="line"></span><br><span class="line">set(LIBS $&#123;LIBS&#125; GLAD $&#123;OPENGL_gl_LIBRARY&#125; glfw)</span><br><span class="line"></span><br><span class="line">add_executable(LearnOpenGL hello_window.cpp)</span><br><span class="line">target_link_libraries(LearnOpenGL $&#123;LIBS&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;GLFW&quot;&gt;&lt;a href=&quot;#GLFW&quot; class=&quot;headerlink&quot; title=&quot;GLFW&quot;&gt;&lt;/a&gt;GLFW&lt;/h2&gt;&lt;p&gt;GLFW是一个专门针对OpenGL的C语言库，它提供了一些渲染物体所需的最低限度的接口。它允许用户创建OpenGL上下文，定</summary>
      
    
    
    
    <category term="OpenGL" scheme="http://readlnh.github.io/categories/OpenGL/"/>
    
    
  </entry>
  
  <entry>
    <title>Pipe(管道)的一些理解</title>
    <link href="http://readlnh.github.io/2022/10/27/Linux/APUE/pipe1/"/>
    <id>http://readlnh.github.io/2022/10/27/Linux/APUE/pipe1/</id>
    <published>2022-10-27T19:58:23.765Z</published>
    <updated>2022-10-27T19:58:23.765Z</updated>
    
    <content type="html"><![CDATA[<h2 id="管道的概念"><a href="#管道的概念" class="headerlink" title="管道的概念"></a>管道的概念</h2><p>管道是操作系统中常见的一种进程间通信方式，它使用于所有POSIX系统以及Windows系列产品。</p><p>管道也是unix ipc的最老形式，管道有两种限制：</p><ul><li>数据自己读不能自己写</li><li>它们是半双工的。数据只能在一个方向上流动。</li><li>数据一旦被读走，便不在管道中存在，不可反复读取。</li><li>它们只能在具有公共祖先的进程之间使用。通常,一个管道由一个进程创建,然后该进程调用fork,此后父、子进程之间就可应用该管道。</li></ul><h2 id="管道的创建"><a href="#管道的创建" class="headerlink" title="管道的创建"></a>管道的创建</h2><p>管道由pipe函数创建而成<code>pipe(pipe_fd)</code>经由参数pipe_fd返回两个文件描述符，pipe_fd[0]为读而打开,pipe_fd[1]为写而打开。pipe_fd[1]的输出是pipe_fd[0]的输入。</p><p>函数调用成功返回r&#x2F;w两个文件描述符。无需open，但需手动close。规定：<code>fd[0] → r； fd[1] → w</code>，就像0对应标准输入，1对应标准输出一样。向管道文件读写数据其实是在读写内核缓冲区。</p><p>管道创建成功以后，创建该管道的进程（父进程）同时掌握着管道的读端和写端。</p><p><img src="https://raw.githubusercontent.com/readlnh/picture/master/pipe.png"> </p><p>具体通信过程如上图所示</p><ul><li><p>父进程调用pipe函数创建管道，得到两个文件描述符fd[0]、fd[1]指向管道的读端和写端。</p></li><li><p>父进程调用fork创建子进程，那么子进程也有两个文件描述符指向同一管道。</p></li><li><p>父进程关闭管道读端，子进程关闭管道写端。父进程可以向管道中写入数据，子进程将管道中的数据读出。由于管道是利用环形队列实现的，数据从写端流入管道，从读端流出，这样就实现了进程间通信。</p></li></ul><h2 id="管道的读写行为"><a href="#管道的读写行为" class="headerlink" title="管道的读写行为"></a>管道的读写行为</h2><p>如果所有指向管道写端的文件描述符都关闭了（管道写端引用计数为0），而仍然有进程从管道的读端读数据，那么管道中剩余的数据都被读取后，再次read会返回0，就像读到文件末尾一样。</p><p>如果有指向管道写端的文件描述符没关闭（管道写端引用计数大于0），而持有管道写端的进程也没有向管道中写数据，这时有进程从管道读端读数据，那么管道中剩余的数据都被读取后，再次read会阻塞，直到管道中有数据可读了才读取数据并返回。</p><p>如果所有指向管道读端的文件描述符都关闭了（管道读端引用计数为0），这时有进程向管道的写端write，那么该进程会收到信号SIGPIPE，通常会导致进程异常终止。当然也可以对SIGPIPE信号实施捕捉，不终止进程。具体方法信号章节详细介绍。</p><p>如果有指向管道读端的文件描述符没关闭（管道读端引用计数大于0），而持有管道读端的进程也没有从管道中读数据，这时有进程向管道写端写数据，那么在管道被写满时再次write会阻塞，直到管道中有空位置了才写入数据并返回。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pipe_fd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">pid_t</span> child_pid;</span><br><span class="line">    <span class="type">char</span> pipe_buf;</span><br><span class="line">    <span class="built_in">memset</span>(pipe_fd, <span class="number">0</span>, <span class="keyword">sizeof</span>(pipe_fd));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pipe(pipe_fd) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    child_pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(child_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(child_pid == <span class="number">0</span>) &#123;</span><br><span class="line">        close(pipe_fd[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">while</span>(read(pipe_fd[<span class="number">0</span>], &amp;pipe_buf, <span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            write(STDOUT_FILENO, &amp;pipe_buf, <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\npipe_buf is %c\n&quot;</span>, pipe_buf);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\nsuccess\n&quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        close(pipe_fd[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        close(pipe_fd[<span class="number">0</span>]);</span><br><span class="line">        write(pipe_fd[<span class="number">1</span>], <span class="string">&quot;H&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        close(pipe_fd[<span class="number">1</span>]);</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;管道的概念&quot;&gt;&lt;a href=&quot;#管道的概念&quot; class=&quot;headerlink&quot; title=&quot;管道的概念&quot;&gt;&lt;/a&gt;管道的概念&lt;/h2&gt;&lt;p&gt;管道是操作系统中常见的一种进程间通信方式，它使用于所有POSIX系统以及Windows系列产品。&lt;/p&gt;
&lt;p&gt;管道</summary>
      
    
    
    
    <category term="Linux" scheme="http://readlnh.github.io/categories/Linux/"/>
    
    <category term="APUE" scheme="http://readlnh.github.io/categories/Linux/APUE/"/>
    
    
  </entry>
  
  <entry>
    <title>聊一聊linux中的cgroup</title>
    <link href="http://readlnh.github.io/2022/10/27/Linux/docker/cgroup/"/>
    <id>http://readlnh.github.io/2022/10/27/Linux/docker/cgroup/</id>
    <published>2022-10-27T19:58:23.765Z</published>
    <updated>2022-10-27T19:58:23.765Z</updated>
    
    <content type="html"><![CDATA[<p>最近由于工作原因接触了docker，也就研究一下它的原理，主要看了阿里出的&lt;&lt;自己动手写docker&gt;&gt;，感觉蛮有意思，姑且记录一下。docker可以算是当前非常火热的技术了。我们知道docker基于Namespce和Cgroups，其中</p><ul><li>Namespace主要用于隔离资源</li><li>Cgroups用来提供对一组进程以及将来子进程的资源限制</li></ul><h2 id="Cgrougps的三个组件"><a href="#Cgrougps的三个组件" class="headerlink" title="Cgrougps的三个组件"></a>Cgrougps的三个组件</h2><p>cgrpups包含三个组件</p><ul><li><p><strong>控制组</strong> 一个cgroups包含一组进程，并可以在这个cgroups上增加Linux subsystem的各种参数配置，将一组进程和一组subsystem关联起来。</p></li><li><p><strong>subsystem</strong> 子系统 是一组资源控制模块，可以通过<code>lssubsys -a</code>命令查看当前内核支持哪些subsystem。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cpuset</span><br><span class="line">cpu,cpuacct</span><br><span class="line">blkio</span><br><span class="line">memory</span><br><span class="line">devices</span><br><span class="line">freezer</span><br><span class="line">net_cls,net_prio</span><br><span class="line">perf_event</span><br><span class="line">hugetlb</span><br><span class="line">pids</span><br><span class="line">rdma</span><br></pre></td></tr></table></figure><p>subsystem作用于hierarchy的cgroup节点，并控制节点中进程的资源占用。</p></li><li><p><strong>hierarchy 层级树</strong> 主要功能是把cgroups串成一个树型结构，使cgruops可以做到继承。也就是说将cgroup通过树状结构串起来，通过虚拟文件系统的方式暴露给用户。</p></li></ul><h3 id="三个组件之前的关系"><a href="#三个组件之前的关系" class="headerlink" title="三个组件之前的关系"></a>三个组件之前的关系</h3><p>cgroup中的组件是相互关联的</p><ul><li><p>系统创建新的hierarchy之后，系统中所有的进程都会加入这个hierarchy的cgroup的根节点，这个cgroup根节点是hierarchy默认创建的，在这个hierarchy中创建的所有cgroup都是这个cgroup根节点的子节点。</p></li><li><p>一个subsystem只能附加到一个hierarchy上</p></li><li><p>一个hierarchy可以附加多个subsystem</p></li><li><p>一个进程可以作为多个cgroup的成员，但是这些cgroup必须在不同的hierarchy下</p></li><li><p>一个进程fork出子进程时，子进程和父进程是在同一个cgroup中的，根据需要也可以移动到其他的cgroup中</p></li></ul><h2 id="使用Cgroup"><a href="#使用Cgroup" class="headerlink" title="使用Cgroup"></a>使用Cgroup</h2><h3 id="创建挂载点"><a href="#创建挂载点" class="headerlink" title="创建挂载点"></a>创建挂载点</h3><p>我们知道kernel是通过一个虚拟树状文件系统来配置Cgroups的。我们首先需要创建并挂载一个hierarchy(cgroup树)。即先mkdir后mount。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">readlnh@readlnh-Inspiron-3542:~$ sudo mount -t cgroup -o none,name=cgroup-test cgroup-test cgroup-test/</span><br><span class="line">readlnh@readlnh-Inspiron-3542:~$ ls ./c</span><br><span class="line">cgroup-test/  clone_test.c</span><br><span class="line">readlnh@readlnh-Inspiron-3542:~$ ls ./cgroup-test/</span><br><span class="line">cgroup.clone_children  cgroup.sane_behavior  release_agent</span><br><span class="line">cgroup.procs           notify_on_release     tasks</span><br></pre></td></tr></table></figure><p>可以看到挂载后系统在目录下生成了一系列文件，这些文件其实就是根节点文件的配置项。</p><h3 id="创建子cgroup"><a href="#创建子cgroup" class="headerlink" title="创建子cgroup"></a>创建子cgroup</h3><p>创建cgroup-1，我们可以看到在cgroup文件夹下再创建文件夹，系统会将这个文件夹也标记为cgroup，并且它是上一个cgroup的子cgroup，它会继承父cgroup的属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">readlnh@readlnh-Inspiron-3542:~/cgroup-test$ sudo mkdir cgroup-1</span><br><span class="line">readlnh@readlnh-Inspiron-3542:~/cgroup-test$ tree</span><br><span class="line">.</span><br><span class="line">├── cgroup-1</span><br><span class="line">│   ├── cgroup.clone_children</span><br><span class="line">│   ├── cgroup.procs</span><br><span class="line">│   ├── notify_on_release</span><br><span class="line">│   └── tasks</span><br><span class="line">├── cgroup.clone_children</span><br><span class="line">├── cgroup.procs</span><br><span class="line">├── cgroup.sane_behavior</span><br><span class="line">├── notify_on_release</span><br><span class="line">├── release_agent</span><br><span class="line">└── tasks</span><br><span class="line"></span><br><span class="line">1 directory, 10 files</span><br></pre></td></tr></table></figure><h3 id="移动进程"><a href="#移动进程" class="headerlink" title="移动进程"></a>移动进程</h3><p>将终端进程移动到cgroup-1(只要将进程ID写到相应的cgroup的tasks文件)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">readlnh@readlnh-Inspiron-3542:~/cgroup-test/cgroup-1$ <span class="built_in">echo</span> $$</span><br><span class="line">10644</span><br><span class="line">readlnh@readlnh-Inspiron-3542:~/cgroup-test/cgroup-1$ <span class="built_in">cat</span> /proc/10644/cgroup </span><br><span class="line">13:name=cgroup-test:/</span><br><span class="line">12:perf_event:/</span><br><span class="line">11:memory:/user.slice</span><br><span class="line">10:hugetlb:/</span><br><span class="line">9:cpuset:/</span><br><span class="line">8:pids:/user.slice/user-1000.slice/user@1000.service</span><br><span class="line">7:rdma:/</span><br><span class="line">6:devices:/user.slice</span><br><span class="line">5:freezer:/</span><br><span class="line">4:cpu,cpuacct:/user.slice</span><br><span class="line">3:net_cls,net_prio:/</span><br><span class="line">2:blkio:/user.slice</span><br><span class="line">1:name=systemd:/user.slice/user-1000.slice/user@1000.service/gnome-terminal-server.service</span><br><span class="line">0::/user.slice/user-1000.slice/user@1000.service/gnome-terminal-server.service</span><br><span class="line">readlnh@readlnh-Inspiron-3542:~/cgroup-test/cgroup-1$ sudo sh -c <span class="string">&quot;echo $$ &gt;&gt; tasks&quot;</span></span><br><span class="line">readlnh@readlnh-Inspiron-3542:~/cgroup-test/cgroup-1$ <span class="built_in">cat</span> /proc/10644/cgroup </span><br><span class="line">13:name=cgroup-test:/cgroup-1</span><br><span class="line">12:perf_event:/</span><br><span class="line">11:memory:/user.slice</span><br><span class="line">10:hugetlb:/</span><br><span class="line">9:cpuset:/</span><br><span class="line">8:pids:/user.slice/user-1000.slice/user@1000.service</span><br><span class="line">7:rdma:/</span><br><span class="line">6:devices:/user.slice</span><br><span class="line">5:freezer:/</span><br><span class="line">4:cpu,cpuacct:/user.slice</span><br><span class="line">3:net_cls,net_prio:/</span><br><span class="line">2:blkio:/user.slice</span><br><span class="line">1:name=systemd:/user.slice/user-1000.slice/user@1000.service/gnome-terminal-server.service</span><br><span class="line">0::/user.slice/user-1000.slice/user@1000.service/gnome-terminal-server.service</span><br></pre></td></tr></table></figure><p>可以看到现在终端进程已经在cgroup-1了</p><h3 id="通过subsystem限制cgroups中的进程资源"><a href="#通过subsystem限制cgroups中的进程资源" class="headerlink" title="通过subsystem限制cgroups中的进程资源"></a>通过subsystem限制cgroups中的进程资源</h3><p>之前我们创建的cgroup是没有和任何subsystem相关联的，所以没法通过hierarchy中的cgroup节点限制资源。实际系统中已经默认为每个subsystem创建了一个默认的hierarchy，我们这里就直接在这个hierarchy下创建cgroup</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">readlnh@readlnh-Inspiron-3542:~/cgroup-test/test-limit-memory$ mount | grep memory</span><br><span class="line">cgroup on /sys/fs/cgroup/memory <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,memory)</span><br><span class="line">readlnh@readlnh-Inspiron-3542:~/cgroup-test/test-limit-memory$ <span class="built_in">cd</span> /sys/fs/cgroup/memory/</span><br><span class="line">readlnh@readlnh-Inspiron-3542:/sys/fs/cgroup/memory$ sudo <span class="built_in">mkdir</span> test-limit-memory</span><br><span class="line">readlnh@readlnh-Inspiron-3542:/sys/fs/cgroup/memory$ <span class="built_in">cd</span> test-limit-memory/</span><br><span class="line">readlnh@readlnh-Inspiron-3542:/sys/fs/cgroup/memory/test-limit-memory$ <span class="built_in">ls</span></span><br><span class="line">cgroup.clone_children               memory.limit_in_bytes</span><br><span class="line">cgroup.event_control                memory.max_usage_in_bytes</span><br><span class="line">cgroup.procs                        memory.move_charge_at_immigrate</span><br><span class="line">memory.failcnt                      memory.numa_stat</span><br><span class="line">memory.force_empty                  memory.oom_control</span><br><span class="line">memory.kmem.failcnt                 memory.pressure_level</span><br><span class="line">memory.kmem.limit_in_bytes          memory.soft_limit_in_bytes</span><br><span class="line">memory.kmem.max_usage_in_bytes      memory.stat</span><br><span class="line">memory.kmem.slabinfo                memory.swappiness</span><br><span class="line">memory.kmem.tcp.failcnt             memory.usage_in_bytes</span><br><span class="line">memory.kmem.tcp.limit_in_bytes      memory.use_hierarchy</span><br><span class="line">memory.kmem.tcp.max_usage_in_bytes  notify_on_release</span><br><span class="line">memory.kmem.tcp.usage_in_bytes      tasks</span><br><span class="line">memory.kmem.usage_in_bytes</span><br><span class="line">readlnh@readlnh-Inspiron-3542:/sys/fs/cgroup/memory/test-limit-memory$ stress --vm-bytes 200m --vm-keep -m 1</span><br><span class="line">stress: info: [15357] dispatching hogs: 0 cpu, 0 io, 1 vm, 0 hdd</span><br></pre></td></tr></table></figure><p>用top查看，发现内存为100m，实际上这里限制内存就是一个向memory_limit_in_bytes文件中写入100m这个操作，可以说相简单了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">15358 readlnh   20   0  213044 100916    212 D  39.5  1.3   7:54.10 stress</span><br></pre></td></tr></table></figure><p>从这里我们就可以猜测，docker实际上就是通过go语言挂载，创建cgroups再向相应文件写入相应条件来限制容器资源的。cgroup确实是一个很有意思也很方便的功能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近由于工作原因接触了docker，也就研究一下它的原理，主要看了阿里出的&amp;lt;&amp;lt;自己动手写docker&amp;gt;&amp;gt;，感觉蛮有意思，姑且记录一下。docker可以算是当前非常火热的技术了。我们知道docker基于Namespce和Cgroups，其中&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="Linux" scheme="http://readlnh.github.io/categories/Linux/"/>
    
    <category term="docker" scheme="http://readlnh.github.io/categories/Linux/docker/"/>
    
    
  </entry>
  
  <entry>
    <title>docker技术分析 - linux namespce机制</title>
    <link href="http://readlnh.github.io/2022/10/27/Linux/docker/linux%20namespce%E6%9C%BA%E5%88%B6%E5%88%9D%E6%8E%A2/"/>
    <id>http://readlnh.github.io/2022/10/27/Linux/docker/linux%20namespce%E6%9C%BA%E5%88%B6%E5%88%9D%E6%8E%A2/</id>
    <published>2022-10-27T19:58:23.765Z</published>
    <updated>2022-10-27T19:58:23.765Z</updated>
    
    <content type="html"><![CDATA[<p>docker技术是近年来无比火热的技术，不管是哪个领域大家都在研究和使用docker。<br>我们在使用docker的时候经常听人说，docker是基于linux内核的Namespace和Cgroup技术实现的。那么究竟什么是Namespace技术呢？</p><h2 id="linux-namespce"><a href="#linux-namespce" class="headerlink" title="linux namespce"></a>linux namespce</h2><p>linux的namespce机制提供了一种资源隔离方案，它是Linux平台实现容器这种轻量级的虚拟化的基础。namespce使得PID，IPC，NetWork等系统资源不再是全局性，而是属于特定的namespace的，只需要在clone的时候指定相应的flag，就可以创建相应的namespce。大部分容器就是利用了这一技术实现了资源的隔离，不同容器内的进程属于不同的namespace，彼此透明互不干扰。</p><p>目前linux实现了以下6种Namespace</p><ul><li>Mount namespaces(2.4.19)</li><li>UTS namespaces(2.6.19)</li><li>IPC namespaces(2.6.19)</li><li>PID namespaces(2.6.24)</li><li>Network namespaces(2.6.29)</li><li>User namespaces(3.8)</li></ul><h3 id="Mount-namespaces"><a href="#Mount-namespaces" class="headerlink" title="Mount namespaces"></a>Mount namespaces</h3><p>Mount namespaces为一组进程隔离了一系列的文件系统挂载点。在不同Mount namespaces的进程有不同的文件系统层次视图。通过使用Mount namespaces，进程调用mount()和umount()函数时不再操作对所有进程可见的全局挂载点，而是只操作调用进程所关联的mount namespace。</p><p>使用Mount namespaces可以象chroot方式一样创建环境。但是，与使用chroot调用对比，Mount namespaces方式更加安全和灵活。</p><p>Mount namespaces是Linux中实现的第一种namespace(2002年)。</p><h3 id="UTS-namespaces"><a href="#UTS-namespaces" class="headerlink" title="UTS namespaces"></a>UTS namespaces</h3><p>UTS namespaces实现uname()系统调用返回的对两个系统描述符nodename和domainname的隔离（这两个值可以由sethostname()和setdomainname()系统调用来设置）。</p><p>在容器的上下文中，UTS namespaces允许每个容器有自己的hostname和NIS domain name。这对于基于这两个名字的初始化和配置脚本很有用。</p><h3 id="PID-namespaces"><a href="#PID-namespaces" class="headerlink" title="PID namespaces"></a>PID namespaces</h3><p>PID namespaces实现进程间ID空间隔离。在不同PID namespaces中的进程可以有相同的PID。PID namespaces的一个主要好处是容器可以在不同的主机上移植，保持容器内部的进程ID不变。</p><p>PID namespaces还允许每个容器有自己的init进程，及PID为1的进程，这个进程是容器中所有进程的祖先。</p><h3 id="NET-namespaces"><a href="#NET-namespaces" class="headerlink" title="NET namespaces"></a>NET namespaces</h3><p>NET namespaces提供对与网络相关的系统资源的隔离。每个Network namespace有自己的网络设备、IP地址、IP路由表、&#x2F;proc&#x2F;net目录，端口号等等。</p><p>也就是说同一台主机上的多个容器中的web服务器都可以绑定80端口。</p><h3 id="User-namespaces"><a href="#User-namespaces" class="headerlink" title="User namespaces"></a>User namespaces</h3><p>User namespaces提供对用户id和组id号码空间的资源隔离。在一个user namespaces内部和外部，一个进程有不同的userid和groupid。</p><p>User namespace可以让一个进程在User namespace内有root权限，而在User namespace外则只有普通权限。</p><h3 id="用go语言来操作namespace"><a href="#用go语言来操作namespace" class="headerlink" title="用go语言来操作namespace"></a>用go语言来操作namespace</h3><p>由于docker是用go语言实现的，故我这里也使用go语言来作为范例，创建一个utsnamespace。代码如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="string">&quot;os/exec&quot;</span></span><br><span class="line"><span class="string">&quot;syscall&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">cmd := exec.Command(<span class="string">&quot;sh&quot;</span>)</span><br><span class="line">cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123;</span><br><span class="line">Cloneflags: syscall.CLONE_NEWUTS,</span><br><span class="line">&#125;</span><br><span class="line">cmd.Stdin = os.Stdin</span><br><span class="line">cmd.Stdout = os.Stdout</span><br><span class="line">cmd.Stderr = os.Stderr</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := cmd.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里go语言帮我们封装了对clone函数的调用，我们在这里指定了系统调用的参数<code>Cloneflags: syscall.CLONE_NEWUTS</code>，系统会根据该参数去创建一个UTC Namespace并进入到一个sh环境中。<br>我们执行go build，再运行该程序，注意，这里我们需要以管理员权限来执行该程序，不然会提示如下错误。<br><img src="https://raw.githubusercontent.com/readlnh/picture/master/utc-namespace-test1.png"><br>我们运行该程序后似乎什么都没有发生，实际上我们已经进入新的namespace了<br>此时在终端输入hostname命令，发现和主机的hostname是一样的<br><img src="https://raw.githubusercontent.com/readlnh/picture/master/utc-namespace-test2.png"><br>我们在新建的namespace里修改hostname，此时我们在宿主机上再启动一个终端，执行hostname命令，发现宿主机的hostname并没有改变，由此可见UTC Namespce可以拥有自己的hostname。<br><img src="https://raw.githubusercontent.com/readlnh/picture/master/utc-namespce-test3.png"><br>这里我们只指定了一个参数，实际上我们可以在clone时同时指定多重命名空间，由此来达到进程的隔离，各位读者可以自行尝试。如果想使用c语言来进行尝试，只需要在调用clone()函数时指定相应参数即可，这里就不过多展开了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;docker技术是近年来无比火热的技术，不管是哪个领域大家都在研究和使用docker。&lt;br&gt;我们在使用docker的时候经常听人说，docker是基于linux内核的Namespace和Cgroup技术实现的。那么究竟什么是Namespace技术呢？&lt;/p&gt;
&lt;h2 id</summary>
      
    
    
    
    <category term="Linux" scheme="http://readlnh.github.io/categories/Linux/"/>
    
    <category term="docker" scheme="http://readlnh.github.io/categories/Linux/docker/"/>
    
    
  </entry>
  
  <entry>
    <title>如何在docker中运行ubuntukylin桌面系统</title>
    <link href="http://readlnh.github.io/2022/10/27/Linux/docker/%E5%A6%82%E4%BD%95%E5%9C%A8docker%E4%B8%AD%E8%BF%90%E8%A1%8Cubuntukylin%E6%A1%8C%E9%9D%A2%E7%B3%BB%E7%BB%9F/"/>
    <id>http://readlnh.github.io/2022/10/27/Linux/docker/%E5%A6%82%E4%BD%95%E5%9C%A8docker%E4%B8%AD%E8%BF%90%E8%A1%8Cubuntukylin%E6%A1%8C%E9%9D%A2%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-10-27T19:58:23.765Z</published>
    <updated>2022-10-27T19:58:23.769Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>由于要和开源社合办一个活动，要求线上线下同时进行，需要使用对方的云平台，本来以为只需要提供iso镜像就行了，没想到对方只支持docker镜像。虽然之前用过docker，但是完全没想过docker里跑桌面。</p><h2 id="思路调研和已有开源项目"><a href="#思路调研和已有开源项目" class="headerlink" title="思路调研和已有开源项目"></a>思路调研和已有开源项目</h2><p>说实话，由于没怎么接触过docker，所以花了一上午时间看了下docker实践教程，但是对如何运行桌面还是没什么头绪。但是我之前在win10刚出wsl的时候好奇去尝试过，当时有一种使用ximage映射使wsl运行图形界面的方案，我猜测docker也可以通过这种类似远程桌面的方式来跑桌面。</p><p>同时我又寻找了一些开源项目，这里不得不吐槽下，大家似乎对在docker里启桌面都没什么兴趣，相关资料是真的少…</p><p>首先是kde neno，kde neno有docker镜像的试用，看了下发现采用的是xserver-xwphyr这个方案，但是对于docker镜像的细节并看不到，遂放弃。</p><p>然后我想到了deepin，似乎曾经听说过他们有相应的docker镜像，我抱着试试看的心态去找了找，发现确实有一个在docker里运行桌面的方案，然而是使用xdocker，这个显然不符合我的预期，只能放弃。</p><p>最后终于在github上找到了这个<a href="https://github.com/fcwu/docker-ubuntu-vnc-desktop">docker-ubuntu-vnc-desktop</a> 这个项目是在docker里运行lxde桌面的ubuntu，并通过浏览器来访问。效果如下</p><p><img src="https://camo.githubusercontent.com/0a7d00e1480bc9c15cd83833698c89292e934b2d/68747470733a2f2f7261772e6769746875622e636f6d2f666377752f646f636b65722d7562756e74752d766e632d6465736b746f702f6d61737465722f73637265656e73686f74732f6c7864652e706e673f7631"> </p><p>效果相当不错，赶紧看看人家的dockerfile是如何构建的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"># Built with arch: amd64 flavor: lxde image: ubuntu:18.04 localbuild: 1</span><br><span class="line">#</span><br><span class="line">################################################################################</span><br><span class="line"># base system</span><br><span class="line">################################################################################</span><br><span class="line"></span><br><span class="line">FROM ubuntu:18.04 as system</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RUN sed -i &#x27;s#http://archive.ubuntu.com/#http://tw.archive.ubuntu.com/#&#x27; /etc/apt/sources.list; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># built-in packages</span><br><span class="line">ENV DEBIAN_FRONTEND noninteractive</span><br><span class="line">RUN apt update \</span><br><span class="line">    &amp;&amp; apt install -y --no-install-recommends software-properties-common curl apache2-utils \</span><br><span class="line">    &amp;&amp; apt update \</span><br><span class="line">    &amp;&amp; apt install -y --no-install-recommends --allow-unauthenticated \</span><br><span class="line">        supervisor nginx sudo net-tools zenity xz-utils \</span><br><span class="line">        dbus-x11 x11-utils alsa-utils \</span><br><span class="line">        mesa-utils libgl1-mesa-dri \</span><br><span class="line">    &amp;&amp; apt autoclean -y \</span><br><span class="line">    &amp;&amp; apt autoremove -y \</span><br><span class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/*</span><br><span class="line"># install debs error if combine together</span><br><span class="line">RUN add-apt-repository -y ppa:fcwu-tw/apps \</span><br><span class="line">    &amp;&amp; apt update \</span><br><span class="line">    &amp;&amp; apt install -y --no-install-recommends --allow-unauthenticated \</span><br><span class="line">        xvfb x11vnc=0.9.16-1 \</span><br><span class="line">        vim-tiny firefox chromium-browser ttf-ubuntu-font-family ttf-wqy-zenhei  \</span><br><span class="line">    &amp;&amp; add-apt-repository -r ppa:fcwu-tw/apps \</span><br><span class="line">    &amp;&amp; apt autoclean -y \</span><br><span class="line">    &amp;&amp; apt autoremove -y \</span><br><span class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/*</span><br><span class="line"></span><br><span class="line">RUN apt update \</span><br><span class="line">    &amp;&amp; apt install -y --no-install-recommends --allow-unauthenticated \</span><br><span class="line">        lxde gtk2-engines-murrine gnome-themes-standard gtk2-engines-pixbuf gtk2-engines-murrine arc-theme \</span><br><span class="line">    &amp;&amp; apt autoclean -y \</span><br><span class="line">    &amp;&amp; apt autoremove -y \</span><br><span class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/*</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"># Additional packages require ~600MB</span><br><span class="line"># libreoffice  pinta language-pack-zh-hant language-pack-gnome-zh-hant firefox-locale-zh-hant libreoffice-l10n-zh-tw</span><br><span class="line"></span><br><span class="line"># tini for subreap</span><br><span class="line">ARG TINI_VERSION=v0.18.0</span><br><span class="line">ADD https://github.com/krallin/tini/releases/download/$&#123;TINI_VERSION&#125;/tini /bin/tini</span><br><span class="line">RUN chmod +x /bin/tini</span><br><span class="line"></span><br><span class="line"># ffmpeg</span><br><span class="line">RUN mkdir -p /usr/local/ffmpeg \</span><br><span class="line">    &amp;&amp; curl -sSL https://johnvansickle.com/ffmpeg/releases/ffmpeg-release-amd64-static.tar.xz | tar xJvf - -C /usr/local/ffmpeg/ --strip 1</span><br><span class="line"></span><br><span class="line"># python library</span><br><span class="line">COPY image/usr/local/lib/web/backend/requirements.txt /tmp/</span><br><span class="line">RUN apt-get update \</span><br><span class="line">    &amp;&amp; dpkg-query -W -f=&#x27;$&#123;Package&#125;\n&#x27; &gt; /tmp/a.txt \</span><br><span class="line">    &amp;&amp; apt-get install -y python-pip python-dev build-essential \</span><br><span class="line">&amp;&amp; pip install setuptools wheel &amp;&amp; pip install -r /tmp/requirements.txt \</span><br><span class="line">    &amp;&amp; dpkg-query -W -f=&#x27;$&#123;Package&#125;\n&#x27; &gt; /tmp/b.txt \</span><br><span class="line">    &amp;&amp; apt-get remove -y `diff --changed-group-format=&#x27;%&gt;&#x27; --unchanged-group-format=&#x27;&#x27; /tmp/a.txt /tmp/b.txt | xargs` \</span><br><span class="line">    &amp;&amp; apt-get autoclean -y \</span><br><span class="line">    &amp;&amp; apt-get autoremove -y \</span><br><span class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/* \</span><br><span class="line">    &amp;&amp; rm -rf /var/cache/apt/* /tmp/a.txt /tmp/b.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">################################################################################</span><br><span class="line"># builder</span><br><span class="line">################################################################################</span><br><span class="line">FROM ubuntu:18.04 as builder</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RUN sed -i &#x27;s#http://archive.ubuntu.com/#http://tw.archive.ubuntu.com/#&#x27; /etc/apt/sources.list; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RUN apt-get update \</span><br><span class="line">    &amp;&amp; apt-get install -y --no-install-recommends curl ca-certificates gnupg patch</span><br><span class="line"></span><br><span class="line"># nodejs</span><br><span class="line">RUN curl -sL https://deb.nodesource.com/setup_8.x | bash - \</span><br><span class="line">    &amp;&amp; apt-get install -y nodejs</span><br><span class="line"></span><br><span class="line"># yarn</span><br><span class="line">RUN curl -sS https://dl.yarnpkg.com/debian/pubkey.gpg | apt-key add - \</span><br><span class="line">    &amp;&amp; echo &quot;deb https://dl.yarnpkg.com/debian/ stable main&quot; | tee /etc/apt/sources.list.d/yarn.list \</span><br><span class="line">    &amp;&amp; apt-get update \</span><br><span class="line">    &amp;&amp; apt-get install -y yarn</span><br><span class="line"></span><br><span class="line"># build frontend</span><br><span class="line">COPY web /src/web</span><br><span class="line">RUN cd /src/web \</span><br><span class="line">    &amp;&amp; yarn \</span><br><span class="line">    &amp;&amp; npm run build</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">################################################################################</span><br><span class="line"># merge</span><br><span class="line">################################################################################</span><br><span class="line">FROM system</span><br><span class="line">LABEL maintainer=&quot;fcwu.tw@gmail.com&quot;</span><br><span class="line"></span><br><span class="line">COPY --from=builder /src/web/dist/ /usr/local/lib/web/frontend/</span><br><span class="line">COPY image /</span><br><span class="line"></span><br><span class="line">EXPOSE 80</span><br><span class="line">WORKDIR /root</span><br><span class="line">ENV HOME=/home/ubuntu \</span><br><span class="line">    SHELL=/bin/bash</span><br><span class="line">HEALTHCHECK --interval=30s --timeout=5s CMD curl --fail http://127.0.0.1:6079/api/health</span><br><span class="line">ENTRYPOINT [&quot;/startup.sh&quot;]</span><br></pre></td></tr></table></figure><p>发现这个镜像是从最基础的ubuntu18.04开始构建的，然后安装桌面对应的包。然后很关键的，安装了xvfb和x11vnc这两个包。xvfb是虚拟显卡，x11vnc则是用来提供x11服务的，以便主机通过x11客户端来访问桌面。</p><p>继续往下看，略过那些库，还有两个重要的操作，一个是把上下文中的web后端部署到docker中，但是我并不清楚开源社会采用什么方案，我理解里应该只需要提供相应的vnc端口即可，所以这一步没什么必要。另一个则是<code>ADD https://github.com/krallin/tini/releases/download/$&#123;TINI_VERSION&#125;/tini /bin/tini</code>我去到github项目主页下发现这是个用来初始化并启动系统的项目，但是似乎新版的docker已经自带这个功能？于是乎思路已经基本定了，在docker的系统中安装xvfb和x11vnc,用xvfb虚拟显卡，通过x11vnc提供显示服务。</p><h2 id="制作过程"><a href="#制作过程" class="headerlink" title="制作过程"></a>制作过程</h2><p>等等，一般的docker镜像制作都是从基础镜像开始构建的，但是我并不清楚ubuntukylin需要哪些包…这下子尴尬了。好在docker可以通过导入tar包来制作镜像。我找了一台已经安卓ubuntukylin19.04增强版的机器，把根目录下除了启动时自动生成的那些目录打包到一个tar包里，最后导入到docker制作成镜像。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -cvpf /tmp/system.tar --directory=/ --exclude=proc --exclude=sys --exclude=dev --exclude=run --exclude=boot .</span><br></pre></td></tr></table></figure><p>其中&#x2F;proc、&#x2F;sys、&#x2F;run、&#x2F;dev这几个目录都是系统启动时自动生成的，虽然也属于文件系统一部分，但是他们每次开机都会有变化，所以打包的时候就应该忽略它们。<br>然后执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat system.tar | docker import - ubuntukylin:19.04</span><br></pre></td></tr></table></figure><p>这样，镜像就制作完毕了。</p><p>接下来运行docker，恩？什么都没有发生？？？进入容器一看，发现ligtdm根本没有启动，这就很尴尬了…找了半天问题，没什么头绪，大概猜测和systemd有关，一不做二不休，手动启动ukui-session！恩？什么情况，我的桌面怎么没了，被docker内的ukui占用了，开始运行开机动画？我进到容器里查看，发现&#x2F;dev目录下挂载了宿主机的设备，去看了下runc的源码，最后得出的结论是systemd的改动，使得某些目录变成shared by default，所以主机显卡被docker占用了导致主机桌面挂掉了…吸取教训，先把&#x2F;dev的挂载点删了再启动…结果卡在登录进不去？？？然后同事说ukui-greeter出了bug，但是作者上周刚刚才离职了…行吧，不要登录锁屏了，直接把这个包卸载了。ok，终于成功的进了桌面，等等，窗口管理器怎么不见了，鼠标变成x了，想了想发现是自己头脑混乱了，在管理员权限下启动了桌面，用su lm(用户名),切换到普通用户lm，终于正常了。</p><p>但是我不能每次都手动去启动吧，必须在启动时自动执行脚本才行，于是在&#x2F;etc新建了一个rc.local脚本，每次先删除设备节点，然后通过xvfb创建虚拟显卡，设置显示区域，切换到普通用户并执行runsession脚本(chmod + x)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">rm /dev/fb0</span><br><span class="line">rm -rf /dev/dri</span><br><span class="line"></span><br><span class="line">export DISPLAY=:1</span><br><span class="line">Xvfb :1 -screen 0 1024x768x16 &gt; /opt/xvfb.log 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br><span class="line">su lm -c /home/lm/runsession</span><br><span class="line"></span><br><span class="line">sleep 10</span><br><span class="line"></span><br><span class="line">su lm -c /home/lm/runukwm</span><br></pre></td></tr></table></figure><p>runsession脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">export DISPLAY=:1</span><br><span class="line">DISPLAY=:1 x11vnc -display :1 -forever -bg -nopw -xkb</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">sleep</span> 30</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export QT4_IM_MODULE=fcitx </span><br><span class="line">export QT_IM_MODULE=fcitx </span><br><span class="line">export XMODIFIERS=@im=fcitx </span><br><span class="line">export GTK_IM_MODULE=fcitx </span><br><span class="line"></span><br><span class="line">/usr/bin/fcitx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">QT4_IM_MODULE=fcitx QT_IM_MODULE=fcitx XMODIFIERS=@im=fcitx GTK_IM_MODULE=fcitx DISPLAY=:1 ukui-session &gt; /home/lm/ukui-session.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">export DISPLAY=:1</span><br><span class="line">XDG_SESSION_TYPE=x11 DISPALY=:1 UKWM_VERBOSE=1 ukwm -r &gt; /home/lm/ukwm.log 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>脚本里主要就是启动了x11vnc设置了一些默认参数，最后启动ukui-session。这里要注意的是，rc.local执行脚本的时候会缺失很多环境变量，必须在脚本里指定，否则会导致一些异常行为。</p><p>禁用<em>plymouth</em>相关服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find -name *plymouth*.service</span><br></pre></td></tr></table></figure><p>全删了即可</p><p>至此，docker镜像完成了。</p><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p>执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name test1(容器名) --cap-add ALL --privileged=<span class="literal">true</span> -td readlnh/ubuntukylin-vnc-docker:19.04 /sbin/init</span><br></pre></td></tr></table></figure><p>创建并启动容器<br>使用如下命令查看ip地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect test1(容器名)</span><br></pre></td></tr></table></figure><p>最后通过vncview来连接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vncviewer 172.17.0.2(容器ip):5900(默认端口)</span><br></pre></td></tr></table></figure><p>效果如下<br><img src="https://raw.githubusercontent.com/readlnh/picture/master/ukui-docker.png"> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;由于要和开源社合办一个活动，要求线上线下同时进行，需要使用对方的云平台，本来以为只需要提供iso镜像就行了，没想到对方只支持docker镜像</summary>
      
    
    
    
    <category term="Linux" scheme="http://readlnh.github.io/categories/Linux/"/>
    
    <category term="docker" scheme="http://readlnh.github.io/categories/Linux/docker/"/>
    
    
  </entry>
  
  <entry>
    <title>How to use local unpublished crate in Rust by cargo</title>
    <link href="http://readlnh.github.io/2020/09/22/Rust/local_unpublished_crate_in_Rust/"/>
    <id>http://readlnh.github.io/2020/09/22/Rust/local_unpublished_crate_in_Rust/</id>
    <published>2020-09-22T19:21:00.000Z</published>
    <updated>2022-10-27T19:58:23.769Z</updated>
    
    <content type="html"><![CDATA[<p>Cargo is configured to look for dependencies on <a href="https://crates.io/">crates.io</a> by defalut. However I want to use a local crate. Fortunately, cargo supports to use libraries ont only on  <a href="https://crates.io/">crates.io</a>, but also ther registries, <code>git</code> repositories or subdirectories on our local file system.</p><h2 id="create-a-lib"><a href="#create-a-lib" class="headerlink" title="create a lib"></a>create a <code>lib</code></h2><p>Firstly, create a new package:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo new test_crate --lib</span><br></pre></td></tr></table></figure><p>Here we pass <code>--lib</code> because we’re making a library. Then the cargo generates:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── Cargo.lock</span><br><span class="line">├── Cargo.toml</span><br><span class="line">└── src</span><br><span class="line">    └── lib.rs</span><br><span class="line"></span><br><span class="line">1 directory, 3 files</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Let’s do something in <code>lib.rs</code>.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">public_function_in_test_crate</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;called `public_function_in_test_crate`&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> cool &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">cool_function</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;called `cool::cool_function`&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="set-Cargo-toml"><a href="#set-Cargo-toml" class="headerlink" title="set Cargo.toml"></a>set <code>Cargo.toml</code></h2><p>Then we create a new binary program use <code>cargo new test_extern_crate</code> and add a dependency section to our executable’s <code>Cargo.toml</code> and sepcify the path:</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">test_crate</span> = &#123;path = <span class="string">&quot;../test_crate&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies.test_crate]</span></span><br><span class="line"><span class="attr">path</span> = <span class="string">&quot;../test_crate&quot;</span></span><br></pre></td></tr></table></figure><p>Now we can use our local crate <code>test_crate</code> as folliwing:</p><p><em>main.rs:</em></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> test_crate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> test_crate::cool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    test_crate::<span class="title function_ invoke__">public_function_in_test_crate</span>();</span><br><span class="line">    test_crate::cool::<span class="title function_ invoke__">cool_function</span>();</span><br><span class="line">    cool::<span class="title function_ invoke__">cool_function</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>more details in more detals in <a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html">Cargo book</a> .</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Cargo is configured to look for dependencies on &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; by defalut. However I want to use a local crat</summary>
      
    
    
    
    <category term="Rust" scheme="http://readlnh.github.io/categories/Rust/"/>
    
    
    <category term="Rust" scheme="http://readlnh.github.io/tags/Rust/"/>
    
    <category term="cargo" scheme="http://readlnh.github.io/tags/cargo/"/>
    
    <category term="crate" scheme="http://readlnh.github.io/tags/crate/"/>
    
  </entry>
  
  <entry>
    <title>ref in Rust</title>
    <link href="http://readlnh.github.io/2020/09/22/Rust/ref_in_rust/"/>
    <id>http://readlnh.github.io/2020/09/22/Rust/ref_in_rust/</id>
    <published>2020-09-22T19:21:00.000Z</published>
    <updated>2022-10-27T19:58:23.769Z</updated>
    
    <content type="html"><![CDATA[<p>When doing pattern matching or destructuring via <code>let</code> binding, the <code>ref</code> keyword can be used to take references to the field of a struct&#x2F;tuple.</p><p>A <code>ref</code> borrow on the left side of an assignment is equivalent to an <code>&amp;</code> borrow on the right side.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i</span> = <span class="number">3</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">borrow1</span> = &amp;i;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;borrow1: &#123;&#125;&quot;</span>, borrow1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">ref</span> borrow2 = i;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;borrow2: &#123;&#125;&quot;</span>, borrow2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Destructuring a struct:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">i32</span>,</span><br><span class="line">    y: <span class="type">i32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">point</span> = Point&#123;x: <span class="number">1</span>, y: <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">Point</span>&#123;x: xx, y: yy&#125; = point;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, xx, yy);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">Point</span>&#123;x: <span class="keyword">ref</span> xx, y: <span class="keyword">ref</span> yy&#125; = point;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, *xx, *yy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;When doing pattern matching or destructuring via &lt;code&gt;let&lt;/code&gt; binding, the &lt;code&gt;ref&lt;/code&gt; keyword can be used to take references to</summary>
      
    
    
    
    <category term="Rust" scheme="http://readlnh.github.io/categories/Rust/"/>
    
    
    <category term="Rust" scheme="http://readlnh.github.io/tags/Rust/"/>
    
    <category term="ref" scheme="http://readlnh.github.io/tags/ref/"/>
    
  </entry>
  
  <entry>
    <title>Returning Traits with `dyn`</title>
    <link href="http://readlnh.github.io/2020/09/22/Rust/returning_traits_with_dyn/"/>
    <id>http://readlnh.github.io/2020/09/22/Rust/returning_traits_with_dyn/</id>
    <published>2020-09-22T19:21:00.000Z</published>
    <updated>2022-10-27T19:58:23.769Z</updated>
    
    <content type="html"><![CDATA[<p>Let’s see the following codes:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> rand::prelude::*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sheep</span> &#123;&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Cow</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">noise</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Animal</span> <span class="keyword">for</span> <span class="title class_">Sheep</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">noise</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> &#123;</span><br><span class="line">        <span class="string">&quot;baaaaaah!&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Animal</span> <span class="keyword">for</span> <span class="title class_">Cow</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">noise</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> &#123;</span><br><span class="line">        <span class="string">&quot;mooooooo!&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">random_animal</span>(random_number: <span class="type">f64</span>) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Animal&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> random_number &lt; <span class="number">0.5</span> &#123;</span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Sheep &#123;&#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Cow &#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">choose_cow</span>(random_number: <span class="type">f64</span>) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;choose_cow::The number is &#123;&#125;.&quot;</span>, random_number);</span><br><span class="line">    Cow &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">rng</span> = rand::<span class="title function_ invoke__">thread_rng</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">random_number</span> = rng.<span class="title function_ invoke__">gen</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">animal</span> = <span class="title function_ invoke__">random_animal</span>(random_number);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;You&#x27;ve randomly chosen an animal, and it says &#123;&#125;&quot;</span>, animal.<span class="title function_ invoke__">noise</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">animal</span> = <span class="title function_ invoke__">choose_cow</span>(random_number);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;You&#x27;ve chosen a cow, and it says &#123;&#125;&quot;</span>, animal.<span class="title function_ invoke__">noise</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>As the codes saying, if we’re returning <strong>a single type</strong> for our functions, we can use <code>impl Trait</code>, just as:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">choose_cow</span>(random_number: <span class="type">f64</span>) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;choose_cow::The number is &#123;&#125;.&quot;</span>, random_number);</span><br><span class="line">    Cow &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>However, if function returns <strong>multiable types</strong>, it doesn’t work. Because the Rust compiler needs to know how much space every functions’s return type requiers. This means the return type of a function must have a statically known size. We can’t write a function that returns <code>Animal</code>, because the different implementions will need different amounts of memory.</p><p>Instead of returning a trait object directly, our functions return a <code>Box</code> which contains some <code>Animal</code>.  A <code>box</code> is just a reference to some memory in the heap. Because a reference has a statically-known size, and the compiler can guarantee it points to a heap-allocated <code>Animal</code>, we can return a trait from our function!</p><p>Rust tries to be as explicit as possible whenever it allocates memory on the heap. So if your function returns a <strong>pointer-to-trait-on-heap</strong> in this way, you need to write the return type with the dyn keyword, e.g. <code>Box&lt;dyn Animal&gt;</code>.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Let’s see the following codes:&lt;/p&gt;
&lt;figure class=&quot;highlight rust&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span</summary>
      
    
    
    
    <category term="Rust" scheme="http://readlnh.github.io/categories/Rust/"/>
    
    
    <category term="Rust" scheme="http://readlnh.github.io/tags/Rust/"/>
    
    <category term="dyn" scheme="http://readlnh.github.io/tags/dyn/"/>
    
    <category term="trait" scheme="http://readlnh.github.io/tags/trait/"/>
    
  </entry>
  
  <entry>
    <title>笔记1-独立的Rust应用</title>
    <link href="http://readlnh.github.io/2020/09/22/Rust/blog_os%20notes/note_01/"/>
    <id>http://readlnh.github.io/2020/09/22/Rust/blog_os%20notes/note_01/</id>
    <published>2020-09-22T19:11:00.000Z</published>
    <updated>2022-10-27T19:58:23.769Z</updated>
    
    <content type="html"><![CDATA[<p>第一步，先通过cargo创建一个新项目：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo new rtoyos</span><br></pre></td></tr></table></figure><p>项目结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">├── Cargo.toml</span><br><span class="line">├── src</span><br><span class="line">│   ├── main.rs</span><br></pre></td></tr></table></figure><p>但是Rust项目默认都会链接到<code>std</code>标准库，而标准库会用到很多操作系统的功能，诸如线程，文件，网络等。所以我们要做的第一步就是实现一个不依赖于任何操作系统功能的Rust程序（裸机程序）。</p><h2 id="禁用标准库"><a href="#禁用标准库" class="headerlink" title="禁用标准库"></a>禁用标准库</h2><p>我们可以通过<code>![no_std]</code>来禁用<code>std</code>库。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![no_std]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行<code>cargo build</code>，可以看到如下错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">error: cannot find macro `println` in this scope</span><br><span class="line"> --&gt; src/main.rs:4:5</span><br><span class="line">  |</span><br><span class="line">4 |     println!(&quot;Hello, world!&quot;);</span><br><span class="line">  |     ^^^^^^^</span><br><span class="line"></span><br><span class="line">error: `#[panic_handler]` function required, but not found</span><br><span class="line"></span><br><span class="line">error: language item required, but not found: `eh_personality`</span><br><span class="line"></span><br><span class="line">error: aborting due to 3 previous errors</span><br></pre></td></tr></table></figure><h3 id="println-宏"><a href="#println-宏" class="headerlink" title="println! 宏"></a>println! 宏</h3><p><code>println!</code>宏依赖于<code>std</code>库，这里我们就先不使用它了。</p><h3 id="panic-处理函数"><a href="#panic-处理函数" class="headerlink" title="panic 处理函数"></a>panic 处理函数</h3><p>第二个错误说需要一个<code>#[panic_handler]</code>函数，这个函数会在程序<code>panic</code>的时候被调用。默认情况下，<code>std</code>中有<code>panic</code>的实现，然而由于我们是在<code>[no_std]</code>环境中，只能自己实现一个<code>panic</code>函数了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> core::panic::PanicInfo;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[panic_handler]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">panic</span>(_info: &amp;PanicInfo) <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们用了<code>core</code>库，这个库不需要操作系统支持。<code>PanicInfo</code>类型的参数会包含<code>panic</code>发生的文件，代码行数等错误信息。另外<code>!</code>标记表示这个函数的返回类型为<code>never type</code>，即永远不会返回。</p><h3 id="eh-personality-语义项"><a href="#eh-personality-语义项" class="headerlink" title="eh_personality 语义项"></a><code>eh_personality</code> 语义项</h3><p>语义项是编译器内部所需的特殊函数或类型，例如<code>Copy</code> trait（<code>#[lang = &quot;copy&quot;]</code>），又或是之前的<code>panic_handler</code>。<code>eh_personality</code>是用来标记函数实现堆栈展开的语义项，该语义与<code>panic</code>有关。</p><blockquote><p>堆栈展开 (Stack Unwinding) </p><p>通常当程序出现了异常时，从异常点开始会沿着 caller 调用栈一层一层回溯，直到找到某个函数能够捕获这个异常或终止程序。这个过程称为堆栈展开。</p><p>当程序出现异常时，我们需要沿着调用栈一层层回溯上去回收每个 caller 中定义的局部变量（这里的回收包括 C++ 的 RAII 的析构以及 Rust 的 drop 等）避免造成捕获异常并恢复后的内存溢出。</p><p>而在 Rust 中，panic 证明程序出现了错误，我们则会对于每个 caller 函数调用依次这个被标记为堆栈展开处理函数的函数进行清理。</p><p>这个处理函数是一个依赖于操作系统的复杂过程，在标准库中实现。但是我们禁用了标准库使得编译器找不到该过程的实现函数了。</p></blockquote><p>为了简单起见，我们将堆栈展开禁用，在<code>panic</code>发生时直接<code>abort</code>而不是依次获取堆栈信息。</p><p>在<code>Cargo.toml</code>中进行配置：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[profile.dev]</span></span><br><span class="line"><span class="attr">panic</span> = <span class="string">&quot;abort&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[profile.release]</span></span><br><span class="line"><span class="attr">panic</span> = <span class="string">&quot;abort&quot;</span></span><br></pre></td></tr></table></figure><p>现在,错误信息变成了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: requires `start` lang_item</span><br></pre></td></tr></table></figure><h2 id="移除C运行时依赖"><a href="#移除C运行时依赖" class="headerlink" title="移除C运行时依赖"></a>移除C运行时依赖</h2><p>大部分语言都有一个运行时（Runtime），这个运行时会在<code>main</code>函数之前被调用。以<code>Rust</code>为例，一个典型的链接了标准库的Rust程序会先跳转到C语言运行时环境<code>crt0</code>（C runtime zero），<code>crt0</code>会接着跳转到Rust运行时的入口点，这个入口点是被<code>start</code>语义所标记的。最后，Rust的运行时会调用<code>main</code>函数。</p><p>由于我们的程序无法访问标准库也就无法访问<code>crt0</code>和Rust运行时，所以我们需要定义我们自己的入口点。这里即使覆写<code>start</code>语义也是没用的，因为它仍然需要<code>crt0</code>的支持，所以我们要做的是直接覆写整个<code>ctr0</code>入口点。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![no_std]</span></span><br><span class="line"><span class="meta">#![no_main]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> core::panic::PanicInfo;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[panic_handler]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">panic</span>(_info: &amp;PanicInfo) <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">_start</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用<code>#![no_main]</code>属性来告诉编译器我们不使用常规入口点，并使用<code>_start</code>函数作为新的入口点（<code>_start</code>是大部分系统的默认入口点）。这里我们使用<code>#[no_mangle]</code>标记来禁用编译时的重命名，保证编译器生成的函数名仍然为<code>_start</code>，并使用<code>extern &quot;C&quot;</code>表示这是一个C语言函数。</p><p>此时我们再编译，发现错误变成了链接错误。</p><h2 id="解决链接错误"><a href="#解决链接错误" class="headerlink" title="解决链接错误"></a>解决链接错误</h2><p>链接器（Linker）是一个程序，它将生成的目标文件组合为一个可执行文件。不同的操作系统如 Windows、macOS 或 Linux，规定了不同的可执行文件格式，因此也各有自己的链接器，抛出不同的错误；但这些错误的根本原因还是相同的：链接器的默认配置假定程序依赖于 C 语言的运行时环境，但我们的程序并不依赖于它。以x86-64-linux为例，错误如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">error: linking with `cc` failed: <span class="built_in">exit</span> code: 1</span><br><span class="line">  |</span><br><span class="line">  = note: <span class="string">&quot;cc&quot;</span> <span class="string">&quot;-Wl,--as-needed&quot;</span> <span class="string">&quot;-Wl,-z,noexecstack&quot;</span> <span class="string">&quot;-m64&quot;</span> </span><br><span class="line">  ...</span><br><span class="line">          collect2: error: ld returned 1 <span class="built_in">exit</span> status</span><br></pre></td></tr></table></figure><p>我们只需要使用<code>-C link-arg</code>flag（<code>cargo rustc -- -C link-arg=-nostartfiles</code>）或是干脆选择编译为裸机目标（例如：<code>cargo build --target thumbv7em-none-eabihf</code>）即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;第一步，先通过cargo创建一个新项目：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td</summary>
      
    
    
    
    <category term="Rust" scheme="http://readlnh.github.io/categories/Rust/"/>
    
    <category term="blog_os notes" scheme="http://readlnh.github.io/categories/Rust/blog-os-notes/"/>
    
    
    <category term="Rust" scheme="http://readlnh.github.io/tags/Rust/"/>
    
    <category term="os" scheme="http://readlnh.github.io/tags/os/"/>
    
  </entry>
  
  <entry>
    <title>Modules</title>
    <link href="http://readlnh.github.io/2020/06/20/Rust/Rust-by-example-notes/Modules/"/>
    <id>http://readlnh.github.io/2020/06/20/Rust/Rust-by-example-notes/Modules/</id>
    <published>2020-06-20T17:32:00.000Z</published>
    <updated>2022-10-27T19:58:23.769Z</updated>
    
    <content type="html"><![CDATA[<p>A module is a colletction of items: </p><ul><li>functions</li><li>structs</li><li>traits</li><li><code>impl</code> blocks</li><li>other modules</li></ul><h2 id="features"><a href="#features" class="headerlink" title="features"></a>features</h2><p>Split code in logical units(modules), manage visibility(public&#x2F;private) between them.</p><h2 id="Visibility"><a href="#Visibility" class="headerlink" title="Visibility"></a>Visibility</h2><p>By <strong>default</strong>, the items in a module have <strong>private visibility</strong>, but this can be <strong>overridden</strong> with <code>pub</code>. Only the public items of a module can be accessed from outside the module scope.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> my_mod &#123;</span><br><span class="line">    <span class="comment">// Items in modules default to private visibility.</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">private_function</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;called `my_mod::private_function()`&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use the `pub` modifier to override default visibility.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">function</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;called `my_mod::function()`&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Items can access other items in the same module,</span></span><br><span class="line">    <span class="comment">// even when private.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">indirect_access</span>() &#123;  </span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;called `my_mod::indirect_access()`, that\n&gt; &quot;</span>);</span><br><span class="line">        <span class="title function_ invoke__">private_function</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> nested &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">function</span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;called `my_mod::nested::function()`&quot;</span>);</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Public items, including those inside nested modules, can be accessed from outside the parent module.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    my_mod::<span class="title function_ invoke__">function</span>();</span><br><span class="line">    my_mod::<span class="title function_ invoke__">indirect_access</span>();</span><br><span class="line">    my_mod::nested::<span class="title function_ invoke__">function</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="pub-crate"><a href="#pub-crate" class="headerlink" title="pub(crate)"></a><code>pub(crate)</code></h3><p>Functions declared using <code>pub(crate)</code> syntax are only visible within the current crate.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> my_mod &#123;</span><br><span class="line">    <span class="title function_ invoke__">pub</span>(<span class="keyword">crate</span>) <span class="keyword">fn</span> <span class="title function_">public_function_in_crate</span>() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    ...</span><br><span class="line">    my_mod::<span class="title function_ invoke__">public_function_in_crate</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>pub(crate)</code> can be called from anywhere in the same module.</p><h3 id="pub-in-path"><a href="#pub-in-path" class="headerlink" title="pub(in path)"></a><code>pub(in path)</code></h3><p>Functions declared by <code>pub(in path)</code> syntax are only visible within the given path. <code>path</code> must be a <strong>parent or ancestor</strong> module.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> my_mod &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> nested &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="title function_ invoke__">pub</span>(<span class="keyword">in</span> crate::my_mod) <span class="keyword">fn</span> <span class="title function_">public_function_in_my_mod</span>() &#123;</span><br><span class="line">            <span class="built_in">print!</span>(<span class="string">&quot;called `my_mod::nested::public_function_in_my_mod()`, that\n&gt; &quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>pub(crate)</code> items can only be called from within the module specified.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Error `public_function_in_my_mod()` is private.</span></span><br><span class="line">    <span class="comment">// my_mod::nested::public_function_in_my_mod();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="pub-self"><a href="#pub-self" class="headerlink" title="pub(self)"></a><code>pub(self)</code></h3><p>Functions declared by <code>pub(self)</code> syntax are only visible within the <strong>current module</strong>, which is <strong>same as leaving them private.</strong></p><h3 id="pub-super"><a href="#pub-super" class="headerlink" title="pub(super)"></a><code>pub(super)</code></h3><p>Functions declared using <code>pub(super)</code> syntax are only visible within the <strong>parent module</strong>.</p><h3 id="private-module"><a href="#private-module" class="headerlink" title="private module"></a>private module</h3><p>Nested modules follow the same rules for visibility.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">my_mod &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Nested modules follow the same rules for visibility</span></span><br><span class="line">    <span class="keyword">mod</span> private_nested &#123;</span><br><span class="line">        <span class="meta">#[allow(dead_code)]</span></span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">function</span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;called `my_mod::private_nested::function()`&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Private parent items will still restrict the visibility of a child item,</span></span><br><span class="line">        <span class="comment">// even if it is declared as visible within a bigger scope.</span></span><br><span class="line">        <span class="meta">#[allow(dead_code)]</span></span><br><span class="line">        <span class="title function_ invoke__">pub</span>(<span class="keyword">crate</span>) <span class="keyword">fn</span> <span class="title function_">restricted_function</span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;called `my_mod::private_nested::restricted_function()`&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="struct-visibility"><a href="#struct-visibility" class="headerlink" title="struct visibility"></a>struct visibility</h2><p>Structs have an extra level of visibility with their fields. The visibility <strong>defaults to private</strong>, and can be overridden with <code>pub</code> modifier.</p><h2 id="use-and-as"><a href="#use-and-as" class="headerlink" title="use and as"></a><code>use</code> and <code>as</code></h2><p>The <code>use</code> declaration can be used to bind a full path to a new name, and the <code>as</code> keywords can bind imports to a different name.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> xxx::yyy::function1;</span><br><span class="line"><span class="keyword">use</span> xxx::yyy::function2 <span class="keyword">as</span> f2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">function1</span>();</span><br><span class="line">    <span class="title function_ invoke__">f2</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="super-and-self"><a href="#super-and-self" class="headerlink" title="super and self"></a><code>super</code> and <code>self</code></h2><p>The <code>super</code> keyword refers to the <strong>parent scope</strong>, the <code>self</code> keyword refers to the current module scope - in the following case <code>mod1</code>. Note we can use <code>self</code> to access another module inside <code>mod1</code>(in this case <code>mod2</code>).</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">f</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;called `f()`&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> mod1 &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">test_super</span>() &#123;</span><br><span class="line">        super::<span class="title function_ invoke__">f</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">test_self</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;called `test_self()`&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mod</span> mod2 &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">function_in_mod2</span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;called `function_in_mod2()`&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">test_all</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">test_super</span>();</span><br><span class="line">        <span class="title function_ invoke__">test_self</span>();</span><br><span class="line">        self::<span class="title function_ invoke__">test_self</span>();</span><br><span class="line">        self::mod2::<span class="title function_ invoke__">function_in_mod2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    mod1::<span class="title function_ invoke__">test_all</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="File-heirarchy"><a href="#File-heirarchy" class="headerlink" title="File heirarchy"></a>File heirarchy</h2><p>Modules can be mapped to a file&#x2F;directory.</p><p>For example:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── main.rs</span><br><span class="line">└── my_mod</span><br><span class="line">    ├── mod.rs</span><br><span class="line">    └── nested_mod.rs</span><br></pre></td></tr></table></figure><p><em>main.rs:</em></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> my_mod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    my_mod::<span class="title function_ invoke__">function</span>();</span><br><span class="line">    my_mod::nested_mod::<span class="title function_ invoke__">function</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note the <code>mod my_mod</code>, this declaration will look for a file named <code>my_mod.rs</code> or <code>my_mod/mod.rs</code> and will insert its contents inside a module named <code>my_mod</code> under this scope.</p><p><em>mod.rs:</em></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> nested_mod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">function</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;called `my_mod::function()`&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Same as before. <code>pub mod nested_mod;</code> will locate the <code>nested_mod.rs</code> and insert it here under their respective modules. Note it follows the same rules for visibility. For instance, if we remove <code>pub</code> from <code>pub mod nested_mod</code>, we couldn’t call <code>my_mod::nested_mod::function();</code> in <code>main.rs</code>.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;A module is a colletction of items: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;functions&lt;/li&gt;
&lt;li&gt;structs&lt;/li&gt;
&lt;li&gt;traits&lt;/li&gt;
&lt;li&gt;&lt;code&gt;impl&lt;/code&gt; blocks&lt;/li&gt;
&lt;li&gt;o</summary>
      
    
    
    
    <category term="Rust" scheme="http://readlnh.github.io/categories/Rust/"/>
    
    <category term="Rust-by-example-notes" scheme="http://readlnh.github.io/categories/Rust/Rust-by-example-notes/"/>
    
    
    <category term="Rust" scheme="http://readlnh.github.io/tags/Rust/"/>
    
    <category term="Modules" scheme="http://readlnh.github.io/tags/Modules/"/>
    
  </entry>
  
  <entry>
    <title>Bonding in darwinia and substrate</title>
    <link href="http://readlnh.github.io/2020/01/03/Rust/substrate/bond_in_darwinia_and_substrate/"/>
    <id>http://readlnh.github.io/2020/01/03/Rust/substrate/bond_in_darwinia_and_substrate/</id>
    <published>2020-01-03T16:25:00.000Z</published>
    <updated>2022-10-27T19:58:23.769Z</updated>
    
    <content type="html"><![CDATA[<p>What does the <code>bond</code> mean? Somehow it can be translated as building up a strong <code>binding</code> relationship with a PoS network. If you want to put your tokens “at stake”, you must <code>bond</code> them first. But what does the bond actually do? What’s the difference between <code>substrate</code> and <code>darwinia-network</code>?</p><h2 id="Account-abstractions-for-bond-–-Stash-and-Controller"><a href="#Account-abstractions-for-bond-–-Stash-and-Controller" class="headerlink" title="Account abstractions for bond – Stash and Controller"></a>Account abstractions for <code>bond</code> – <code>Stash</code> and <code>Controller</code></h2><ul><li><p>Stash Key: The Stash account is meant to hold large amounts of funds. Its private key should be as secure as possible in a cold wallet.</p></li><li><p>Controller Key: The Controller account signals choices on behalf of the Stash account, like payout preferences, but should only hold a minimal amount of funds to pay transaction fees. Its private key should be secure as it can affect validator settings, but will be used somewhat regularly for validator maintenance.</p></li></ul><h2 id="Bond-in-Substrate"><a href="#Bond-in-Substrate" class="headerlink" title="Bond in Substrate"></a>Bond in Substrate</h2><p>Let’s have a look at the following codes:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">bond</span>(origin,</span><br><span class="line">controller: &lt;T::Lookup <span class="keyword">as</span> StaticLookup&gt;::Source,</span><br><span class="line"><span class="meta">#[compact]</span> value: BalanceOf&lt;T&gt;,</span><br><span class="line">payee: RewardDestination</span><br><span class="line">) &#123;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">stash</span> = <span class="title function_ invoke__">ensure_signed</span>(origin)?;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> &lt;Bonded&lt;T&gt;&gt;::<span class="title function_ invoke__">exists</span>(&amp;stash) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="string">&quot;stash already bonded&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">controller</span> = T::Lookup::<span class="title function_ invoke__">lookup</span>(controller)?;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> &lt;Ledger&lt;T&gt;&gt;::<span class="title function_ invoke__">exists</span>(&amp;controller) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="string">&quot;controller already paired&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reject a bond which is considered to be _dust_.</span></span><br><span class="line"><span class="keyword">if</span> value &lt; T::Currency::<span class="title function_ invoke__">minimum_balance</span>() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="string">&quot;can not bond with value less than minimum balance&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// You&#x27;re auto-bonded forever, here. We might improve this by only bonding when</span></span><br><span class="line"><span class="comment">// you actually validate/nominate and remove once you unbond __everything__.</span></span><br><span class="line">&lt;Bonded&lt;T&gt;&gt;::<span class="title function_ invoke__">insert</span>(&amp;stash, &amp;controller);</span><br><span class="line">&lt;Payee&lt;T&gt;&gt;::<span class="title function_ invoke__">insert</span>(&amp;stash, payee);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">stash_balance</span> = T::Currency::<span class="title function_ invoke__">free_balance</span>(&amp;stash);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">value</span> = value.<span class="title function_ invoke__">min</span>(stash_balance);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">item</span> = StakingLedger &#123; stash, total: value, active: value, unlocking: <span class="built_in">vec!</span>[] &#125;;</span><br><span class="line"><span class="keyword">Self</span>::<span class="title function_ invoke__">update_ledger</span>(&amp;controller, &amp;item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>It’s really simple. Take the origin account as a stash and lock up <code>value</code> of its balance. <code>controller</code> will be the account that controls it. <code>value</code> must be more than the <code>minimum_balance</code> specified by <code>T::Currency</code>. The dispatch origin for this call must be <em>Signed</em> by the stash account.</p><p>As we all know, “Verify First, Write Last” should be obeyed on Substrate, so verify wheather stash has been bonded and wheather controller has been paired already First. Make sure the <code>value</code> is bigger than the <code>minimum_balance</code> or the account would be a <em>dust</em> account that should be cleaned. </p><p>Then bond the <code>stash</code> and the <code>controller</code>.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Bonded&lt;T&gt;&gt;::<span class="title function_ invoke__">insert</span>(&amp;stash, &amp;controller);</span><br></pre></td></tr></table></figure><p>Set the Reward Destination:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Payee&lt;T&gt;&gt;::<span class="title function_ invoke__">insert</span>(&amp;stash, payee);</span><br></pre></td></tr></table></figure><p>Fianlly update the ledger.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">stash_balance</span> = T::Currency::<span class="title function_ invoke__">free_balance</span>(&amp;stash);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">value</span> = value.<span class="title function_ invoke__">min</span>(stash_balance);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">item</span> = StakingLedger &#123; stash, total: value, active: value, unlocking: <span class="built_in">vec!</span>[] &#125;;</span><br><span class="line"><span class="keyword">Self</span>::<span class="title function_ invoke__">update_ledger</span>(&amp;controller, &amp;item);</span><br></pre></td></tr></table></figure><p>Note if <code>value</code> is larger than <code>stash_balance</code>, the bond should not faill and will bond all the balances in the stash account to the controller.</p><p><code>bond</code> doesn’t mean transfer tokens to the <code>controller</code> account. The tokens are still at the <code>stash</code> account. Howerever, the Staking Ledger’s active item will become the minium between the <code>value</code> and the <code>stash_balance</code>.</p><h2 id="Bond-in-Darwinia"><a href="#Bond-in-Darwinia" class="headerlink" title="Bond in Darwinia"></a>Bond in Darwinia</h2><p>The <code>bond</code> operation in darwinia-network is almost the same as the <code>bond</code> operation in substrate. However, there are also something different between them. As darwinia has two tokens – <code>ring</code> and <code>kton</code>, the <code>bond</code> operation should be able to handle both tokens.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> value &#123;</span><br><span class="line">StakingBalances::<span class="title function_ invoke__">RingBalance</span>(r) =&gt; &#123;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">stash_balance</span> = T::Ring::<span class="title function_ invoke__">free_balance</span>(&amp;stash);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">value</span> = r.<span class="title function_ invoke__">min</span>(stash_balance);</span><br><span class="line"></span><br><span class="line"><span class="keyword">Self</span>::<span class="title function_ invoke__">bond_helper_in_ring</span>(&amp;stash, &amp;controller, value, promise_month, ledger);</span><br><span class="line"></span><br><span class="line">&lt;RingPool&lt;T&gt;&gt;::<span class="title function_ invoke__">mutate</span>(|r| *r += value);</span><br><span class="line">&lt;Module&lt;T&gt;&gt;::<span class="title function_ invoke__">deposit_event</span>(RawEvent::<span class="title function_ invoke__">Bond</span>(</span><br><span class="line">StakingBalances::<span class="title function_ invoke__">RingBalance</span>(value.<span class="title function_ invoke__">saturated_into</span>()),</span><br><span class="line">now,</span><br><span class="line">promise_month,</span><br><span class="line">));</span><br><span class="line">&#125;,</span><br><span class="line">StakingBalances::<span class="title function_ invoke__">KtonBalance</span>(k) =&gt; &#123;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">stash_balance</span> = T::Kton::<span class="title function_ invoke__">free_balance</span>(&amp;stash);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">value</span> = k.<span class="title function_ invoke__">min</span>(stash_balance);</span><br><span class="line"></span><br><span class="line"><span class="keyword">Self</span>::<span class="title function_ invoke__">bond_helper_in_kton</span>(&amp;controller, value, ledger);</span><br><span class="line"></span><br><span class="line">&lt;KtonPool&lt;T&gt;&gt;::<span class="title function_ invoke__">mutate</span>(|k| *k += value);</span><br><span class="line">&lt;Module&lt;T&gt;&gt;::<span class="title function_ invoke__">deposit_event</span>(RawEvent::<span class="title function_ invoke__">Bond</span>(</span><br><span class="line">StakingBalances::<span class="title function_ invoke__">KtonBalance</span>(value.<span class="title function_ invoke__">saturated_into</span>()),</span><br><span class="line">now,</span><br><span class="line">promise_month,</span><br><span class="line">));</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>There are also a special rule in darwinia-network: Users can choose to lock RING for 3-36 months in the process of Staking, and the system will offer a KTON token as reward for users participating in Staking. So we need <code>bond_helper_in_ring</code> and <code>bond_helper_in_kton</code>.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">bond_helper_in_ring</span>(</span><br><span class="line">stash: &amp;T::AccountId,</span><br><span class="line">controller: &amp;T::AccountId,</span><br><span class="line">value: RingBalance&lt;T&gt;,</span><br><span class="line">promise_month: Moment,</span><br><span class="line"><span class="keyword">mut</span> ledger: StakingLedger&lt;T::AccountId, RingBalance&lt;T&gt;, KtonBalance&lt;T&gt;, T::Moment&gt;,</span><br><span class="line">) &#123;</span><br><span class="line"><span class="comment">// if stash promise to a extra-lock</span></span><br><span class="line"><span class="comment">// there will be extra reward, kton, which</span></span><br><span class="line"><span class="comment">// can also be use to stake.</span></span><br><span class="line"><span class="keyword">if</span> promise_month &gt;= <span class="number">3</span> &#123;</span><br><span class="line">ledger.active_deposit_ring += value;</span><br><span class="line"><span class="comment">// for now, kton_return is free</span></span><br><span class="line"><span class="comment">// mint kton</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">kton_return</span> = inflation::compute_kton_return::&lt;T&gt;(value, promise_month);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">kton_positive_imbalance</span> = T::Kton::<span class="title function_ invoke__">deposit_creating</span>(&amp;stash, kton_return);</span><br><span class="line">T::KtonReward::<span class="title function_ invoke__">on_unbalanced</span>(kton_positive_imbalance);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">now</span> = &lt;timestamp::Module&lt;T&gt;&gt;::<span class="title function_ invoke__">now</span>();</span><br><span class="line">ledger.deposit_items.<span class="title function_ invoke__">push</span>(TimeDepositItem &#123;</span><br><span class="line">value,</span><br><span class="line">start_time: now,</span><br><span class="line">expire_time: now + T::Moment::<span class="title function_ invoke__">saturated_from</span>((promise_month * MONTH_IN_MILLISECONDS).<span class="title function_ invoke__">into</span>()),</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">ledger.active_ring = ledger.active_ring.<span class="title function_ invoke__">saturating_add</span>(value);</span><br><span class="line"></span><br><span class="line"><span class="keyword">Self</span>::<span class="title function_ invoke__">update_ledger</span>(&amp;controller, &amp;<span class="keyword">mut</span> ledger, StakingBalances::<span class="title function_ invoke__">RingBalance</span>(value));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>As the code shows, <code>bond_helper_in_ring</code> computes the <code>kton</code> should return and update the ledger. </p><p><code>bond_helper_in_kton</code> is simper, it just updates the ledger.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">bond_helper_in_kton</span>(</span><br><span class="line">controller: &amp;T::AccountId,</span><br><span class="line">value: KtonBalance&lt;T&gt;,</span><br><span class="line"><span class="keyword">mut</span> ledger: StakingLedger&lt;T::AccountId, RingBalance&lt;T&gt;, KtonBalance&lt;T&gt;, T::Moment&gt;,</span><br><span class="line">) &#123;</span><br><span class="line">ledger.active_kton += value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">Self</span>::<span class="title function_ invoke__">update_ledger</span>(&amp;controller, &amp;<span class="keyword">mut</span> ledger, StakingBalances::<span class="title function_ invoke__">KtonBalance</span>(value));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;What does the &lt;code&gt;bond&lt;/code&gt; mean? Somehow it can be translated as building up a strong &lt;code&gt;binding&lt;/code&gt; relationship with a PoS n</summary>
      
    
    
    
    <category term="Rust" scheme="http://readlnh.github.io/categories/Rust/"/>
    
    <category term="substrate" scheme="http://readlnh.github.io/categories/Rust/substrate/"/>
    
    
    <category term="Rust" scheme="http://readlnh.github.io/tags/Rust/"/>
    
    <category term="Substrate" scheme="http://readlnh.github.io/tags/Substrate/"/>
    
    <category term="blcokchain" scheme="http://readlnh.github.io/tags/blcokchain/"/>
    
  </entry>
  
  <entry>
    <title>Darwinia Eth-Backing</title>
    <link href="http://readlnh.github.io/2019/12/20/Rust/substrate/darwinia_eth_backing_notes/"/>
    <id>http://readlnh.github.io/2019/12/20/Rust/substrate/darwinia_eth_backing_notes/</id>
    <published>2019-12-20T17:37:00.000Z</published>
    <updated>2022-10-27T19:58:23.769Z</updated>
    
    <content type="html"><![CDATA[<p>这几天在写Darwinia的eth-backing模块的测试，遇到不少问题，写个记录。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>eth-backing模块的主要负责以太坊的跨链功能，darwinia跨链的思路大致如下：<br>我在以太坊上建立相应的智能合约，以太坊上的token和darwinia上的token应该是可以1:1兑换的。一笔钱当然不能花两次，所以以太坊上的钱转移到darwinia上时，以太坊上的token就应该被销毁。所以总体逻辑应该是:</p><ul><li><ol><li>以太坊上销毁这笔token</li></ol></li><li><ol start="2"><li>将销毁的证据proof发给darwinia</li></ol></li><li><ol start="3"><li>darwinia解析proof并在darwinia网络上生成token</li></ol></li></ul><p>这个过程在darwinia上被称为redeem。</p><h3 id="redeem"><a href="#redeem" class="headerlink" title="redeem"></a>redeem</h3><p>实际上，在darwinia上有两种原生资产：</p><ul><li>ring</li><li>kton</li></ul><p>所以理论上redeem应该有这两种对象。但是由于darwinia中锁定ring可以得到kton，所以ring有两种状态，一种是锁定中的，一种是普通的。如此一来redeem的对象又多了一个，对于锁定中的ring，我们可以认为它是被存在银行里，所以有一个存单deposit。故，redeem的对象如下：</p><ul><li>ring</li><li>kton</li><li>deposit</li></ul><h3 id="storage"><a href="#storage" class="headerlink" title="storage"></a>storage</h3><p>链上存储的数据大致可以分为三类：</p><ul><li><p>Redeem地址，即proof提交的地址，测试时需要预设</p><ul><li>RingRedeemAddress get(ring_redeem_address) config(): EthAddress;</li><li>KtonRedeemAddress get(kton_redeem_address) config(): EthAddress;</li><li>DepositRedeemAddress get(deposit_redeem_address) config(): EthAddress;</li></ul></li><li><p>链上初始抵押的ring和kton，每次redemm后就减掉</p><ul><li>RingLocked get(fn ring_locked) config(): RingBalanceOf<T>;</li><li>KtonLocked get(fn kton_locked) config(): KtonBalanceOf<T>;</li></ul></li><li><p>ProofVerifed，用来存储已经redeem的proof，保证一个proof不会redeem两次</p><ul><li>RingProofVerified get(ring_proof_verfied): map (H256, u64) &#x3D;&gt; Option<EthReceiptProof>;</li><li>KtonProofVerified get(kton_proof_verfied): map (H256, u64) &#x3D;&gt; Option<EthReceiptProof>;</li><li>DepositProofVerified</li></ul></li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>前两者的实现其实非常简单，就是检查proof，解析proof，token转账，保存proof信息等等。比较特殊的是deposit的redeem。因为deposit里面的ring是locked的ring，所以需要先将ring转入账户中然后再锁定起来，但是要注意的是这时候锁定是没有kton的，因为在之前就已经奖励过了。这里似乎用到了support回调？不知道具体为何可以这么做。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>测试部分由于不熟悉substrate的测试，所以浪费了很多时间。</p><h3 id="mock"><a href="#mock" class="headerlink" title="mock"></a>mock</h3><p>首先是mock，主要就是引入模块，以及初始化，初始化构造如下</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">ExtBuilder</span> &#123;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">build</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> runtime_io::TestExternalities &#123;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">t</span> = system::GenesisConfig::<span class="title function_ invoke__">default</span>().build_storage::&lt;Test&gt;().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">_</span> = GenesisConfig::&lt;Test&gt; &#123;</span><br><span class="line">ring_redeem_address: hex![<span class="string">&quot;dbc888d701167cbfb86486c516aafbefc3a4de6e&quot;</span>].<span class="title function_ invoke__">into</span>(),</span><br><span class="line">kton_redeem_address: hex![<span class="string">&quot;dbc888d701167cbfb86486c516aafbefc3a4de6e&quot;</span>].<span class="title function_ invoke__">into</span>(),</span><br><span class="line">deposit_redeem_address: hex![<span class="string">&quot;6ef538314829efa8386fc43386cb13b4e0a67d1e&quot;</span>].<span class="title function_ invoke__">into</span>(),</span><br><span class="line">ring_locked: <span class="number">20000000000000</span>,</span><br><span class="line">kton_locked: <span class="number">5000000000000</span>,</span><br><span class="line">&#125;</span><br><span class="line">.<span class="title function_ invoke__">assimilate_storage</span>(&amp;<span class="keyword">mut</span> t)</span><br><span class="line">.<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">t.<span class="title function_ invoke__">into</span>()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tests"><a href="#tests" class="headerlink" title="tests"></a>tests</h3><p>测试主要就是对比信息，这里没有太多的难点，主要就是需要调用一些辅助的api来帮助找出原始数据。另外就是关于调用其他模块的private函数的问题。</p><h4 id="Some-apis-tools-for-darwinia-eth-backing-development"><a href="#Some-apis-tools-for-darwinia-eth-backing-development" class="headerlink" title="Some apis(tools) for darwinia_eth_backing development"></a>Some apis(tools) for darwinia_eth_backing development</h4><ul><li><p>ropsten<br>  <a href="https://ropsten.etherscan.io/tx/0x59c6758bd2b93b2f060e471df8d6f4d901c453d2c2c012ba28088acfb94f821">https://ropsten.etherscan.io/tx/0x59c6758bd2b93b2f060e471df8d6f4d901c453d2c2c012ba28088acfb94f821</a></p></li><li><p>api for proof<br>  <a href="https://alpha.evolution.land/api/darwinia/receipt?tx=0x59c6758bd2b93b2f060e471df8d6f4d901c453d2c2c012ba28088acfb94f8216">https://alpha.evolution.land/api/darwinia/receipt?tx=0x59c6758bd2b93b2f060e471df8d6f4d901c453d2c2c012ba28088acfb94f8216</a></p><ul><li>tx &#x3D; Transaction Hash</li></ul><p>  Just change Transaction Hash</p><ul><li>index </li><li>proof</li><li>header_hash</li></ul></li><li><p>api for all information<br><a href="http://api-ropsten.etherscan.io/api?module=proxy&amp;action=eth_getBlockByNumber&amp;tag=0x6a910b&amp;boolean=true&amp;apikey=YourApiKeyToken">http://api-ropsten.etherscan.io/api?module=proxy&amp;action=eth_getBlockByNumber&amp;tag=0x6a910b&amp;boolean=true&amp;apikey=YourApiKeyToken</a></p><p>  Just replace the blocknumber(hex)</p></li></ul><h4 id="Calling-Private-Dispatchable-Functions"><a href="#Calling-Private-Dispatchable-Functions" class="headerlink" title="Calling Private Dispatchable Functions"></a>Calling Private Dispatchable Functions</h4><p>具体可参见<a href="https://www.shawntabrizi.com/substrate/extending-substrate-runtime-modules/#calling-private-dispatchable-functions">Extending Substrate Runtime Modules</a></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">assert_ok!(</span><br><span class="line">staking::Call::&lt;Test&gt;::<span class="title function_ invoke__">bond</span>(</span><br><span class="line">controller.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">StakingBalances::<span class="title function_ invoke__">Ring</span>(<span class="number">1</span>),</span><br><span class="line">RewardDestination::Controller,</span><br><span class="line"><span class="number">0</span>).<span class="title function_ invoke__">dispatch</span>(Origin::<span class="title function_ invoke__">signed</span>(expect_account_id.<span class="title function_ invoke__">clone</span>())</span><br><span class="line">)</span><br><span class="line">); </span><br></pre></td></tr></table></figure><p>这里需要调用<code>bond</code>函数，因为只有参与staking的token才可以lock，而参与staking需要controller。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这几天在写Darwinia的eth-backing模块的测试，遇到不少问题，写个记录。&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;eth-backing模块的主要负责以</summary>
      
    
    
    
    <category term="Rust" scheme="http://readlnh.github.io/categories/Rust/"/>
    
    <category term="substrate" scheme="http://readlnh.github.io/categories/Rust/substrate/"/>
    
    
    <category term="Rust" scheme="http://readlnh.github.io/tags/Rust/"/>
    
    <category term="Substrate" scheme="http://readlnh.github.io/tags/Substrate/"/>
    
    <category term="blcokchain" scheme="http://readlnh.github.io/tags/blcokchain/"/>
    
    <category term="darwinia" scheme="http://readlnh.github.io/tags/darwinia/"/>
    
  </entry>
  
  <entry>
    <title>Closure</title>
    <link href="http://readlnh.github.io/2019/11/27/Rust/Rust-by-example-notes/Closure/"/>
    <id>http://readlnh.github.io/2019/11/27/Rust/Rust-by-example-notes/Closure/</id>
    <published>2019-11-27T17:44:00.000Z</published>
    <updated>2022-10-27T19:58:23.769Z</updated>
    
    <content type="html"><![CDATA[<h2 id="About-closure"><a href="#About-closure" class="headerlink" title="About closure"></a>About closure</h2><p>Closure in Rust, also called lamba expressions or lambdas, are functions that can capture the enclosing environment.</p><p>Some characterisitics of closures include:</p><ul><li>using <code>||</code> instead of <code>()</code> around input variables.</li><li>optional body delimination <code>&#123;&#125;</code> for a single expression (mandatory otherwise).</li><li>the ability to capture the outer environment variables</li></ul><p><em>example</em></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">closure_annotated</span> = |i: <span class="type">i32</span>| <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123; i + <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">closure_inferred</span> = |i| i + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="title function_ invoke__">closure_annotated</span>(<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="title function_ invoke__">closure_inferred</span>(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Hi xxxx&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title function_ invoke__">x</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Capturing"><a href="#Capturing" class="headerlink" title="Capturing"></a>Capturing</h3><p>Capturing can flexibly adapt to the use case, sometimes moving and sometimes borrowing. Closures can capture variables:</p><ul><li>by reference: <code>&amp;T</code></li><li>by mutable reference: <code>&amp;mut T</code></li><li>by value: <code>T</code></li></ul><p>Closures preferentially capture variables by reference and only go lower when required.</p><p><em>example</em></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">use</span> std::mem;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &amp;T</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">color</span> = <span class="string">&quot;red&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">print</span> = || <span class="built_in">println!</span>(<span class="string">&quot;color is &#123;&#125;&quot;</span>, color);</span><br><span class="line">    <span class="title function_ invoke__">print</span>();</span><br><span class="line">    <span class="title function_ invoke__">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &amp;mut T</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">count</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">inc</span> = || &#123;</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;count is &#123;&#125;&quot;</span>, count);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title function_ invoke__">inc</span>();</span><br><span class="line">    <span class="title function_ invoke__">inc</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;count: &#123;&#125;&quot;</span>, count);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A non-copy type</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">movable</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">consume</span> = || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;movable: &#123;:?&#125;&quot;</span>, movable);</span><br><span class="line">        mem::<span class="title function_ invoke__">drop</span>(movable);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title function_ invoke__">consume</span>();</span><br><span class="line">    <span class="comment">//consume();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Howerver, if we do this:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">use</span> std::mem;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A non-copy type</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">movable</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">consume</span> = || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;movable: &#123;:?&#125;&quot;</span>, movable);</span><br><span class="line">        mem::<span class="title function_ invoke__">drop</span>(movable);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title function_ invoke__">consume</span>();</span><br><span class="line">    <span class="title function_ invoke__">consume</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>We would get:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">error[E0382]: use of moved value: `consume`</span><br><span class="line">  --&gt; src/main.rs:11:5</span><br><span class="line">   |</span><br><span class="line">10 |     consume();</span><br><span class="line">   |     ------- value moved here</span><br><span class="line">11 |     consume();</span><br><span class="line">   |     ^^^^^^^ value used here after move</span><br><span class="line">   |</span><br><span class="line">note: closure cannot be invoked more than once because it moves the variable `movable` out of its environment</span><br><span class="line">  --&gt; src/main.rs:8:19</span><br><span class="line">   |</span><br><span class="line">8  |         mem::drop(movable);</span><br><span class="line">   |                   ^^^^^^^</span><br><span class="line"></span><br><span class="line">error: aborting due to previous error</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0382`.</span><br><span class="line">error: Could not compile `capturing_test`.</span><br><span class="line"></span><br><span class="line">To learn more, run the <span class="built_in">command</span> again with --verbose.</span><br></pre></td></tr></table></figure><p><code>mem::drop</code> requires <code>T</code> so this mut take by value. A copy type would copy into the closure leaving the original untouched. A non-copy mut move and so <code>movable</code> immediately moves into the closure.</p><h4 id="move"><a href="#move" class="headerlink" title="move"></a><code>move</code></h4><p>Using <code>move</code> before vertical pipes forces closures to take ownership of captured variables:</p><p><em>example</em></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">vec</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">contains</span> = <span class="keyword">move</span> |needle| vec.<span class="title function_ invoke__">contains</span>(needle);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="title function_ invoke__">contains</span>(&amp;<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="title function_ invoke__">contains</span>(&amp;<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>output</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">true</span><br></pre></td></tr></table></figure><p>If we call  <code>vec.len()</code> later:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">vec</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">contains</span> = <span class="keyword">move</span> |needle| vec.<span class="title function_ invoke__">contains</span>(needle);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="title function_ invoke__">contains</span>(&amp;<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="title function_ invoke__">contains</span>(&amp;<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, vec.<span class="title function_ invoke__">len</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>We would get:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">error[E0382]: borrow of moved value: `vec`</span><br><span class="line"> --&gt; src/main.rs:9:20</span><br><span class="line">  |</span><br><span class="line">2 |     <span class="built_in">let</span> vec = vec![1, 2, 3];</span><br><span class="line">  |         --- move occurs because `vec` has <span class="built_in">type</span> `std::vec::Vec&lt;i32&gt;`, <span class="built_in">which</span> does not implement the `Copy` trait</span><br><span class="line">3 | </span><br><span class="line">4 |     <span class="built_in">let</span> contains = move |needle| vec.contains(needle);</span><br><span class="line">  |                    ------------- --- variable moved due to use <span class="keyword">in</span> closure</span><br><span class="line">  |                    |</span><br><span class="line">  |                    value moved into closure here</span><br><span class="line">...</span><br><span class="line">9 |     println!(<span class="string">&quot;&#123;&#125;&quot;</span>, vec.len());</span><br><span class="line">  |                    ^^^ value borrowed here after move</span><br><span class="line"></span><br><span class="line">error: aborting due to previous error</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0382`.</span><br><span class="line">error: Could not compile `movable_closure_test`.</span><br></pre></td></tr></table></figure><p>It’s no doubt that <code>vec</code> has been moved into the closure.</p><h3 id="As-input-parameters"><a href="#As-input-parameters" class="headerlink" title="As input parameters"></a>As input parameters</h3><p>While Rust choose how to capture variables on the fly mostly without type annotaions, this ambiguity is not allowed when writing functions. When taking a closure as an input parameter, the closure’s complete type must be annotated using one of a few <code>traits</code>. In order of decreasing restriction, they are:</p><ul><li><code>Fn</code>: the closure captures by reference(<code>&amp;T</code>)</li><li><code>FnMut</code>: the closure captures by mutable reference(<code>&amp;mut T</code>)</li><li><code>FnOnce</code>: the closure captures by value(<code>T</code>)</li></ul><p>For instance, consider a parameter annotated as <code>FnOnce</code>. This specifies that the closure may caputure by <code>&amp;T</code>, <code>&amp;mutT</code>, or <code>T</code>, but ultimately choose based on how the captured variables are used in the closure.</p><p>This is because if a move is possible, then any type of borrow should also be possible. Note that reverse is not true. If the paramenter is annotated as <code>Fn</code>, then capturing varibales by <code>&amp;mut T</code> or <code>T</code> are not allowed.</p><p><em>example</em></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">apply</span>&lt;F&gt;(f: F) <span class="keyword">where</span></span><br><span class="line">    F: <span class="title function_ invoke__">FnOnce</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">f</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">apply_to_3</span>&lt;F&gt;(f: F) <span class="punctuation">-&gt;</span> <span class="type">i32</span> <span class="keyword">where</span></span><br><span class="line">    F: <span class="title function_ invoke__">Fn</span>(<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">f</span>(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">use</span> std::mem;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">greeting</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">farewell</span> = <span class="string">&quot;goodbye&quot;</span>.<span class="title function_ invoke__">to_owned</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">dairy</span> = || &#123;</span><br><span class="line">        <span class="comment">// greeting is by reference: requries Fn</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;I said &#123;&#125;&quot;</span>, greeting);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Mutation forces `farewell` to be captured by mutable reference </span></span><br><span class="line">        <span class="comment">// Now require FnMut</span></span><br><span class="line">        farewell.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;!!!&quot;</span>);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Then I screamed &#123;&#125;&quot;</span>, farewell);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Now require FnOnce</span></span><br><span class="line">        mem::<span class="title function_ invoke__">drop</span>(farewell);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">apply</span>(dairy);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">double</span> = |x| x * <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="title function_ invoke__">apply_to_3</span>(double));   </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Type-anonymity"><a href="#Type-anonymity" class="headerlink" title="Type anonymity"></a>Type anonymity</h3><p>Using a closure as a parameter requires <strong>generics</strong>.This is necessary because of how thet are defined:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `F` must be generic.</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">apply</span>&lt;F&gt;(f: F) <span class="keyword">where</span></span><br><span class="line">    F: <span class="title function_ invoke__">FnOnce</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">f</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>When a closure is defined, the compiler implicitly creates a new anonymous structure to store the captured variables inside, meanwhile implementing the functionality via one of the <code>traits</code>: <code>Fn</code>, <code>FnMut</code> or <code>FnOnce</code> for this unknown type. This type is assigned to the variable which is stored until calling.</p><p>Since this new type if of unknown type, any usage in a function will require generics. However, an unbounded type parameter <T> would still be ambigious and not be allowed. Thus, bounding by one of the <code>traits</code>: <code>Fn</code>, <code>FnMut</code> or <code>FnOnce</code>(which it implements) is sufficient to specify its type.</p><h3 id="Input-functions"><a href="#Input-functions" class="headerlink" title="Input functions"></a>Input functions</h3><p>If you declare a function that takes a closure as a parameter, then any <em>function</em> that satisfies the trait bound of that closure can be passed as parameter.</p><p><em>example</em></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">call_me</span>&lt;F&gt;(f: F) </span><br><span class="line"><span class="keyword">where</span> </span><br><span class="line">    F: <span class="title function_ invoke__">Fn</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_ invoke__">f</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">function</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hi, I&#x27;m a function.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">closure</span> = | | <span class="built_in">println!</span>(<span class="string">&quot;Hi, I&#x27;m a closure.&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">call_me</span>(closure);</span><br><span class="line">    <span class="title function_ invoke__">call_me</span>(function);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>function</code> could also be used as a parameter as the same as <code>closure</code>.</p><h3 id="As-output-parameters"><a href="#As-output-parameters" class="headerlink" title="As output parameters"></a>As output parameters</h3><p>Returning closures as output parameters are also possible. However, anoymous closure types are, by definition, unknown, so we have to use <code>impl Trait</code> to return them.</p><p><em>example</em></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">create_fn</span>() <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Fn</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">text</span> = <span class="string">&quot;Fn&quot;</span>.<span class="title function_ invoke__">to_owned</span>();</span><br><span class="line">    <span class="keyword">move</span> || <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, text)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">create_fnmut</span>() <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">FnMut</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">text</span> = <span class="string">&quot;FnMut&quot;</span>.<span class="title function_ invoke__">to_owned</span>();</span><br><span class="line">    <span class="keyword">move</span> || <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, text)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">fn_plain</span> = <span class="title function_ invoke__">create_fn</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">fn_mut</span> = <span class="title function_ invoke__">create_fnmut</span>();</span><br><span class="line">    <span class="title function_ invoke__">fn_plain</span>();</span><br><span class="line">    <span class="title function_ invoke__">fn_mut</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note: <code>impl xxTrait</code> means a type that implements <code>xxTrait</code>. </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;About-closure&quot;&gt;&lt;a href=&quot;#About-closure&quot; class=&quot;headerlink&quot; title=&quot;About closure&quot;&gt;&lt;/a&gt;About closure&lt;/h2&gt;&lt;p&gt;Closure in Rust, also call</summary>
      
    
    
    
    <category term="Rust" scheme="http://readlnh.github.io/categories/Rust/"/>
    
    <category term="Rust-by-example-notes" scheme="http://readlnh.github.io/categories/Rust/Rust-by-example-notes/"/>
    
    
    <category term="Rust" scheme="http://readlnh.github.io/tags/Rust/"/>
    
    <category term="closure" scheme="http://readlnh.github.io/tags/closure/"/>
    
  </entry>
  
  <entry>
    <title>How to setup environment for loongson LS1C0300B(mipsel) on Ubuntu18.04</title>
    <link href="http://readlnh.github.io/2019/11/27/Linux/loongson/loongson_on_ubuntu/"/>
    <id>http://readlnh.github.io/2019/11/27/Linux/loongson/loongson_on_ubuntu/</id>
    <published>2019-11-27T14:48:00.000Z</published>
    <updated>2022-10-27T19:58:23.769Z</updated>
    
    <content type="html"><![CDATA[<p>This article is about setting up an environment for enbedded Linux application development for loongson. The resulting environment enables cross-platform application development for Loongson mipsel-based SOMs&#x2F;COMs using Ubuntu18.04 for application development.</p><h2 id="Communicate-with-loongson-development-board-using-USB-cable"><a href="#Communicate-with-loongson-development-board-using-USB-cable" class="headerlink" title="Communicate with loongson development board using USB cable"></a>Communicate with loongson development board using USB cable</h2><p>The first thing we need to do is communicating with hardware using USB cable.The boards are equipped with PL2303-based device. To be able to talk to an application, our machine must have appropriate PL2303 drivers. Fortunately, Ubuntu18.04 is default equipped with the PL2030 drivers(we could use <code>lsmod | grep pl2303</code> to check it). The only thing necessary is to check whether the Ubuntu machine can communicate over USB with the attached loongson development board.</p><p>To do this:</p><ul><li>Connect the PC via an USB cable to the USB UART port of the loongson development board.</li><li>Turn the board on.</li></ul><p>Note the correspondence between the colored cable and thier pinout:</p><ul><li>Black wire(GND)</li><li>Green wire(RX)</li><li>White wire(TX)</li></ul><p>Use <code>lsusb</code> command to list the usb devices connected to our machine. The output text of this command in terminal is something like this:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Bus 001 Device 007: ID 0bda:0129 Realtek Semiconductor Corp. RTS5129 Card Reader Controller</span><br><span class="line">Bus 001 Device 008: ID 0cf3:0036 Atheros Communications, Inc. </span><br><span class="line">Bus 001 Device 005: ID 0c45:6a04 Microdia </span><br><span class="line">Bus 001 Device 004: ID 17ef:6050 Lenovo </span><br><span class="line">Bus 001 Device 010: ID 046d:c326 Logitech, Inc. </span><br><span class="line">Bus 001 Device 011: ID 067b:2303 Prolific Technology, Inc. PL2303 Serial Port</span><br><span class="line">Bus 001 Device 002: ID 8087:8000 Intel Corp. </span><br><span class="line">Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub</span><br></pre></td></tr></table></figure><p>This shows that the PL2303 devices on the development board has been detected and that the drivers on the PC are running. To find out what RS232(UART) port is used by the USB driver, type:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg | grep -ie PL2303</span><br></pre></td></tr></table></figure><p>The return message:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[ 8907.910272] usbcore: registered new interface driver pl2303</span><br><span class="line">[ 8907.910924] usbserial: USB Serial support registered <span class="keyword">for</span> pl2303</span><br><span class="line">[ 8907.911054] pl2303 1-1.1:1.0: pl2303 converter detected</span><br><span class="line">[ 8907.913355] usb 1-1.1: pl2303 converter now attached to ttyUSB0</span><br></pre></td></tr></table></figure><p>The message tells us where the driver connects to a TTY port, in this case, <code>usb 1-1.1: pl2303 converter now attached to ttyUSB0</code>.</p><h3 id="picocom"><a href="#picocom" class="headerlink" title="picocom"></a>picocom</h3><p>Picocom is a minimal dumb-terminal emulation program that is great for accessing a serial port based Linux console; which is typical done when developing an embedded Linux based product. </p><p>Install picocom with this command:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install picocom</span><br></pre></td></tr></table></figure><p>Now, we know the serial port, set the speed to 115200 baud.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo picocom -b 115200 /dev/ttyUSB0</span><br></pre></td></tr></table></figure><p>Now, we can communicate with the board.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">picocom v2.2</span><br><span class="line"></span><br><span class="line">port is        : /dev/ttyUSB0</span><br><span class="line">flowcontrol    : none</span><br><span class="line">baudrate is    : 115200</span><br><span class="line">parity is      : none</span><br><span class="line">databits are   : 8</span><br><span class="line">stopbits are   : 1</span><br><span class="line">escape is      : C-a</span><br><span class="line"><span class="built_in">local</span> <span class="built_in">echo</span> is  : no</span><br><span class="line">noinit is      : no</span><br><span class="line">noreset is     : no</span><br><span class="line">nolock is      : no</span><br><span class="line">send_cmd is    : sz -vv</span><br><span class="line">receive_cmd is : rz -vv -E</span><br><span class="line">imap is        : </span><br><span class="line">omap is        : </span><br><span class="line">emap is        : crcrlf,delbs,</span><br><span class="line"></span><br><span class="line">Type [C-a] [C-h] to see available commands</span><br><span class="line"></span><br><span class="line">Terminal ready</span><br><span class="line"></span><br><span class="line">[root@Loongson:/]<span class="comment">#</span></span><br></pre></td></tr></table></figure><h2 id="Cross-Compile"><a href="#Cross-Compile" class="headerlink" title="Cross Compile"></a>Cross Compile</h2><p>Now we should install the cross tool chain. I download the <code>mips-loongson-gcc4.9-2019.08-05.linux-gnu.tar.gz</code> from the loongson website. Unpack the <em>tar.xz</em> file and move it to the <code>/opt</code>. Export the environment variables by adding the following lines into the <code>~/.bashrc</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;/opt/gcc-4.3-ls232/bin:<span class="variable">$PATH</span>&quot;</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;home/readlnh/Application/mipsel-linux-musl-cross/bin:<span class="variable">$PATH</span>&quot;</span> </span><br></pre></td></tr></table></figure><p>Don’t forget to run command <code>source ~/.bashrc</code>.</p><p>Now, we could compile <code>a.c</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mipsel-linux-gnu-gcc a.c</span><br></pre></td></tr></table></figure><h2 id="tftp-server"><a href="#tftp-server" class="headerlink" title="tftp server"></a>tftp server</h2><p>On ubuntu, run <code> sudo apt-get install tftpd-hpa tftp-hpa</code>. Then edit the <code>/etc/default/tftpd-hap</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /etc/default/tftpd-hpa                                                     </span></span><br><span class="line">  TFTP_USERNAME=<span class="string">&quot;tftp&quot;</span></span><br><span class="line">  TFTP_DIRECTORY=<span class="string">&quot;/home/readlnh/tftpboot&quot;</span></span><br><span class="line">  TFTP_ADDRESS=<span class="string">&quot;0.0.0.0:69&quot;</span></span><br><span class="line">  TFTP_OPTIONS=<span class="string">&quot;-l -c -s&quot;</span></span><br></pre></td></tr></table></figure><p>Create file <code>/etc/xinetd.d/tftp</code> with the following contents:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">service tftp</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">disable</span> = no</span><br><span class="line">socket_type = dgram</span><br><span class="line">protocol = udp</span><br><span class="line"><span class="built_in">wait</span> = <span class="built_in">yes</span></span><br><span class="line">user = root</span><br><span class="line">server = /usr/sbin/in.tftpd</span><br><span class="line">server_args = -s /home/readlnh/tftpboot -c</span><br><span class="line">per_source = 11</span><br><span class="line">cps = 100 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Create directory <code>/home/readlnh/tftpboot</code> and set its permissions:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo <span class="built_in">mkdir</span> /home/readlnh/tftpboot</span><br><span class="line">$ sudo <span class="built_in">chmod</span> -R 777 /home/readlnh/tftpboot</span><br><span class="line">$ sudo <span class="built_in">chown</span> -R nobody /home/readlnh/tftpboot</span><br></pre></td></tr></table></figure><p>Restart the <code>xinetd</code> service:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo service xinetd restart</span><br></pre></td></tr></table></figure><p>We could use <code>ifconfig</code> to get the ip address of our host machine. Make sure that ethernet cable is plugged into the board and a dhcp server is running in either your host machine or your router. In this case, my host machine’s ip address is <code>192.168.1.230</code>. Run <code>ifconfig</code> to set the ip address of the board to make sure the address fall into the same subnet, here I set it <code>192.168.1.108</code>. </p><p>Now, we could <code>ping</code> our host machine by <code>ping 192.168.1.230</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PING 192.168.1.230 (192.168.1.230): 56 data bytes</span><br><span class="line">64 bytes from 192.168.1.230: <span class="built_in">seq</span>=0 ttl=64 time=5.054 ms</span><br><span class="line">64 bytes from 192.168.1.230: <span class="built_in">seq</span>=1 ttl=64 time=4.140 ms</span><br><span class="line">64 bytes from 192.168.1.230: <span class="built_in">seq</span>=2 ttl=64 time=0.843 ms</span><br><span class="line">64 bytes from 192.168.1.230: <span class="built_in">seq</span>=3 ttl=64 time=3.813 ms</span><br><span class="line">64 bytes from 192.168.1.230: <span class="built_in">seq</span>=4 ttl=64 time=3.727 ms</span><br><span class="line">64 bytes from 192.168.1.230: <span class="built_in">seq</span>=5 ttl=64 time=0.562 ms</span><br><span class="line">64 bytes from 192.168.1.230: <span class="built_in">seq</span>=6 ttl=64 time=3.749 ms</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>Download the <code>a.out</code> we compiled before by <code>tftp -r a.out -g 192.168.1.230</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.out                100% |*******************************|  7796   0:00:00 ETA</span><br></pre></td></tr></table></figure><p>Run the <code>a.out</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@Loongson:/]<span class="comment">#chmod u+x a.out </span></span><br><span class="line">[root@Loongson:/]<span class="comment">#./a.out</span></span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure><h2 id="Hints"><a href="#Hints" class="headerlink" title="Hints"></a>Hints</h2><p>Loongson only provide <code>gcc4.9</code> for LSC1C0300B, howerver, the <code>mipsel-linux-gnu-gcc</code> in Ubuntu apt source also works well.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><p><a href="https://elinux.org/Communicate_with_hardware_using_USB_cable_for_Ubuntu">Communicate with hardware using USB cable for Ubuntu</a> </p></li><li><p><a href="https://rechtzeit.wordpress.com/2013/01/16/tftp-boot-using-u-boot/">TFTP Boot using u-boot</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;This article is about setting up an environment for enbedded Linux application development for loongson. The resulting environment enable</summary>
      
    
    
    
    <category term="Linux" scheme="http://readlnh.github.io/categories/Linux/"/>
    
    <category term="loongson" scheme="http://readlnh.github.io/categories/Linux/loongson/"/>
    
    
    <category term="loognson" scheme="http://readlnh.github.io/tags/loognson/"/>
    
    <category term="mipsel" scheme="http://readlnh.github.io/tags/mipsel/"/>
    
    <category term="cross-compile" scheme="http://readlnh.github.io/tags/cross-compile/"/>
    
  </entry>
  
  <entry>
    <title>Substrate-workshop notes</title>
    <link href="http://readlnh.github.io/2019/11/22/Rust/substrate/substrate-workshop_notes/"/>
    <id>http://readlnh.github.io/2019/11/22/Rust/substrate/substrate-workshop_notes/</id>
    <published>2019-11-22T11:13:00.000Z</published>
    <updated>2022-10-27T19:58:23.769Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h2><p>The Runtime is block execution logic of a blockchain, sometimes referred to as the state transition function <code>STF</code>. In <em>Substrate</em>, this is stored on-chain in an implementation-neutal(语言无关的), machine-executable(机器可执行的) format as a WebAssembly binary.</p><p><strong>Other system</strong></p><ul><li>Ethereum(human-readable format)</li><li>Bitcoin(not at all)</li></ul><p> The runtime is composed of multiple features and functionalities which work together to power your blockchain. Things like:</p><ul><li>Account Management</li><li>Token Balances</li><li>Governance</li><li>Runtime Upgrades</li><li>and more…</li></ul><h2 id="Creating-a-Module"><a href="#Creating-a-Module" class="headerlink" title="Creating a Module"></a>Creating a Module</h2><p>First, we need to create a module for our runtime. For that we will work with an empty module template which we will place in a new <code>substratekitties.rs</code> file:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">substratekitties</span><br><span class="line">|</span><br><span class="line">+-- runtime</span><br><span class="line">    |</span><br><span class="line">    +-- src</span><br><span class="line">        |</span><br><span class="line">        +-- lib.rs</span><br><span class="line">        |</span><br><span class="line">        +-- * substratekitties.rs</span><br><span class="line">    |</span><br><span class="line">    +-- template.rs </span><br></pre></td></tr></table></figure><p><em>substratekitties.rs</em></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> support::&#123;decl_storage, decl_module&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Trait</span>: system::Trait&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">decl_storage! &#123;</span><br><span class="line">    <span class="keyword">trait</span> <span class="title class_">Store</span> <span class="keyword">for</span> <span class="title class_">Module</span>&lt;T: Trait&gt; <span class="keyword">as</span> KittyStorage &#123;</span><br><span class="line">        <span class="comment">// Declare storge and getter functions here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">decl_module! &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Module</span>&lt;T: Trait&gt; <span class="keyword">for</span> <span class="title class_">enum</span> Call <span class="keyword">where</span> origin: T::Origin &#123;</span><br><span class="line">        <span class="comment">// Declare public functions here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This template allows us to start writing the most basic parts of our module, the public functions and the storage.</p><p><em>Note: The line <code>trait Store for Module&lt;T: Trait&gt; as NAME</code> is macro magic. That line as written is not valid Rust, but it gets converted to valid Rust code through the <code>decl_storage! macro</code>.</em></p><h2 id="Updating-our-Runtime"><a href="#Updating-our-Runtime" class="headerlink" title="Updating our Runtime"></a>Updating our Runtime</h2><p>For each module, we should:</p><ul><li>Import the Rust file containing the module</li><li>Implement its trait</li><li>Include the module into the <code>construct_runtime!</code> macro</li></ul><p><strong>Firstly</strong>, import the <code>substratekitties.rs</code>.<br>We should add this line into the <code>lib.rs</code>.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib.rs</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// Index of a block number in the chain.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">type</span> <span class="title class_">BlockNumber</span> = <span class="type">u64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Index of an account&#x27;s extrinsic in the chain.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">type</span> <span class="title class_">Nonce</span> = <span class="type">u64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add this line</span></span><br><span class="line"><span class="keyword">mod</span> substratekitties;</span><br></pre></td></tr></table></figure><p><em>Secondlly</em>, implement the traits. Our <code>Triat</code> implementation is very simple, because we haven’t defined anything in it yet.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">sudo</span>::Trait <span class="keyword">for</span> <span class="title class_">Runtime</span> &#123;</span><br><span class="line"><span class="comment">/// The uniquitous event type.</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Event</span> = Event;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Proposal</span> = Call;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add the implementation here</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">substratekitties</span>::Trait <span class="keyword">for</span> <span class="title class_">Runtime</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Finally</strong>, add this line at the end of our <code>construct_runtime!</code> definition:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// lib.rs</span><br><span class="line"></span><br><span class="line">construct_runtime!(</span><br><span class="line">pub enum Runtime with Log(InternalLog: DigestItem&lt;Hash, AuthorityId, AuthoritySignature&gt;) where</span><br><span class="line">Block = Block,</span><br><span class="line">NodeBlock = opaque::Block,</span><br><span class="line">UncheckedExtrinsic = UncheckedExtrinsic</span><br><span class="line">&#123;</span><br><span class="line">System: system::&#123;default, Log(ChangesTrieRoot)&#125;,</span><br><span class="line">Timestamp: timestamp::&#123;Module, Call, Storage, Config&lt;T&gt;, Inherent&#125;,</span><br><span class="line">Consensus: consensus::&#123;Module, Call, Storage, Config&lt;T&gt;, Log(AuthoritiesChange), Inherent&#125;,</span><br><span class="line">Aura: aura::&#123;Module&#125;,</span><br><span class="line">Indices: indices,</span><br><span class="line">Balances: balances,</span><br><span class="line">Sudo: sudo,</span><br><span class="line"></span><br><span class="line">// Add this line</span><br><span class="line">Substratekitties: substratekitties::&#123;Module, Call, Storage&#125;,</span><br><span class="line">&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>Note than we have added three <code>types</code> to this definition(<code>Module</code>, <code>Call</code>, <code>Storage</code>), all of which are produced by the macros defined in our template.</p><h2 id="Creating-a-Storage-Value"><a href="#Creating-a-Storage-Value" class="headerlink" title="Creating a Storage Value"></a>Creating a Storage Value</h2><p>Let’s add a function which stores a variable. Substrate natively supports all the primitive types avaliable in Rust(<code>bool</code>, <code>u8</code>, <code>u32</code>, etc..) and custom types sepcific to Substrate(<code>AccountId</code>m <code>BlockNumber</code>, <code>Hash</code>, <a href="https://polkadot.js.org/api/types/#codec-types">etc..</a> )</p><p>We can declare a simple storage item like this:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">decl_storage! &#123;</span><br><span class="line">    <span class="keyword">trait</span> <span class="title class_">Store</span> <span class="keyword">for</span> <span class="title class_">Module</span>&lt;T: Trait&gt; <span class="keyword">as</span> Example &#123;</span><br><span class="line">        MyU32: <span class="type">u32</span>;</span><br><span class="line">        MyBool <span class="title function_ invoke__">get</span>(my_bool_getter): <span class="type">bool</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Here we have defined two variables: a <code>u32</code> and a <code>bool</code> with a getter function named <code>my_bool_getter</code>. The <code>get</code> parameter is <strong>optional</strong>, but i<em>f you add it to your storage item it will expose a getter function with the name specified(<code>fn getter_name() -&gt; Type</code>)</em>.</p><p>To store these basic values, we need to import the <code>support::StorageValue</code> module.</p><p>The function used to access a <code>StorageValue</code> are defined in <a href="https://substrate.dev/rustdocs/v1.0/srml_support/storage/trait.StorageValue.html">StorageValue</a>.</p><p>Now, create a storage value called <code>Value</code> which stores as <code>u64</code>.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">decl_storage! &#123;</span><br><span class="line">    <span class="keyword">trait</span> <span class="title class_">Store</span> <span class="keyword">for</span> <span class="title class_">Module</span>&lt;T: Trait&gt; <span class="keyword">as</span> KittyStorage &#123;</span><br><span class="line">        <span class="comment">// Declare storage and getter functions here</span></span><br><span class="line">        Value: <span class="type">u64</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Storing-a-Value"><a href="#Storing-a-Value" class="headerlink" title="Storing a Value"></a>Storing a Value</h2><p>Now that we have our <em>storage value</em> declared in our runtime, we can actually create a <em>function</em> to push a value to it.</p><h3 id="Declaring-a-public-function"><a href="#Declaring-a-public-function" class="headerlink" title="Declaring a public function"></a>Declaring a public function</h3><p>We need to define runtime functions that will set and modify our storage values. This can be done within our <code>decl_module!</code> macro, which declares all the entry points that your module handles.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add these imports: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">use</span> support::&#123;dispatch::<span class="type">Result</span>, StorageValue&#125;;</span><br><span class="line"><span class="keyword">use</span> system::ensure_signed;</span><br><span class="line"></span><br><span class="line">decl_module! &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Module</span>&lt;T: Trait&gt; <span class="keyword">for</span> <span class="title class_">enum</span> Call <span class="keyword">where</span> origin: T::Origin &#123;</span><br><span class="line">        <span class="comment">// Declare public functions here</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">set_value</span>(origin, value: <span class="type">u64</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">_sender</span> = <span class="title function_ invoke__">ensure_signed</span>(origin)?;</span><br><span class="line"></span><br><span class="line">            &lt;Value&lt;T&gt;&gt;::<span class="title function_ invoke__">put</span>(value);</span><br><span class="line"></span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Function-Structure"><a href="#Function-Structure" class="headerlink" title="Function Structure"></a>Function Structure</h3><p>Module functions exposed here should always take the form:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">foo</span>(origin, bar: Bar, baz: Baz, ...) <span class="punctuation">-&gt;</span> <span class="type">Result</span>;</span><br></pre></td></tr></table></figure><h4 id="Origin"><a href="#Origin" class="headerlink" title="Origin"></a>Origin</h4><p>The first argument of these function is always <code>origin</code>. <code>origin</code> contains information about where the call originated from. This is generally split into three groups:</p><ul><li>Public calls that are signed by an external account.</li><li>Root calls that are allowed to be made only by the governance system.</li><li>Inherent calls that are allowed to be made only by the block authors and validators.</li></ul><h4 id="Checking-for-a-Signed-Message"><a href="#Checking-for-a-Signed-Message" class="headerlink" title="Checking for a Signed Message"></a>Checking for a Signed Message</h4><p>The first argument in any of these module functions is the <code>origin</code>. There are three convenience call in <code>system</code> that do the matching for your and return a convenient result: <code>ensure_signed</code>, <code>ensure_root</code> and <code>ensire_inherent</code>. <strong>You should always match against them as the first thing you do in your function.</strong></p><p>We can use the <code>ensure_signed()</code> function from <code>system::ensure_signed</code> to check the origin, and “ensure” that the messaged is signed by a valid account.</p><h2 id="Storage-Mapping"><a href="#Storage-Mapping" class="headerlink" title="Storage Mapping"></a>Storage Mapping</h2><p>Our last runtime only allowed us to <strong>store a single value across all users</strong> of our blockchain. As we start thinking toward our collectables chain, it makes sense to add support to have their own value stored.</p><p>To enable this, we will replace our single value storage with a storage mapping.</p><p>The functions used to access a StorageMap are in <a href="https://substrate.dev/rustdocs/v1.0/srml_support/storage/trait.StorageMap.html">StorageMap</a> </p><p>Now our storage example is updated to store a map from <code>AccountId</code> to a <code>u64</code>.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// change `StorageValue` to `StorageMap`</span></span><br><span class="line"></span><br><span class="line">decl_module! &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Module</span>&lt;T: Trait&gt; <span class="keyword">for</span> <span class="title class_">enum</span> Call <span class="keyword">where</span> origin: T::Origin &#123;</span><br><span class="line">        <span class="comment">// Declare public functions here</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">set_value</span>(origin, value: <span class="type">u64</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">sender</span> = <span class="title function_ invoke__">ensure_signed</span>(origin)?;</span><br><span class="line"></span><br><span class="line">            &lt;Value&lt;T&gt;&gt;::<span class="title function_ invoke__">insert</span>(sender, value);</span><br><span class="line"></span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Storing-a-Structure"><a href="#Storing-a-Structure" class="headerlink" title="Storing a Structure"></a>Storing a Structure</h2><p>We can define a <code>struct</code> for digital kitties and store them in our runtime storage like so:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Encode, Decode, Default, Clone, PartialEq)]</span></span><br><span class="line"><span class="meta">#[cfg_attr(feature = <span class="string">&quot;std&quot;</span>, derive(Debug))]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Kitty</span>&lt;Hash, Balance&gt; &#123;</span><br><span class="line">    id: Hash,</span><br><span class="line">    dna: Hash,</span><br><span class="line">    price: Balance,</span><br><span class="line">    gen: <span class="type">u64</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note: To use the custom <code>Encode</code> and <code>Decode</code> traits, you will need to import them from the <code>parity_codec</code> crate:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> parity_codec::&#123;Encode, Decode&#125;;</span><br></pre></td></tr></table></figure><p>We define our example struct using a generic as one of the types that we store. This will be important when trying to use custom Substrate types like <code>AccountId</code> or <code>Balance</code> within our struct as we wil need to pass in these types every time we use our struct.</p><p>So, if we wanted to store a <code>Balance</code> in <code>some_generic</code> and <code>Hash</code> in <code>some_other_generic</code>, we wiuld need to define our storage item like this:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">decl_storage! &#123;</span><br><span class="line">    <span class="keyword">trait</span> <span class="title class_">Store</span> <span class="keyword">for</span> <span class="title class_">Module</span>&lt;T: Trait&gt; <span class="keyword">as</span> Example &#123;</span><br><span class="line">        MyItem: map T::AccountId =&gt; MyStruct&lt;T::Balance, T::Hash&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>For the purpose of clarity, we will name a generic type for <code>T::AccountId</code> as <code>AccountId</code> and <code>T::Balance</code> as <code>Balance</code>.</p><p><a href="https://github.com/paritytech/substrate/wiki/FAQ">Read More</a> </p><p>For our example:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">decl_storage! &#123;</span><br><span class="line">    <span class="keyword">trait</span> <span class="title class_">Store</span> <span class="keyword">for</span> <span class="title class_">Module</span>&lt;T: Trait&gt; <span class="keyword">as</span> KittyStorage &#123;</span><br><span class="line">        <span class="comment">// Declare storage and getter functions here</span></span><br><span class="line">        OwnedKitty <span class="title function_ invoke__">get</span>(kitty_of_owner): map T::AccountId =&gt; Kitty&lt;T::Hash, T::Balance&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>We update the storage item to sotre a <code>Kitty&lt;T::Hash, T::Balance&gt;</code>, add a getter function named <code>kitty_of_owner</code>.</p><p>Now, we have initialized our custom struct in our runtime storage, we can now push values and modify it.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">decl_module! &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Module</span>&lt;T: Trait&gt; <span class="keyword">for</span> <span class="title class_">enum</span> Call <span class="keyword">where</span> origin: T::Origin &#123;</span><br><span class="line">        <span class="comment">// Declare public functions here</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">create_kitty</span>(origin) <span class="punctuation">-&gt;</span> <span class="type">Result</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">sender</span> = <span class="title function_ invoke__">ensure_signed</span>(origin)?;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">new_kitty</span> = Kitty &#123;</span><br><span class="line">                id: &lt;T <span class="keyword">as</span> system::Trait&gt;::Hashing::<span class="title function_ invoke__">hash_of</span>(&amp;<span class="number">0</span>),</span><br><span class="line">                dna: &lt;T <span class="keyword">as</span> system::Trait&gt;::Hashing::<span class="title function_ invoke__">hash_of</span>(&amp;<span class="number">0</span>),</span><br><span class="line">                price: &lt;T::Balance <span class="keyword">as</span> As&lt;<span class="type">u64</span>&gt;&gt;::<span class="title function_ invoke__">sa</span>(<span class="number">0</span>),</span><br><span class="line">                gen: <span class="number">0</span>,</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            &lt;OwnedKitty&lt;T&gt;&gt;::<span class="title function_ invoke__">insert</span>(sender, new_kitty);</span><br><span class="line">            </span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Generating-Random-Data"><a href="#Generating-Random-Data" class="headerlink" title="Generating Random Data"></a>Generating Random Data</h2><p>Now, we allowed each user to create their own kitty. However, they weren’t very unique. Let’s fix that.</p><h3 id="Generating-a-Random-Seed"><a href="#Generating-a-Random-Seed" class="headerlink" title="Generating a Random Seed"></a>Generating a Random Seed</h3><p>In order to tell these kitties apart, we need to generate a unique <code>id</code> for each kitty and some random <code>dna</code>.</p><p>We can securely fetch some randomness from our chain using the <code>system</code> module:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;system::Module&lt;T&gt;&gt;::<span class="title function_ invoke__">random_seed</span>()</span><br></pre></td></tr></table></figure><p>Substrate uses a safe mixing algorithm that uses the entropy of previous blocks to generate new random data for each subsequent block.</p><p>However, since it is dependent on previous blocks, it can take over 80 blocks to fully warm up, and you may notice the seed will not change until then.</p><h3 id="Using-a-Nonce"><a href="#Using-a-Nonce" class="headerlink" title="Using a Nonce"></a>Using a Nonce</h3><p>Since the random seed does not change for multiple transactions in the same block, and since it may not even generate a random seed for the first 80 blocks, it is important that we also introduce a <code>nonce</code> which our module can manage. Furthermore, we can also user a user specific property like the <code>AccountId</code> to introduce a bit more entropy.</p><h3 id="Hashing-Data"><a href="#Hashing-Data" class="headerlink" title="Hashing Data"></a>Hashing Data</h3><p>A random number generator:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">sender</span> = <span class="title function_ invoke__">ensure_signed</span>(origin)?;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">nonce</span> = &lt;Nonce&lt;T&gt;&gt;::<span class="title function_ invoke__">get</span>();</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">random_seed</span> = &lt;system::Module&lt;T&gt;&gt;::<span class="title function_ invoke__">random_seed</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">random_hash</span> = (random_seed, &amp;sender, nonce).<span class="title function_ invoke__">using_encoded</span>(&lt;T <span class="keyword">as</span> system::Trait&gt;::Hashing::hash);</span><br></pre></td></tr></table></figure><p>We can use this <code>random_hash</code> to populate both the <code>id</code> and <code>dna</code> for our kitty.</p><p><code>using_encoded</code>: Convert self to a slice and then <em>invoke the given closure with it</em>.</p><h3 id="Checking-for-Collision"><a href="#Checking-for-Collision" class="headerlink" title="Checking for Collision"></a>Checking for Collision</h3><p>The <code>id</code> on the <code>Kitty</code> should be unique. We can do this with a new storage item <code>Kitties</code> which will be a mapping from <code>id</code>(<code>Hash</code>) to the <code>Kitty</code> object.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Kitties: map T::Hash =&gt; Kitty&lt;T::Hash, T::Balance&gt;;</span><br></pre></td></tr></table></figure><p>For this object, we can easily check for collisions by simply checking whether this storage item already contains a mapping using a particular <code>id</code>.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ensure!(!&lt;Kitties&lt;T&gt;&gt;::<span class="title function_ invoke__">exists</span>(random_hash), <span class="string">&quot;This id is already exists&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="Updating-the-code"><a href="#Updating-the-code" class="headerlink" title="Updating the code"></a>Updating the code</h3><p>So we should update our storage module. First, we should add tewo new kitty storage item.</p><ul><li><code>Kitties</code><br>  point from our kitty’s id to the <code>Kitty</code> object</li><li><code>KittyOwner</code><br>  point from our kitty’s id to the owner</li></ul><p>Then update the <code>OwnedKitty</code> storage below to store the kitty’s id rather than the <code>Kitty</code> object.</p><p>Finally, add a <code>u64</code> value named <code>Nonce</code>.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">decl_storage! &#123;</span><br><span class="line">    <span class="keyword">trait</span> <span class="title class_">Store</span> <span class="keyword">for</span> <span class="title class_">Module</span>&lt;T: Trait&gt; <span class="keyword">as</span> KittyStorage &#123;</span><br><span class="line">        <span class="comment">// Declare storage and getter functions here</span></span><br><span class="line">        Kitties: map T::Hash =&gt; Kitty&lt;T::Hash, T::Balance&gt;;</span><br><span class="line">        KittyOwner: map T::Hash =&gt; <span class="type">Option</span>&lt;T::AccountId&gt;;</span><br><span class="line">        </span><br><span class="line">        OwnedKitty <span class="title function_ invoke__">get</span>(kitty_of_owner): map T::AccountId =&gt; T::Hash;</span><br><span class="line"></span><br><span class="line">        Nonce: <span class="type">u64</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The <code>create_kitty</code> should be updated too:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">decl_module! &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Module</span>&lt;T: Trait&gt; <span class="keyword">for</span> <span class="title class_">enum</span> Call <span class="keyword">where</span> origin: T::Origin &#123;</span><br><span class="line">        <span class="comment">// Declare public functions here</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">create_kitty</span>(origin) <span class="punctuation">-&gt;</span> <span class="type">Result</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">sender</span> = <span class="title function_ invoke__">ensure_signed</span>(origin)?;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">nonce</span> = &lt;Nonce&lt;T&gt;&gt;::<span class="title function_ invoke__">get</span>();</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">random_seed</span> = &lt;system::Module&lt;T&gt;&gt;::<span class="title function_ invoke__">random_seed</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">random_hash</span> = (random_seed, &amp;sender, nonce).<span class="title function_ invoke__">using_encoded</span>(&lt;T <span class="keyword">as</span> system::Trait&gt;::Hashing::hash);</span><br><span class="line"></span><br><span class="line">            ensure!(!&lt;Kitties&lt;T&gt;&gt;::<span class="title function_ invoke__">exists</span>(random_hash), <span class="string">&quot;This id is already exists&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &lt;Nonce&lt;T&gt;&gt;::<span class="title function_ invoke__">mutate</span>(|n| *n += <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> <span class="variable">new_kitty</span> = Kitty &#123;</span><br><span class="line">                id: random_hash,</span><br><span class="line">                dna: random_hash,</span><br><span class="line">                price: &lt;T::Balance <span class="keyword">as</span> As&lt;<span class="type">u64</span>&gt;&gt;::<span class="title function_ invoke__">sa</span>(<span class="number">0</span>),</span><br><span class="line">                gen: <span class="number">0</span>,</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            &lt;Kitties&lt;T&gt;&gt;::<span class="title function_ invoke__">insert</span>(random_hash, new_kitty);</span><br><span class="line">            &lt;KittyOwner&lt;T&gt;&gt;::<span class="title function_ invoke__">insert</span>(random_hash, &amp;sender);</span><br><span class="line"></span><br><span class="line">            &lt;OwnedKitty&lt;T&gt;&gt;::<span class="title function_ invoke__">insert</span>(&amp;sender, random_hash);</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Nonce</code> will be a new item in our storage which we will <em>simply increment whenever we use it</em>.</p><h2 id="Creating-an-Event"><a href="#Creating-an-Event" class="headerlink" title="Creating an Event"></a>Creating an Event</h2><p>On Substrate, <strong>even though a transaction may be finalized, it does not necessarily imply that the function executed by that transaction fully succeed.</strong></p><p>To know that, we should <strong>emit an <code>Event</code> at the end of the function</strong> to not only report success, but to tell the “off-chain world” that some particular state transition has happened.</p><h3 id="Declaring-an-Event"><a href="#Declaring-an-Event" class="headerlink" title="Declaring an Event"></a>Declaring an Event</h3><p><code>decl_event!</code> macro, example of an event declaration:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">decl_event!(</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Event</span>&lt;T&gt;</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        &lt;T <span class="keyword">as</span> system::Trait&gt;::AccountId,</span><br><span class="line">        &lt;T <span class="keyword">as</span> system::Trait&gt;::Balance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_ invoke__">MyEvent</span>(<span class="type">u32</span>, Balance),</span><br><span class="line">        <span class="title function_ invoke__">MyOtherEvent</span>(Balance, AccountId),</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>In our kitty-example:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">decl_event! &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Event</span>&lt;T&gt;</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        &lt;T <span class="keyword">as</span> system::Trait&gt;::AccountId,</span><br><span class="line">        &lt;T <span class="keyword">as</span> system::Trait&gt;::Hash,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_ invoke__">Created</span>(AccountId, Hash),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If we want to use some custom Substrate types, we need to integerate generics into our event definition.</p><h3 id="Adding-an-Event"><a href="#Adding-an-Event" class="headerlink" title="Adding an Event"></a>Adding an Event</h3><p>The decl_event! macro will generate a new Event type which you will need to expose in your module. This type will need to inherit some traits like so:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Trait</span>: balances::Trait &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Event</span>: <span class="built_in">From</span>&lt;Event&lt;<span class="keyword">Self</span>&gt;&gt; + <span class="built_in">Into</span>&lt;&lt;<span class="keyword">Self</span> <span class="keyword">as</span> system::Trait&gt;::Event&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Depositing-an-Event"><a href="#Depositing-an-Event" class="headerlink" title="Depositing an Event"></a>Depositing an Event</h3><p>In order to use events within your runtime, you need to add a function which deposits those events. The <code>decl_module!</code> macro can automatically add a default implementation of this to your module.</p><p>Add this to the <code>decl_module</code>:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">deposit_event</span>&lt;T&gt;() = default;</span><br></pre></td></tr></table></figure><p>If you do not use any generics:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">deposit_event</span>() = default;</span><br></pre></td></tr></table></figure><h3 id="Calling-deposit-event"><a href="#Calling-deposit-event" class="headerlink" title="Calling deposit_event()"></a>Calling <code>deposit_event()</code></h3><p>Just provide the values that go along with our Event <code>definition</code> at the end of our function.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">my_value</span> = <span class="number">1337</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">my_balance</span> = &lt;T::Balance <span class="keyword">as</span> As&lt;<span class="type">u64</span>&gt;&gt;::<span class="title function_ invoke__">sa</span>(<span class="number">1337</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">Self</span>::<span class="title function_ invoke__">deposit_event</span>(RawEvent::<span class="title function_ invoke__">MyEvent</span>(my_value, my_balance));</span><br></pre></td></tr></table></figure><p>So to our projects:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Self</span>::<span class="title function_ invoke__">deposit_event</span>(RawEvent::<span class="title function_ invoke__">Created</span>(sender, random_hash));</span><br></pre></td></tr></table></figure><h3 id="Updating-lib-rs-to-Include-Events"><a href="#Updating-lib-rs-to-Include-Events" class="headerlink" title="Updating lib.rs to Include Events"></a>Updating <code>lib.rs</code> to Include Events</h3><p>In the module <code>Trait</code> implementation:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `lib.rs`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">mymodule</span>::Trait <span class="keyword">for</span> <span class="title class_">Runtime</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Event</span> = Event;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Include the <code>Event</code> or <code>Event&lt;T&gt;</code> type to the module’s definition in the <code>construct_runtime!</code> macro.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">construct_runtime!(</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Runtime</span> with <span class="title function_ invoke__">Log</span>(InternalLog: DigestItem&lt;Hash, Ed25519AuthorityId&gt;) <span class="keyword">where</span></span><br><span class="line">        Block = Block,</span><br><span class="line">        NodeBlock = opaque::Block,</span><br><span class="line">        InherentData = BasicInherentData</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        MyModule: mymodule::&#123;Module, Call, Storage, Event&lt;T&gt;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="Why-we-need-events"><a href="#Why-we-need-events" class="headerlink" title="Why we need events?"></a>Why we need events?</h4><p>Followings are some of my understandings:</p><p>Substrate runtime module does not support <code>println!</code> macros for us to check the output from Substrate. However, we can deposit events from our substrate code and see it in polkadot.js apps. In <strong>extrinsics</strong> menu, we make a extrinsic which we built from our runtime and see events in the <strong>explorer</strong> menu.</p><h2 id="Tracking-All-Kitties"><a href="#Tracking-All-Kitties" class="headerlink" title="Tracking All Kitties"></a>Tracking All Kitties</h2><h3 id="Verify-First-Write-Last"><a href="#Verify-First-Write-Last" class="headerlink" title="Verify First, Write Last"></a>Verify First, Write Last</h3><p>There’s big difference between Substrate and Etherenum. On Ethereum, if at any point your transaction fails (error, out of gas, etc…), the state of your smart contract will be unaffected. Howerver, on Substrate this is not the case. <em>As soon as a transaction starts to modify the storage of the blockchain, those changes are <strong>parmanent</strong>, even if the transaction would fail at a later time during runtime execution.</em></p><p>As a Substrate runtime developer, we must follow “Verify first, write last” pattern.</p><h3 id="Creating-a-List"><a href="#Creating-a-List" class="headerlink" title="Creating a List"></a>Creating a List</h3><p>Substrate does support lists in the form of an <a href="https://substrate.dev/rustdocs/v1.0/srml_support/storage/trait.EnumerableStorageMap.html">EnumerableStorageMap</a>.</p><p>In runtime development, list iteration is, generally speaking, dangerous. Unless explicitly guarded against, <strong>runtime functions which enumerate a list will add O(N) complexity, but only charge O(1) fees</strong>. As a result, the chain can be vulnerable to attacks. Furthermore, if the lists you iterate over are large or even unbounded, <strong>your runtime may need more time to process the list than what is allocated between blocks. This means that a block producer may not even be able to create new blocks!</strong></p><p>For this reason, we will not use any list iteration in our runtime logic. Instead, we will emulate an enumerable map with a mapping and a counter like so:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">decl_storage! &#123;</span><br><span class="line">    <span class="keyword">trait</span> <span class="title class_">Store</span> <span class="keyword">for</span> <span class="title class_">Module</span>&lt;T: Trait&gt; <span class="keyword">as</span> KittyStorage &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        AllKittiesArray <span class="title function_ invoke__">get</span>(kitty_by_index): map <span class="type">u64</span> =&gt; T::Hash;</span><br><span class="line">        AllKittiesCount <span class="title function_ invoke__">get</span>(all_kitties_count): <span class="type">u64</span>;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Here we are storing a list of kitty in our runtime represented by <code>T::Hash</code>.</p><p>(有了这两个item以后，我们可以通过all_kitties_count来获得当前的kitty数，然后根据index(<code>最后一个索引index = count - 1</code>)去索引对应的kitty，就可以追踪到所有的kitty了，即遍历<code>0 ~ count -1</code>的<code>index</code>就可以遍历所有的kitty了)。</p><h3 id="Checking-for-Overflow-x2F-Underflow"><a href="#Checking-for-Overflow-x2F-Underflow" class="headerlink" title="Checking for Overflow&#x2F;Underflow"></a>Checking for Overflow&#x2F;Underflow</h3><p>Overflow and underflows are an easy way to cause our runtime to panic or for our storage to get messed up. We must always be proactive about checking for possible runtime errors before we make changes to our state. Ulike Ethereum, when a transaction fails, the state is <strong>NOT</strong> reverted back to before the transaction, so it is your responsibility to <strong>ensure that there are no side effect on error</strong>.</p><p>Fortuanately, checking for these kinds of errors are quite simple in Rust where primitive number types have <code>checked_add()</code> and <code>checked_sub()</code> functions.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">all_kitties_count</span> = <span class="keyword">Self</span>::<span class="title function_ invoke__">all_kitties_count</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">new_all_kitties_count</span> = all_kitties_count.<span class="title function_ invoke__">checked_add</span>(<span class="number">1</span>).<span class="title function_ invoke__">ok_or</span>(<span class="string">&quot;Overflow adding a new kitty&quot;</span>)?;</span><br></pre></td></tr></table></figure><p>Using <code>ok_or</code> is the same as writing:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">new_all_kitties_count</span> = <span class="keyword">match</span> all_kitties_count.<span class="title function_ invoke__">check_add</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(x) =&gt; x,</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(<span class="string">&quot;Overflow adding a new kitty&quot;</span>),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Make sure to remember the <code>?</code> at the end.</p><h3 id="Updating-our-List-in-Storage"><a href="#Updating-our-List-in-Storage" class="headerlink" title="Updating our List in Storage"></a>Updating our List in Storage</h3><p>Now that we have checked that we can safely increament our list, we can finally push changes to our storage. Remember that when you update your list, the <em>“last index” of your list is one less than the count</em>. For example, in a list with 2 items, the first item is index 0, and the second item is index 1.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">create_kitty</span>(origin) <span class="punctuation">-&gt;</span> <span class="type">Result</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sender</span> = <span class="title function_ invoke__">ensure_signed</span>(origin)?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">all_kitties_count</span> = <span class="keyword">Self</span>::<span class="title function_ invoke__">all_kitties_count</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">new_all_kitties_count</span> = all_kitties_count.<span class="title function_ invoke__">checked_add</span>(<span class="number">1</span>).<span class="title function_ invoke__">ok_or</span>(<span class="string">&quot;Overflow addina new kitty&quot;</span>)?</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (`index` is `count - 1` = `new_all_kitties_count 1` = `all_kitties_count`)</span></span><br><span class="line">    &lt;AllKittiesArray&lt;T&gt;&gt;::<span class="title function_ invoke__">insert</span>(all_kitties_count, random_hash); </span><br><span class="line">    &lt;AllKittiesCount&lt;T&gt;&gt;::<span class="title function_ invoke__">put</span>(new_all_kitties_count);</span><br><span class="line">    &lt;AllKittiesIndex&lt;T&gt;&gt;::<span class="title function_ invoke__">insert</span>(random_hash, all_kitties_count)</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>First, we get the current <code>AllKittiesCount</code> value and store it in <code>all_kitties_count</code>. Then create a <code>new_all_kitties_count</code> by doing a <code>checked_add()</code> to increment <code>all_kitties_count</code>. We also map the index(<code>all_kitties_count</code> &#x3D; <code>new_kitties_count -1</code>, remember the <code>index</code> is <code>count -1</code> ) to the kitty(<code>random_hash</code>).</p><h3 id="Deleting-From-Our-List"><a href="#Deleting-From-Our-List" class="headerlink" title="Deleting From Our List"></a>Deleting From Our List</h3><p>One problem that this <code>map</code> and <code>count</code> pattern introduces is holes in our list when we try to remove elements from the middle. Fortunately, the order of the list we want to manage in our example is not important, so we can use a “swap and pop” method to efficiently mitigate this issue.</p><p>The “swap and pop” method switches the position of the item we want to remove and the last item in our list. Then, we can simply remove the last item without introducing any holes to our list.</p><p>Rather than run a loop to find the index of the item we want to remove each time we remove an item, we will use a little extra storage to keep track of each item and its position in our list.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AllKittiesIndex: map T::Hash =&gt; <span class="type">u64</span>;</span><br></pre></td></tr></table></figure><p>（简单来讲其实就是每次先交换要删除的kitty和整个list里最后一个kitty，交换完后把最后一个kitty删掉就好，这样一来就不会因为删除在list里留下空缺。同时，我们用<code>AllKittiesIndex</code>这个数据结构来映射kitty和index，这样就不需要每次删除kitty的时候还要遍历整个list去找它的index）</p><h2 id="Owning-Multiple-Kitties"><a href="#Owning-Multiple-Kitties" class="headerlink" title="Owning Multiple Kitties"></a>Owning Multiple Kitties</h2><p>Right now our storage can only track one kitty per user, howerver one user can own multiple kitties.</p><blockquote><p>Note: 其实这种说法并不准确，虽然对于每个user只能看到最新的一只kitty，但是实际上通过某只kitty还是可以追踪到它的owner的。 (Though every user can only check the last kitty he has, we can find the kitty’s owner by <code>KittyOwner</code>.)</p></blockquote><h3 id="Using-tuples-to-emulate-higher-order-arrays"><a href="#Using-tuples-to-emulate-higher-order-arrays" class="headerlink" title="Using tuples to emulate higher order arrays"></a>Using tuples to emulate higher order arrays</h3><p>We could use a tuple to represent ownership of multiple items across multiple users.</p><p>Here is how we could build a “kitty list” unique to each person using such a structure:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OwnedKittiesArray <span class="title function_ invoke__">get</span>(kitty_of_owner_by_index): <span class="title function_ invoke__">map</span> (T::AccountId, <span class="type">u64</span>) =&gt; T::Hash;</span><br><span class="line">OwnedKittiesCount <span class="title function_ invoke__">get</span>(owned_kitty_count): map T::AccountId =&gt; <span class="type">u64</span>;</span><br></pre></td></tr></table></figure><p>This should emulate a more standard two-dimensional array like:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OwnedKittiesArray[AccountId][index] -&gt; (one)kitty</span><br></pre></td></tr></table></figure><p>Also we can get the number of kitties for a user like:        </p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OwnedKittiesArray[AccountId].<span class="title function_ invoke__">length</span>() = <span class="title function_ invoke__">owned_kitty_count</span>() = OwnedKittiesCount[AccountId]</span><br></pre></td></tr></table></figure><h3 id="Relative-Index"><a href="#Relative-Index" class="headerlink" title="Relative Index"></a>Relative Index</h3><p>Just as before, we can optimize the computational work our runtime needs to do by indexing the location of items. The general approach to this would be to reserve the mapping of <code>OwnedKittiesArray</code>:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (T::AccountId, T::Hash) -&gt; `index` in `OwnedKittiesArray`</span></span><br><span class="line">OwnedKittiesIndex: <span class="title function_ invoke__">map</span> (T::AccountId, T::Hash) =&gt; <span class="type">u64</span>;</span><br></pre></td></tr></table></figure><p>Howerver, our kitties all have unique identifiers as a <code>Hash</code>, and cannot be owned by more than one user, we can actually simplify this structure:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OwnedKittiesIndex: map T::Hash =&gt; <span class="type">u64</span>;</span><br></pre></td></tr></table></figure><p>This index tells us for a given kitty, where to look in the <em>owners</em> array for that item.</p><h2 id="Refactoring-our-code"><a href="#Refactoring-our-code" class="headerlink" title="Refactoring our code"></a>Refactoring our code</h2><p>Within our runtime, we are able to include an implementation of our runtime module like so:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T: Trait&gt; Module&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// our function here    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Functions in this block are usually public interfaces or private functions. Public interfaces should be labeled <code>pub</code> and generally fall into inspector functions that do not write to storage and operation functions that do. Private functions are your usual private utilities unavailable to other modules.</p><p>You can call functions defined here using the <code>Self::function_name()</code> pattern you have seen before. Here is an intentionally overcomplicated example:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">decl_module! &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Module</span>&lt;T: Trait&gt; <span class="keyword">for</span> <span class="title class_">enum</span> Call <span class="keyword">where</span> origin: T::Origin &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">adder_to_storage</span>(origin, num1: <span class="type">u32</span>, num2: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">_sender</span> = <span class="title function_ invoke__">ensure_signed</span>(origin)?;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">result</span> = <span class="keyword">Self</span>::_adder(num1, num2);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">Self</span>::_store_value(result)?;</span><br><span class="line"></span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T: Trait&gt; Module&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">_adder</span>(num1: <span class="type">u32</span>, num2: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">final_answer</span> = num1.<span class="title function_ invoke__">checked_add</span>(num2).<span class="title function_ invoke__">ok_or</span>(<span class="string">&quot;Overflow when adding&quot;</span>)?;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">_store_value</span>(value: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span> &#123;</span><br><span class="line">        &lt;myStorage&lt;T&gt;&gt;::<span class="title function_ invoke__">put</span>(value);</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Remember that we still need to follow a “verify first, write last” pattern, so it is important to not daisy chain private functions which do writes to storage where there is a chance one will throw an error.</p><p>So, in our example, we moved most of the logic to the function <code>mint</code>:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T: Trait&gt; Module&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">mint</span>(to: T::AccountId, kitty_id: T::Hash, new_kitty: Kitty&lt;T::Hash, T::Balance&gt;) <span class="punctuation">-&gt;</span> <span class="type">Result</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">owned_kitty_count</span> = <span class="keyword">Self</span>::<span class="title function_ invoke__">owned_kitty_count</span>(&amp;to);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">new_owned_kitty_count</span> = owned_kitty_count.<span class="title function_ invoke__">checked_add</span>(<span class="number">1</span>).<span class="title function_ invoke__">ok_or</span>(<span class="string">&quot;Overflow adding a new kitty to account Balance&quot;</span>)?;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">let</span> <span class="variable">all_kitties_count</span> = <span class="keyword">Self</span>::<span class="title function_ invoke__">all_kitties_count</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">new_all_kitties_count</span> = all_kitties_count.<span class="title function_ invoke__">checked_add</span>(<span class="number">1</span>).<span class="title function_ invoke__">ok_or</span>(<span class="string">&quot;Overflow adding a new kitty&quot;</span>)?;</span><br><span class="line"></span><br><span class="line">        &lt;Kitties&lt;T&gt;&gt;::<span class="title function_ invoke__">insert</span>(kitty_id, new_kitty);</span><br><span class="line">        &lt;KittyOwner&lt;T&gt;&gt;::<span class="title function_ invoke__">insert</span>(kitty_id, &amp;to);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// (`index` is `count - 1` = `new_all_kitties_count - 1` = `all_kitties_count`,)</span></span><br><span class="line">        &lt;AllKittiesArray&lt;T&gt;&gt;::<span class="title function_ invoke__">insert</span>(all_kitties_count, kitty_id); </span><br><span class="line">        &lt;AllKittiesCount&lt;T&gt;&gt;::<span class="title function_ invoke__">put</span>(new_all_kitties_count);</span><br><span class="line">        &lt;AllKittiesIndex&lt;T&gt;&gt;::<span class="title function_ invoke__">insert</span>(kitty_id, all_kitties_count);</span><br><span class="line">        &lt;OwnedKittiesArray&lt;T&gt;&gt;::<span class="title function_ invoke__">insert</span>((to.<span class="title function_ invoke__">clone</span>(), owned_kitty_count), kitty_id);</span><br><span class="line">        &lt;OwnedKittiesCount&lt;T&gt;&gt;::<span class="title function_ invoke__">insert</span>(&amp;to, new_owned_kitty_count);</span><br><span class="line">        &lt;OwnedKittiesIndex&lt;T&gt;&gt;::<span class="title function_ invoke__">insert</span>(kitty_id, owned_kitty_count);</span><br><span class="line">        &lt;OwnedKitty&lt;T&gt;&gt;::<span class="title function_ invoke__">insert</span>(&amp;to, kitty_id);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">Self</span>::<span class="title function_ invoke__">deposit_event</span>(RawEvent::<span class="title function_ invoke__">Created</span>(to, kitty_id));</span><br><span class="line">        </span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Set-the-price-of-a-Kitty"><a href="#Set-the-price-of-a-Kitty" class="headerlink" title="Set the price of a Kitty"></a>Set the price of a Kitty</h2><p>Now, every kitty has a <code>price</code> attribute that we have set it to <code>0</code> as defalut. If we want to set the price of a kitty, we will need to pull down the <code>Kitty</code> object, update the price, and push it back into the storage.</p><h3 id="Sanity-Checks"><a href="#Sanity-Checks" class="headerlink" title="Sanity Checks"></a>Sanity Checks</h3><p>Before doing this, we need to do sanity checks. Since we are going to start letting users call public functions that our runtime exposes, and that means opportunity for our users to give poor input or even maliciously. So if we are creating a function which updates the value of an object, the first thing we better do is make sure the object exists at all.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ensure!(&lt;Kitties&lt;T&gt;&gt;::<span class="title function_ invoke__">exists</span>(kitty_id), <span class="string">&quot;This kitty does not exists.&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="Permissioned-Functions"><a href="#Permissioned-Functions" class="headerlink" title="Permissioned Functions"></a>Permissioned Functions</h3><p>Although everyone could call our <code>create_kitty()</code> function with a message, only the owner of the kitty is allowed to set the price. For modifying a <code>Kitty</code>, we need to get the owner of the kitty, and ensure that it is the same as the <code>sender</code>.</p><p>KittyOwner stores a mapping to an <code>Option&lt;T::AccountId&gt;</code> since a given <code>Hash</code> may not point to a generated and owned Kitty yet. This means, whenever we fetch the owner of a kitty, we need to resolve the possibility that it returns None. This could be caused by bad user input or even some sort of problem with our runtime, but checking will help prevent these kinds of problems.</p><blockquote><p>其实这里说的不是很准确，每个kitty应该都有owner，如果是输入错误那么实际上在第一次检查的时候，就已经发现这个kitty不存在了。(In fact, every kitty should have its owner, if it does not have a owner, it should not exist.)</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kitty&#x27;s owner</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">owner</span> = <span class="keyword">Self</span>::<span class="title function_ invoke__">owner_of</span>(kitty_id).<span class="title function_ invoke__">ok_or</span>(<span class="string">&quot;No owner for this kitty&quot;</span>)?;</span><br><span class="line">ensure!(owner == sender, <span class="string">&quot;You are not the owner of the kitty&quot;</span>);</span><br></pre></td></tr></table></figure><p>So the <code>set_price</code> function looks like:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">set_price</span>(origin, kitty_id: T::Hash, new_price: T::Balance) <span class="punctuation">-&gt;</span> <span class="type">Result</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sender</span> = <span class="title function_ invoke__">ensure_signed</span>(origin)?;</span><br><span class="line">    ensure!(&lt;Kitties&lt;T&gt;&gt;::<span class="title function_ invoke__">exists</span>(kitty_id), <span class="string">&quot;This kitty does not exists.&quot;</span>)</span><br><span class="line"></span><br><span class="line">         <span class="comment">// kitty&#x27;s owner</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">owner</span> = <span class="keyword">Self</span>::<span class="title function_ invoke__">owner_of</span>(kitty_id).<span class="title function_ invoke__">ok_or</span>(<span class="string">&quot;No owner for this kitty&quot;</span>)?;</span><br><span class="line">    ensure!(owner == sender, <span class="string">&quot;You are not the owner of the kitty&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">kitty</span> = <span class="keyword">Self</span>::<span class="title function_ invoke__">kitty</span>(kitty_id);</span><br><span class="line">    kitty.price = new_price</span><br><span class="line"></span><br><span class="line">    &lt;Kitties&lt;T&gt;&gt;::<span class="title function_ invoke__">insert</span>(kitty_id, kitty)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">Self</span>::<span class="title function_ invoke__">deposit_event</span>(RawEvent::<span class="title function_ invoke__">PriceSet</span>(sender, kitty_id, new_price));</span><br><span class="line">         </span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Transferring-a-Kitty"><a href="#Transferring-a-Kitty" class="headerlink" title="Transferring a Kitty"></a>Transferring a Kitty</h2><p>Ownership is entirely managed by our storage, so a <code>transfer_kitty</code> function is really only modifying our existing storage to reflect the state. Here are the storage items we need to update:</p><ul><li>Change the global kitty owner</li><li>Change the owned kitty count of each user</li><li>Change the owned kitty index of the kitty</li><li>Change the owned kitty map for each user</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">transfer</span>(origin, to: T::AccountId, kitty_id: T::Hash) <span class="punctuation">-&gt;</span> <span class="type">Result</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sender</span> = <span class="title function_ invoke__">ensure_signed</span>(origin)?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">owner</span> = <span class="keyword">Self</span>::<span class="title function_ invoke__">owner_of</span>(kitty_id).<span class="title function_ invoke__">ok_or</span>(<span class="string">&quot;No owner for this kitty&quot;</span>)?;</span><br><span class="line">    ensure!(owner == sender, <span class="string">&quot;You are not the owner of this kitty&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">Self</span>::<span class="title function_ invoke__">transfer_from</span>(sender, to, kitty_id)?;</span><br><span class="line">            </span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">buy_kitty</span>(origin, kitty_id: T::Hash, max_price: T::Balance) <span class="punctuation">-&gt;</span> <span class="type">Result</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sender</span> = <span class="title function_ invoke__">ensure_signed</span>(origin)?;</span><br><span class="line"></span><br><span class="line">    ensure!(&lt;Kitties&lt;T&gt;&gt;::<span class="title function_ invoke__">exists</span>(kitty_id), <span class="string">&quot;This kitty does not exists.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">owner</span> = <span class="keyword">Self</span>::<span class="title function_ invoke__">owner_of</span>(kitty_id).<span class="title function_ invoke__">ok_or</span>(<span class="string">&quot;No owner for this kitty&quot;</span>)?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">kitty</span> = <span class="keyword">Self</span>::<span class="title function_ invoke__">kitty</span>(kitty_id);</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">kitty_price</span> = kitty.price;</span><br><span class="line">    ensure!(!kitty_price.<span class="title function_ invoke__">is_zero</span>(), <span class="string">&quot;Price is zero.&quot;</span>);</span><br><span class="line">    ensure!(kitty_price &lt;= max_price, <span class="string">&quot;The cat you want to by cost more than your max price&quot;</span>);</span><br><span class="line">            </span><br><span class="line">    &lt;balances::Module&lt;T&gt; <span class="keyword">as</span> Currency&lt;_&gt;&gt;::<span class="title function_ invoke__">transfer</span>(&amp;sender, &amp;owner, kitty_price)?;</span><br><span class="line">    <span class="keyword">Self</span>::<span class="title function_ invoke__">transfer_from</span>(owner.<span class="title function_ invoke__">clone</span>(), sender.<span class="title function_ invoke__">clone</span>(), kitty_id)</span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;`owner` is shown to own the kitty; \</span></span><br><span class="line"><span class="string">                `owner` must have greater than 0 kitties, so transfer cannot cause underflow; \</span></span><br><span class="line"><span class="string">                `all_kitty_count` shares the same type as `owned_kitty_count` \</span></span><br><span class="line"><span class="string">                and minting ensure there won&#x27;t ever be more than `max()` kitties, \</span></span><br><span class="line"><span class="string">                which means transfer cannot cause an overflow; \</span></span><br><span class="line"><span class="string">                qed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    kitty.price = &lt;T::Balance <span class="keyword">as</span> As&lt;<span class="type">u64</span>&gt;&gt;::<span class="title function_ invoke__">sa</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">Self</span>::<span class="title function_ invoke__">deposit_event</span>(RawEvent::<span class="title function_ invoke__">Bought</span>(sender, owner, kitty_id, kitty_price));</span><br><span class="line">            </span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Buying-a-Kitty"><a href="#Buying-a-Kitty" class="headerlink" title="Buying a Kitty"></a>Buying a Kitty</h2><p>First, make sure that the kitty is indeed for sale. To simplified our problem, just define that any kitty with default price of 0 is not for sale.</p><p>Then, we need to make a payment. So far our chain has been completely independent of our internal currency provided by the <code>Balances</code> module. The <code>Balances</code> module gives us access to completely manage the internal currency of every user, which means we need to be careful how we use it.</p><p>Fortunately, the <code>Balances</code> module expose a trait called <code>Currency</code> which implements a function called <code>transfer()</code> which allows you to safely transfer units from one account to another, checking for enough balance, overflow, underflow, and even account creation as a result of getting tokens.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;balances::Module&lt;T&gt; <span class="keyword">as</span> Currency&lt;_&gt;&gt;::<span class="title function_ invoke__">transfer</span>(&amp;sender, &amp;owner, kitty_price)?;</span><br></pre></td></tr></table></figure><h2 id="Breeding-a-Kitty"><a href="#Breeding-a-Kitty" class="headerlink" title="Breeding a Kitty"></a>Breeding a Kitty</h2><p>Probably the most unique part of the origina; CryptoKitties game is the ability to breed new kitties from existing ones.</p><p>We have prepared our <code>Kitty</code> object with this in mind, introducing <code>dna</code> and <code>gen</code> which will be used in forming brand new kitty offspring.</p><p>In our runtime, DNA is a 256 bit hash, which is represented by as a bytearray in our code, and a hexadecimal string in our upcoming UI.</p><p>This means that there are 32 elements, each of which can be a value from 0 - 255. We will use these elements to determine which traits our kitties have. For example, the first index of the byte array can determine the color of our kitty(from a range of 256 colors); the nex element could represent the eye shape, etc…</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">breed_kitty</span>(origin, kitty_id_1: T::Hash, kitty_id_2: T::Hash) <span class="punctuation">-&gt;</span> <span class="type">Result</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sender</span> = <span class="title function_ invoke__">ensure_signed</span>(origin)?</span><br><span class="line">    ensure!(&lt;Kitties&lt;T&gt;&gt;::<span class="title function_ invoke__">exists</span>(kitty_id_1), <span class="string">&quot;Kitty1 doenot exist&quot;</span>);</span><br><span class="line">    ensure!(&lt;Kitties&lt;T&gt;&gt;::<span class="title function_ invoke__">exists</span>(kitty_id_2), <span class="string">&quot;Kitty2 doenot exist&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">nonce</span> = &lt;Nonce&lt;T&gt;&gt;::<span class="title function_ invoke__">get</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">random_hash</span> = (&lt;system::Module&lt;T&gt;&gt;::<span class="title function_ invoke__">random_seed</span>(),sender, nonce).<span class="title function_ invoke__">using_encoded</span>(&lt;T asystem::Trait&gt;::Hashing::hash);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">kitty_1</span> = <span class="keyword">Self</span>::<span class="title function_ invoke__">kitty</span>(kitty_id_1);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">kitty_2</span> = <span class="keyword">Self</span>::<span class="title function_ invoke__">kitty</span>(kitty_id_2)</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">final_dna</span> = kitty_1.dna;</span><br><span class="line">    <span class="comment">// &#x27;Zips up&#x27; two iterators into a single iterator opairs. tuple</span></span><br><span class="line">    <span class="title function_ invoke__">for</span> (i, (dna_2_element, r)) <span class="keyword">in</span> kitty_2.dna.<span class="title function_ invoke__">as_ref</span>().<span class="title function_ invoke__">it</span>().<span class="title function_ invoke__">zip</span>(random_hash.<span class="title function_ invoke__">as_ref</span>().<span class="title function_ invoke__">iter</span>()).<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> r % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">            final_dna.<span class="title function_ invoke__">as_mut</span>()[i] = *dna_2_element;</span><br><span class="line">        &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">new_kitty</span> = Kitty &#123;</span><br><span class="line">        id: random_hash,</span><br><span class="line">        dna: final_dna,</span><br><span class="line">        price: &lt;T::Balance <span class="keyword">as</span> As&lt;<span class="type">u64</span>&gt;&gt;::<span class="title function_ invoke__">sa</span>(<span class="number">0</span>),</span><br><span class="line">        gen: cmp::<span class="title function_ invoke__">max</span>(kitty_1.gen, kitty_2.gen) + <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">Self</span>::<span class="title function_ invoke__">mint</span>(sender, random_hash, new_kitty)?</span><br><span class="line">    &lt;Nonce&lt;T&gt;&gt;::<span class="title function_ invoke__">mutate</span>(|n| *n += <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Runtime&quot;&gt;&lt;a href=&quot;#Runtime&quot; class=&quot;headerlink&quot; title=&quot;Runtime&quot;&gt;&lt;/a&gt;Runtime&lt;/h2&gt;&lt;p&gt;The Runtime is block execution logic of a blockcha</summary>
      
    
    
    
    <category term="Rust" scheme="http://readlnh.github.io/categories/Rust/"/>
    
    <category term="substrate" scheme="http://readlnh.github.io/categories/Rust/substrate/"/>
    
    
    <category term="Rust" scheme="http://readlnh.github.io/tags/Rust/"/>
    
    <category term="Substrate" scheme="http://readlnh.github.io/tags/Substrate/"/>
    
    <category term="blcokchain" scheme="http://readlnh.github.io/tags/blcokchain/"/>
    
  </entry>
  
  <entry>
    <title>Primitives</title>
    <link href="http://readlnh.github.io/2019/11/05/Rust/Rust-by-example-notes/Primitives/"/>
    <id>http://readlnh.github.io/2019/11/05/Rust/Rust-by-example-notes/Primitives/</id>
    <published>2019-11-05T14:11:00.000Z</published>
    <updated>2022-10-27T19:58:23.769Z</updated>
    
    <content type="html"><![CDATA[<p>Rust by examples notes about primitives.</p><h2 id="Primitives"><a href="#Primitives" class="headerlink" title="Primitives"></a>Primitives</h2><p>Rust provides access to a wide variety of <code>primitives</code>.</p><h3 id="scalar-Types"><a href="#scalar-Types" class="headerlink" title="scalar Types"></a>scalar Types</h3><ul><li>signed integers: <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code> and <code>isize</code>(pointer size)</li><li>unsigned integers: <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code> and <code>usize</code>(pointer size)</li><li>floating point: f32, f64</li><li><code>char</code> Unicode scalar values like <code>&#39;a&#39;</code>, <code>&#39;α&#39;</code> and <code>&#39;∞&#39;</code>(4 bytes each)</li><li><code>bool</code> either <code>true</code> and <code>false</code></li><li>and the unit type <code>()</code>, whose only possible value is an empty tuple: <code>()</code></li></ul><p><strong>note:</strong> Despite the value of a unit type being a tuple, it is not considered a compound type because it does not contain multiple values.</p><h3 id="Compound-Types"><a href="#Compound-Types" class="headerlink" title="Compound Types"></a>Compound Types</h3><ul><li>arrys like [1, 2, 3]</li><li>tuples like (1, true)</li></ul><h3 id="Tuples"><a href="#Tuples" class="headerlink" title="Tuples"></a>Tuples</h3><p>A tuple is a collection of values of different types. Tuples are constructed using parenthese <code>()</code>, and each tuple itself is a value with type signature <code>(T1, T2, ...)</code>, where <code>T1</code>, <code>T2</code> are the types of its members.Functions can use tuples to return multiple values, as tuples can hold any number of values.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix</span>(<span class="type">f32</span>, <span class="type">f32</span>, <span class="type">f32</span>, <span class="type">f32</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">long_tuple</span> = (<span class="number">1u8</span>, <span class="number">2u16</span>, <span class="number">3u32</span>, <span class="number">4u64</span>,</span><br><span class="line">                      -<span class="number">1i8</span>, -<span class="number">2i16</span>, -<span class="number">3i32</span>, -<span class="number">4i64</span>,</span><br><span class="line">                      <span class="number">0.1f32</span>, <span class="number">0.2f64</span>,</span><br><span class="line">                      <span class="string">&#x27;a&#x27;</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p><em>Values can be extracted from the tuple using tuple indexing,such as<code>long_tuple.0</code>,<code>long_tuple.1</code></em></p><p><em>Tuples can be tuple members</em></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">tuple_of_tuples</span> = ((<span class="number">1u8</span>, <span class="number">2u16</span>, <span class="number">2u32</span>), (<span class="number">4u64</span>, -<span class="number">1i8</span>), -<span class="number">2i16</span>);</span><br></pre></td></tr></table></figure><p><em><code>let</code> can be used to bind the members of a tuple to variables.</em></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">tuple</span> = (<span class="number">1</span>, <span class="literal">true</span>, <span class="number">1.2</span>);</span><br><span class="line"><span class="keyword">let</span> (a , b, c) = tuple;</span><br></pre></td></tr></table></figure><p><em>Display for tuples</em></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::&#123;Display, Formatter, <span class="type">Result</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix</span>(<span class="type">f32</span>, <span class="type">f32</span>, <span class="type">f32</span>, <span class="type">f32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">transpose</span>(x: &amp;Matrix) <span class="punctuation">-&gt;</span> Matrix &#123;</span><br><span class="line">    <span class="title function_ invoke__">Matrix</span>(x.<span class="number">0</span>, x.<span class="number">2</span>, x.<span class="number">1</span>, x.<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Display</span> <span class="keyword">for</span> <span class="title class_">Matrix</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> Formatter&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Result</span> &#123;</span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">&quot;( &#123;&#125; &#123;&#125; )\n&quot;</span>, &amp;<span class="keyword">self</span>.<span class="number">0</span>, &amp;<span class="keyword">self</span>.<span class="number">1</span>)?;</span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">&quot;( &#123;&#125; &#123;&#125; )&quot;</span>, &amp;<span class="keyword">self</span>.<span class="number">2</span>, &amp;<span class="keyword">self</span>.<span class="number">3</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">matrix</span> = <span class="title function_ invoke__">Matrix</span>(<span class="number">1.1</span>, <span class="number">1.2</span>, <span class="number">2.1</span>, <span class="number">2.2</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Matrix:\n&#123;&#125;&quot;</span>, matrix);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Transpose:\n&#123;&#125;&quot;</span>, <span class="title function_ invoke__">transpose</span>(&amp;matrix));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Matrix:\n&#123;&#125;&quot;</span>, matrix);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>output</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Matrix:</span><br><span class="line">( 1.1 1.2 )</span><br><span class="line">( 2.1 2.2 )</span><br><span class="line">Transpose:</span><br><span class="line">( 1.1 2.1 )</span><br><span class="line">( 1.2 2.2 )</span><br><span class="line">Matrix:</span><br><span class="line">( 1.1 1.2 )</span><br><span class="line">( 2.1 2.2 )</span><br></pre></td></tr></table></figure><h3 id="Arrays-and-Slices"><a href="#Arrays-and-Slices" class="headerlink" title="Arrays and Slices"></a>Arrays and Slices</h3><p>An array is a collection of objects of the same type <code>T</code>, stored in contiguous memory. Arrays are created using brackets <code>[]</code>, and <strong>their size, which is know at compile time</strong>, is part of  their signature <code>[T; size]</code>.</p><p>Slices are similar to arrays, but <strong>their size is not know at compile time</strong>. Instead, a slice is a <strong>two-word</strong> object, the first word is a pointer to the data, the second word is the length of the slice. The word size is the same as usize, determined by archiecture eg 64 bits on x86-64.Slices can be used to borrow a section of an array, and have type signature <code>&amp;[T]</code>.</p><p><em>elements can be initalized to the same value</em></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span>: [<span class="type">i32</span>; <span class="number">500</span>] = [<span class="number">0</span>; <span class="number">500</span>]</span><br></pre></td></tr></table></figure><h2 id="Custom-Types"><a href="#Custom-Types" class="headerlink" title="Custom Types"></a>Custom Types</h2><p>Rust custom data types are formed mainly through the two keywords:</p><ul><li><code>struct</code>: define a structure</li><li><code>enum</code>: define an enumeration</li></ul><h3 id="Structures"><a href="#Structures" class="headerlink" title="Structures"></a>Structures</h3><p>There are three types of structures (“struct”) that can be created using the <code>struct</code> keyword:</p><ul><li>Tuple structs, which are, basically, named tuples.</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Pair</span>(<span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">pair</span> = <span class="title function_ invoke__">Pair</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// Destructure a tuple struct </span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">Pair</span>(integer, decimal) = pair;</span><br></pre></td></tr></table></figure><ul><li>The classic <code>C structs</code>.<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">f32</span>,</span><br><span class="line">    y: <span class="type">f32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">point</span> = Point &#123; <span class="number">1</span>, <span class="number">1.1</span>&#125;;</span><br><span class="line"><span class="comment">// Destructure the point using a `let` binding</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">Point</span> &#123; x: my_x, y: my_y &#125; = point;</span><br></pre></td></tr></table></figure></li><li>Unit structs, which are field-less, are useful for generics.</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Nil</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">_nil</span> = Nil;</span><br></pre></td></tr></table></figure><p><strong>Note</strong>: Structs can be reused as fields of another struct.</p><p><em>rectangle struct example</em></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">f64</span>,</span><br><span class="line">    y: <span class="type">f64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[allow(dead_code)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    p1: Point,</span><br><span class="line">    p2: Point,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">rect_area</span>(rectangle: &amp;Rectangle) <span class="punctuation">-&gt;</span> <span class="type">f64</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">Rectangle</span> &#123;</span><br><span class="line">        p1: Point &#123;x: x1, y: y1&#125;, </span><br><span class="line">        p2: Point &#123;x: x2, y: y2&#125;</span><br><span class="line">    &#125; = rectangle;</span><br><span class="line">    <span class="comment">//println!(&quot;&#123;&#125; &#123;&#125; &#123;&#125;&quot;, y2, y1, y2 - y1);</span></span><br><span class="line">    ((x2 - x1) * (y2 - y1))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">square</span>(p: &amp;Point, x: <span class="type">f64</span>) <span class="punctuation">-&gt;</span> Rectangle &#123;</span><br><span class="line">    Rectangle &#123;</span><br><span class="line">        p1: Point &#123; x: p.x, y: p.y, &#125;,</span><br><span class="line">        p2: Point &#123; x: p.x + x, y: p.y + x, &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">point</span>: Point = Point &#123; x: <span class="number">0.3</span>, y: <span class="number">0.4</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">0.5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rectangle</span> = <span class="title function_ invoke__">square</span>(&amp;point, x);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,<span class="title function_ invoke__">rect_area</span>(&amp;rectangle));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>output</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.5</span><br></pre></td></tr></table></figure><h2 id="Enums"><a href="#Enums" class="headerlink" title="Enums"></a>Enums</h2><p>The <code>enum</code> keyword allows the creation of a type which may be one of a few different variants. Any variant which is valid as a <code>struct</code> is also valid as <code>enum</code>.</p><p><em>example</em></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create an `enum` to classify a web event. Note how both</span></span><br><span class="line"><span class="comment">// names and type information together specify the variant:</span></span><br><span class="line"><span class="comment">// `PageLoad != PageUnload` and `KeyPress(char) != Paste(String)`.</span></span><br><span class="line"><span class="comment">// Each is different and independent.</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">WebEvent</span> &#123;</span><br><span class="line">    <span class="comment">// An `enum` may either be `unit-like`,</span></span><br><span class="line">    PageLoad,</span><br><span class="line">    PageUnload,</span><br><span class="line">    <span class="comment">// like tuple structs,</span></span><br><span class="line">    <span class="title function_ invoke__">KeyPress</span>(<span class="type">char</span>),</span><br><span class="line">    <span class="title function_ invoke__">Paste</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="comment">// or c-like structures.</span></span><br><span class="line">    Click &#123; x: <span class="type">i64</span>, y: <span class="type">i64</span> &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="use"><a href="#use" class="headerlink" title="use"></a>use</h3><p>The <code>use</code> declaration can be used so manual scoping isn’t needed:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Status</span> &#123;</span><br><span class="line">    A,</span><br><span class="line">    B,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>no use</em></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">status</span> = Status::A;</span><br></pre></td></tr></table></figure><p><em>use</em></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::Status::&#123;A, B&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">status</span> = A;</span><br></pre></td></tr></table></figure><h3 id="C-like"><a href="#C-like" class="headerlink" title="C-like"></a>C-like</h3><p><code>enum</code> can also be used as C-like enums.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// An attribute to hide warnings for unused code.</span></span><br><span class="line"><span class="meta">#![allow(dead_code)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// enum with implicit discriminator (starts at 0)</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Number</span> &#123;</span><br><span class="line">    Zero,</span><br><span class="line">    One,</span><br><span class="line">    Two,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// enum with explicit discriminator</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    Red = <span class="number">0xff0000</span>,</span><br><span class="line">    Green = <span class="number">0x00ff00</span>,</span><br><span class="line">    Blue = <span class="number">0x0000ff</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// `enums` can be cast as integers.</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;zero is &#123;&#125;&quot;</span>, Number::Zero <span class="keyword">as</span> <span class="type">i32</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;one is &#123;&#125;&quot;</span>, Number::One <span class="keyword">as</span> <span class="type">i32</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;roses are #&#123;:06x&#125;&quot;</span>, Color::Red <span class="keyword">as</span> <span class="type">i32</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;violets are #&#123;:06x&#125;&quot;</span>, Color::Blue <span class="keyword">as</span> <span class="type">i32</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Linked-list"><a href="#Linked-list" class="headerlink" title="Linked-list"></a>Linked-list</h3><p>Cons: Tuple struct that wraps an element and a pointer to the next node</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::List::*;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">u32</span>, <span class="type">Box</span>&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> List &#123;</span><br><span class="line">        Nil</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">prepend</span>(<span class="keyword">self</span>, elem: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> List &#123;</span><br><span class="line">        <span class="title function_ invoke__">Cons</span>(elem, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="keyword">self</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">len</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> *<span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">Cons</span>(_, <span class="keyword">ref</span> tail) =&gt; <span class="number">1</span> + tail.<span class="title function_ invoke__">len</span>(),</span><br><span class="line">            Nil =&gt; <span class="number">0</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">stringify</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> *<span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">Cons</span>(head, <span class="keyword">ref</span> tail) =&gt; &#123;</span><br><span class="line">                <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, head, tail.<span class="title function_ invoke__">stringify</span>())</span><br><span class="line">            &#125;,</span><br><span class="line">            Nil =&gt; &#123;</span><br><span class="line">                <span class="built_in">format!</span>(<span class="string">&quot;Nil&quot;</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">list</span> = List::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    list = list.<span class="title function_ invoke__">prepend</span>(<span class="number">1</span>);</span><br><span class="line">    list = list.<span class="title function_ invoke__">prepend</span>(<span class="number">2</span>);</span><br><span class="line">    list = list.<span class="title function_ invoke__">prepend</span>(<span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, list.<span class="title function_ invoke__">len</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, list.<span class="title function_ invoke__">stringify</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="constants"><a href="#constants" class="headerlink" title="constants"></a>constants</h3><p>Rust has two different types of constants which can be declared in any scope including global. Both require explicit type annotation:</p><ul><li><code>const</code>: An unchanged value (the common case).</li><li><code>static</code>: A possibly mutable variable with <code>&#39;static</code> lifetime. The staic lifetime is inferred and does not have to be specified. Accessing or modifying a mutable static variable is <code>unsafe</code>.</li></ul><h2 id="Type-conversation"><a href="#Type-conversation" class="headerlink" title="Type conversation"></a>Type conversation</h2><p>The generic conversations will use the <code>From</code> and <code>Into</code> traits.</p><h3 id="From-and-Into"><a href="#From-and-Into" class="headerlink" title="From and Into"></a><code>From</code> and <code>Into</code></h3><p><code>From</code> and <code>Into</code> traits are inherently linked. If your are able to convert type A from type B, then it should be easy to believe that we should be able to convert type B to type A.</p><p>The <code>From</code> trait allows for a type to define how to create itself from another type, hence providing a very simple mechanism for converting between several types.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">my_str</span> = <span class="string">&quot;hi&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">my_string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(my_str);</span><br></pre></td></tr></table></figure><p>The <code>Into</code> trait is simply the reciprocal of the <code>From</code> trait. That is, if you have implemented the <code>From</code> trait for your type you get the <code>Into</code> implementation for free.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::convert::<span class="built_in">From</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Number</span> &#123;</span><br><span class="line">    value: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">From</span>&lt;<span class="type">i32</span>&gt; <span class="keyword">for</span> <span class="title class_">Number</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">from</span>(item: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        Number &#123; value: item &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num</span> = Number::<span class="title function_ invoke__">from</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, num);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">int</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num</span>: Number = int.<span class="title function_ invoke__">into</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="To-and-from-Strings"><a href="#To-and-from-Strings" class="headerlink" title="To and from Strings"></a>To and from Strings</h3><h4 id="Converting-to-String"><a href="#Converting-to-String" class="headerlink" title="Converting to String"></a>Converting to String</h4><p>To convert any type to <code>String</code> is as simple as implenting the <code>ToString</code> trait for the type. Rather than doing so directly, you should implement the <code>fmt::Display</code> trait which automagically provides <code>ToString</code> and also allows printing the types as discussed in the section on <code>print!</code>.</p><h4 id="Parsing-a-String"><a href="#Parsing-a-String" class="headerlink" title="Parsing a String"></a>Parsing a String</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">parsed</span>: <span class="type">i32</span> = <span class="string">&quot;5&quot;</span>.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">turbo_parsed</span> = <span class="string">&quot;10&quot;</span>.parse::&lt;<span class="type">i32</span>&gt;().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sum</span> = parsed + turbo_parsed;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Sum: &#123;:?&#125;&quot;</span>, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Rust by examples notes about primitives.&lt;/p&gt;
&lt;h2 id=&quot;Primitives&quot;&gt;&lt;a href=&quot;#Primitives&quot; class=&quot;headerlink&quot; title=&quot;Primitives&quot;&gt;&lt;/a&gt;Primitiv</summary>
      
    
    
    
    <category term="Rust" scheme="http://readlnh.github.io/categories/Rust/"/>
    
    <category term="Rust-by-example-notes" scheme="http://readlnh.github.io/categories/Rust/Rust-by-example-notes/"/>
    
    
    <category term="Rust" scheme="http://readlnh.github.io/tags/Rust/"/>
    
    <category term="Type" scheme="http://readlnh.github.io/tags/Type/"/>
    
  </entry>
  
  <entry>
    <title>Formatting</title>
    <link href="http://readlnh.github.io/2019/11/01/Rust/Rust-by-example-notes/Formatting/"/>
    <id>http://readlnh.github.io/2019/11/01/Rust/Rust-by-example-notes/Formatting/</id>
    <published>2019-11-01T18:35:00.000Z</published>
    <updated>2022-10-27T19:58:23.769Z</updated>
    
    <content type="html"><![CDATA[<p>Some notes with Rust by example about formatting.</p><h2 id="Formatted-print"><a href="#Formatted-print" class="headerlink" title="Formatted print"></a>Formatted print</h2><p>Printing is handle by a series of <code>macros</code> defined in <code>std::fmt</code> some of which include:</p><ul><li><code>format!</code>: write formatted text to <code>String</code></li><li><code>print!</code>: print fotmatted text to the console(io::stdout) </li><li><code>println!</code>: same as <code>print!</code> but a newline is appended</li><li><code>eprint</code> : same as <code>format!</code>, but the text if printed to the santard error(io::stderr)</li><li><code>eprintln</code>: smae as <code>eprint</code>, but a newline is appended</li></ul><p><code>std::fmt</code> contains many <code>traits</code> which govern the display of text. The base form of two important ones are listed below:</p><ul><li><code>fmt::Debug</code>: Uses the <code>&#123;:?&#125;</code> marker. Format text for debugging purpoes</li><li><code>fmt::Display</code>: Uses the <code>&#123;&#125;</code> marker. Format text in a more elegant, user friendly fashion.</li></ul><p>Note: Implementing the <code>fmt::Display</code> trait automatically implements the <code>ToString</code> trait which allows us to <code>convert</code> the type to <code>String</code>.</p><h2 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h2><p>All types which want to use <code>std::fmt</code> formatting <code>traits</code> require an implementation to be printable. Automatic implementations are only provided for types such as in the <code>std</code> library. All others must be* maually* implemented somehow.</p><p>All types can <code>derive</code>(automatically create) the <code>fmt::Debug</code> implementation. This is not true for <code>fmt::Display</code> which must be manually implemented.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cannot be printed either with `fmt::Display` or  with `fmt::Debug`</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">UnPrintable</span>(<span class="type">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// The `derive` attribute automatically creates the implementation </span></span><br><span class="line"><span class="comment">// required to make this `struct` printable with `fmt::Debug` </span></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DebugUnPrintable</span>(<span class="type">i32</span>);</span><br></pre></td></tr></table></figure><p><code>fmt::Debug</code> definitely makes this printable but scarifices some elegance.Rust also provides <code>pretty printing</code> with <code>&#123;:#?&#125;</code></p><p>One can manually implemnet <code>fmt::Debug</code> instead of derive.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::&#123;<span class="keyword">self</span>, <span class="built_in">Debug</span>, Formatter&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TestDebug</span> &#123;</span><br><span class="line">    v1: <span class="type">i32</span>,</span><br><span class="line">    v2: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TestDebugauto</span> &#123;</span><br><span class="line">    v1: <span class="type">i32</span>,</span><br><span class="line">    v2: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">TestDebugauto</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(x: <span class="type">i32</span>, y: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        TestDebugauto &#123;</span><br><span class="line">            v1: x,</span><br><span class="line">            v2: y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">TestDebug</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(x: <span class="type">i32</span>, y: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        TestDebug &#123;</span><br><span class="line">            v1: x,</span><br><span class="line">            v2: y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Debug</span> <span class="keyword">for</span> <span class="title class_">TestDebug</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> Formatter) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">&quot;TestDebug: &#123;&#125; &#123;&#125;&quot;</span>, <span class="keyword">self</span>.v1, <span class="keyword">self</span>.v2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">t</span> = TestDebug::<span class="title function_ invoke__">new</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">t2</span> = TestDebugauto::<span class="title function_ invoke__">new</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;\n&#123;:?&#125;&quot;</span>, t, t2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>output</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   Compiling debug_manually v0.1.0 (/home/readlnh/workspace/rust_workspace/rust-by-example/debug_manually)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 0.29s</span><br><span class="line">     Running `target/debug/debug_manually`</span><br><span class="line">TestDebug: 1 2</span><br><span class="line">TestDebugauto &#123; v1: 1, v2: 2 &#125;</span><br></pre></td></tr></table></figure><h2 id="Display"><a href="#Display" class="headerlink" title="Display"></a>Display</h2><p>One can manually implement <code>fmt::Display</code> to control the display,same as <code>fmt::Debug</code>.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TestDisplay</span> &#123;</span><br><span class="line">    v1: <span class="type">i32</span>,</span><br><span class="line">    v2: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">TestDisplay</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(x: <span class="type">i32</span>, y: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        TestDisplay &#123;</span><br><span class="line">            v1: x,</span><br><span class="line">            v2: y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">TestDisplay</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="comment">// Write strictly the two elements into the supplied output</span></span><br><span class="line">        <span class="comment">// stream: `f`. Returns `fmt::Result` which indicates whether the</span></span><br><span class="line">        <span class="comment">// operation succeeded or failed. Note that `write!` uses syntax which</span></span><br><span class="line">        <span class="comment">// is very similar to `println!`.</span></span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">&quot;TestDebug: &#123;&#125; &#123;&#125;&quot;</span>, <span class="keyword">self</span>.v1, <span class="keyword">self</span>.v2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">t</span> = TestDisplay::<span class="title function_ invoke__">new</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><em>output</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   Compiling display_manually v0.1.0 (/home/readlnh/workspace/rust_workspace/rust-by-example/display_manually)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 0.28s</span><br><span class="line">     Running `target/debug/display_manually`</span><br><span class="line">TestDebug: 1 2</span><br></pre></td></tr></table></figure><p><strong>example for Complex structure</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Complex</span> &#123;</span><br><span class="line">    x: <span class="type">f64</span>,</span><br><span class="line">    y: <span class="type">f64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Complex</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(x: <span class="type">f64</span>, y: <span class="type">f64</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        Complex &#123;</span><br><span class="line">            x,</span><br><span class="line">            y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">Complex</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">&quot;&#123;&#125; + &#123;&#125;i&quot;</span>, <span class="keyword">self</span>.x, <span class="keyword">self</span>.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::<span class="built_in">Debug</span> <span class="keyword">for</span> <span class="title class_">Complex</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">&quot;Complex &#123;&#123; real: &#123;&#125; imag: &#123;&#125; &#125;&#125;&quot;</span>, <span class="keyword">self</span>.x , <span class="keyword">self</span>.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t</span> = Complex::<span class="title function_ invoke__">new</span>(<span class="number">3.3</span>, <span class="number">7.2</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;\n&#123;:?&#125;&quot;</span>, t, t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>output</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    Finished dev [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 0.01s</span><br><span class="line">     Running `target/debug/complex_display`</span><br><span class="line">3.3 + 7.2i</span><br><span class="line">Complex &#123; real: 3.3 imag: 7.2 &#125;</span><br></pre></td></tr></table></figure><p>Each <code>write!</code> generates a <code>fmt::Result</code>.Proper handing of this requires dealing with all the results.Rust provides <code>?</code> operater for exactly this purpose.</p><p><em>display for vector</em></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">List</span>(<span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="comment">// Extract the value using the type indexing</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">vec</span> = &amp;<span class="keyword">self</span>.<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">&quot;[&quot;</span>)?;</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">for</span> (index, v) <span class="keyword">in</span> vec.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">            <span class="keyword">if</span> index != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="built_in">write!</span>(f, <span class="string">&quot;, &quot;</span>)?;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">write!</span>(f, <span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, index, v)?;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">&quot;]&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="title function_ invoke__">List</span>(<span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>output</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0: 1, 1: 2, 2: 3]</span><br></pre></td></tr></table></figure><h2 id="Formatting"><a href="#Formatting" class="headerlink" title="Formatting"></a>Formatting</h2><p>Formatting is specified via a format string:</p><ul><li><code>format!(&quot;&#123;&#125;&quot;, foo)</code> -&gt; <code>&quot;3735928559&quot;</code></li><li><code>format!(&quot;0x&#123;:X&#125;&quot;, foo)</code> -&gt; <code>&quot;0xDEADBEEF&quot;</code></li><li><code>format!(&quot;0o&#123;:o&#125;&quot;, foo)</code> -&gt; <code>&quot;0o33653337357&quot;</code></li></ul><p>We can pad with zeros to a width of 6 with <code>:06</code></p><p><em>example code Color</em></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    r: <span class="type">i32</span>,</span><br><span class="line">    g: <span class="type">i32</span>,</span><br><span class="line">    b: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(r: <span class="type">i32</span>, g: <span class="type">i32</span>, b: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        Color &#123; r, g, b&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">&quot;RGB (&#123;&#125;, &#123;&#125;, &#123;&#125;) 0x&#123;:06X&#125;&quot;</span>, <span class="keyword">self</span>.r, <span class="keyword">self</span>.g, <span class="keyword">self</span>.b, <span class="keyword">self</span>.r * (<span class="number">1</span> &lt;&lt; <span class="number">16</span>) + <span class="keyword">self</span>.g * (<span class="number">1</span> &lt;&lt; <span class="number">8</span>) + <span class="keyword">self</span>.b )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t1</span> = Color::<span class="title function_ invoke__">new</span>(<span class="number">128</span>, <span class="number">255</span>, <span class="number">90</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t2</span> = Color::<span class="title function_ invoke__">new</span>(<span class="number">0</span>, <span class="number">3</span>, <span class="number">254</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t3</span> = Color::<span class="title function_ invoke__">new</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;\n&#123;&#125;\n&#123;&#125;&quot;</span>, t1, t2, t3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Some notes with Rust by example about formatting.&lt;/p&gt;
&lt;h2 id=&quot;Formatted-print&quot;&gt;&lt;a href=&quot;#Formatted-print&quot; class=&quot;headerlink&quot; title=&quot;Forma</summary>
      
    
    
    
    <category term="Rust" scheme="http://readlnh.github.io/categories/Rust/"/>
    
    <category term="Rust-by-example-notes" scheme="http://readlnh.github.io/categories/Rust/Rust-by-example-notes/"/>
    
    
    <category term="Rust" scheme="http://readlnh.github.io/tags/Rust/"/>
    
  </entry>
  
</feed>
