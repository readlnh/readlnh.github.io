{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://readlnh.github.io","root":"/"},"pages":[{"title":"About","date":"2022-10-27T19:58:23.769Z","updated":"2022-10-27T19:58:23.769Z","comments":true,"path":"about/index.html","permalink":"http://readlnh.github.io/about/index.html","excerpt":"","text":""},{"title":"Tags","date":"2022-10-27T19:58:23.769Z","updated":"2022-10-27T19:58:23.769Z","comments":true,"path":"tags/index.html","permalink":"http://readlnh.github.io/tags/index.html","excerpt":"","text":""},{"title":"Categories","date":"2022-10-27T19:58:23.769Z","updated":"2022-10-27T19:58:23.769Z","comments":true,"path":"categories/index.html","permalink":"http://readlnh.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2022-10-27T19:58:23.769Z","updated":"2022-10-27T19:58:23.769Z","comments":true,"path":"2022/10/27/hello-world/","link":"","permalink":"http://readlnh.github.io/2022/10/27/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Opengl初学","slug":"OpenGL/openl_learning01","date":"2022-10-27T19:58:23.769Z","updated":"2022-10-27T19:58:23.769Z","comments":true,"path":"2022/10/27/OpenGL/openl_learning01/","link":"","permalink":"http://readlnh.github.io/2022/10/27/OpenGL/openl_learning01/","excerpt":"","text":"GLFWGLFW是一个专门针对OpenGL的C语言库，它提供了一些渲染物体所需的最低限度的接口。它允许用户创建OpenGL上下文，定义窗口参数以及处理用户输入，这正是我们需要的。 GLAD因为OpenGL只是一个标准&#x2F;规范，具体的实现是由驱动开发商针对特定显卡实现的。由于OpenGL驱动版本众多，它大多数函数的位置都无法在编译时确定下来，需要在运行时查询。所以任务就落在了开发者身上，开发者需要在运行时获取函数地址并将其保存在一个函数指针中供以后使用。取得地址的方法因平台而异，在Windows上会是类似这样： 1234567// 定义函数原型typedef void (*GL_GENBUFFERS) (GLsizei, GLuint*);// 找到正确的函数并赋值给函数指针GL_GENBUFFERS glGenBuffers = (GL_GENBUFFERS)wglGetProcAddress(&quot;glGenBuffers&quot;);// 现在函数可以被正常调用了GLuint buffer;glGenBuffers(1, &amp;buffer); 你可以看到代码非常复杂，而且很繁琐，我们需要对每个可能使用的函数都要重复这个过程。幸运的是，有些库能简化此过程，其中GLAD是目前最新，也是最流行的库。 GLAD是用来管理OpenGL的函数指针的，所以在调用任何OpenGL的函数之前我们需要初始化GLAD。 12345if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))&#123; std::cout &lt;&lt; &quot;Failed to initialize GLAD&quot; &lt;&lt; std::endl; return -1;&#125; 我们给GLAD传入了用来加载系统相关的OpenGL函数指针地址的函数。GLFW给我们的是glfwGetProcAddress，它根据我们编译的系统定义了正确的函数。 Viewport在我们开始渲染之前还有一件重要的事情要做，我们必须告诉OpenGL渲染窗口的尺寸大小，即视口(Viewport)，这样OpenGL才只能知道怎样根据窗口大小显示数据和坐标。我们可以通过调用glViewport函数来设置窗口的维度(Dimension)： 1glViewport(0, 0, 800, 600); glViewport函数前两个参数控制窗口左下角的位置。第三个和第四个参数控制渲染窗口的宽度和高度（像素）。 OpenGL幕后使用glViewport中定义的位置和宽高进行2D坐标的转换，将OpenGL中的位置坐标转换为你的屏幕坐标。例如，OpenGL中的坐标(-0.5, 0.5)有可能（最终）被映射为屏幕中的坐标(200,450)。注意，处理过的OpenGL坐标范围只为-1到1，因此我们事实上将(-1到1)范围内的坐标映射到(0, 800)和(0, 600)。 然而，当用户改变窗口的大小的时候，视口也应该被调整。我们可以对窗口注册一个回调函数(Callback Function)，它会在每次窗口大小被调整的时候被调用。这个回调函数的原型如下： 1void framebuffer_size_callback(GLFWwindow* window, int width, int height); 这个帧缓冲大小函数需要一个GLFWwindow作为它的第一个参数，以及两个整数表示窗口的新维度。每当窗口改变大小，GLFW会调用这个函数并填充相应的参数供你处理。 1234void framebuffer_size_callback(GLFWwindow* window, int width, int height)&#123; glViewport(0, 0, width, height);&#125; 我们还需要注册这个函数，告诉GLFW我们希望每当窗口调整大小的时候调用这个函数： 1glfwSetFramebufferSizeCallback(window, framebuffer_size_callback); 当窗口被第一次显示的时候framebuffer_size_callback也会被调用。对于视网膜(Retina)显示屏，width和height都会明显比原输入值更高一点。 我们还可以将我们的函数注册到其它很多的回调函数中。比如说，我们可以创建一个回调函数来处理手柄输入变化，处理错误消息等。我们会在创建窗口之后，渲染循环初始化之前注册这些回调函数。渲染循环 主要作用就是让程序不要只绘制一个图像就退出。我们希望在我们主动关闭程序之前，它能不断绘制图像并接受用户输入。 123456while(!glfwWindowShouldClose(window)) &#123; processInput(window); glfwSwapBuffers(window); glfwPollEvents();&#125; glfwWindowShouldClose函数在我们每次循环的开始前检查一次GLFW是否被要求退出，如果是的话该函数返回true然后渲染循环便结束了，之后为我们就可以关闭应用程序了。glfwPollEvents函数检查有没有触发什么事件（比如键盘输入、鼠标移动等）、更新窗口状态，并调用对应的回调函数（可以通过回调方法手动设置）。glfwSwapBuffers函数会交换颜色缓冲（它是一个储存着GLFW窗口每一个像素颜色值的大缓冲），它在这一迭代中被用来绘制，并且将会作为输出显示在屏幕上。 cmakelist123456789101112131415161718192021222324cmake_minimum_required (VERSION 2.8)cmake_policy(VERSION 2.8)project (LearnOpenGL)link_directories($&#123;CMAKE_SOURCE_DIR&#125;/lib)list(APPEND CMAKE_CXX_FLAGS &quot;-std=c++11&quot;)find_package(OpenGL)find_package(glfw3 REQUIRED)include_directories($&#123;CMAKE_SOURCE_DIR&#125;/includes)include_directories($&#123;OPENGL_INCLUDE_DIR&#125;)add_library(GLAD SHARED &quot;src/glad.c&quot;)TARGET_LINK_LIBRARIES(GLAD dl)set(LIBS $&#123;LIBS&#125; GLAD $&#123;OPENGL_gl_LIBRARY&#125; glfw)add_executable(LearnOpenGL hello_window.cpp)target_link_libraries(LearnOpenGL $&#123;LIBS&#125;)","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://readlnh.github.io/categories/OpenGL/"}],"tags":[]},{"title":"Pipe(管道)的一些理解","slug":"Linux/APUE/pipe1","date":"2022-10-27T19:58:23.765Z","updated":"2022-10-27T19:58:23.765Z","comments":true,"path":"2022/10/27/Linux/APUE/pipe1/","link":"","permalink":"http://readlnh.github.io/2022/10/27/Linux/APUE/pipe1/","excerpt":"","text":"管道的概念管道是操作系统中常见的一种进程间通信方式，它使用于所有POSIX系统以及Windows系列产品。 管道也是unix ipc的最老形式，管道有两种限制： 数据自己读不能自己写 它们是半双工的。数据只能在一个方向上流动。 数据一旦被读走，便不在管道中存在，不可反复读取。 它们只能在具有公共祖先的进程之间使用。通常,一个管道由一个进程创建,然后该进程调用fork,此后父、子进程之间就可应用该管道。 管道的创建管道由pipe函数创建而成pipe(pipe_fd)经由参数pipe_fd返回两个文件描述符，pipe_fd[0]为读而打开,pipe_fd[1]为写而打开。pipe_fd[1]的输出是pipe_fd[0]的输入。 函数调用成功返回r&#x2F;w两个文件描述符。无需open，但需手动close。规定：fd[0] → r； fd[1] → w，就像0对应标准输入，1对应标准输出一样。向管道文件读写数据其实是在读写内核缓冲区。 管道创建成功以后，创建该管道的进程（父进程）同时掌握着管道的读端和写端。 具体通信过程如上图所示 父进程调用pipe函数创建管道，得到两个文件描述符fd[0]、fd[1]指向管道的读端和写端。 父进程调用fork创建子进程，那么子进程也有两个文件描述符指向同一管道。 父进程关闭管道读端，子进程关闭管道写端。父进程可以向管道中写入数据，子进程将管道中的数据读出。由于管道是利用环形队列实现的，数据从写端流入管道，从读端流出，这样就实现了进程间通信。 管道的读写行为如果所有指向管道写端的文件描述符都关闭了（管道写端引用计数为0），而仍然有进程从管道的读端读数据，那么管道中剩余的数据都被读取后，再次read会返回0，就像读到文件末尾一样。 如果有指向管道写端的文件描述符没关闭（管道写端引用计数大于0），而持有管道写端的进程也没有向管道中写数据，这时有进程从管道读端读数据，那么管道中剩余的数据都被读取后，再次read会阻塞，直到管道中有数据可读了才读取数据并返回。 如果所有指向管道读端的文件描述符都关闭了（管道读端引用计数为0），这时有进程向管道的写端write，那么该进程会收到信号SIGPIPE，通常会导致进程异常终止。当然也可以对SIGPIPE信号实施捕捉，不终止进程。具体方法信号章节详细介绍。 如果有指向管道读端的文件描述符没关闭（管道读端引用计数大于0），而持有管道读端的进程也没有从管道中读数据，这时有进程向管道写端写数据，那么在管道被写满时再次write会阻塞，直到管道中有空位置了才写入数据并返回。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;sys/wait.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;int main() &#123; int pipe_fd[2]; pid_t child_pid; char pipe_buf; memset(pipe_fd, 0, sizeof(pipe_fd)); if(pipe(pipe_fd) == -1) &#123; return -1; &#125; child_pid = fork(); if(child_pid == -1) &#123; return -1; &#125; if(child_pid == 0) &#123; close(pipe_fd[1]); while(read(pipe_fd[0], &amp;pipe_buf, 1) &gt; 0) &#123; write(STDOUT_FILENO, &amp;pipe_buf, 1); printf(&quot;\\npipe_buf is %c\\n&quot;, pipe_buf); printf(&quot;\\nsuccess\\n&quot;); &#125; close(pipe_fd[0]); return 0; &#125; else &#123; close(pipe_fd[0]); write(pipe_fd[1], &quot;H&quot;, 1); close(pipe_fd[1]); wait(NULL); return 0; &#125;&#125;","categories":[{"name":"Linux","slug":"Linux","permalink":"http://readlnh.github.io/categories/Linux/"},{"name":"APUE","slug":"Linux/APUE","permalink":"http://readlnh.github.io/categories/Linux/APUE/"}],"tags":[]},{"title":"聊一聊linux中的cgroup","slug":"Linux/docker/cgroup","date":"2022-10-27T19:58:23.765Z","updated":"2022-10-27T19:58:23.765Z","comments":true,"path":"2022/10/27/Linux/docker/cgroup/","link":"","permalink":"http://readlnh.github.io/2022/10/27/Linux/docker/cgroup/","excerpt":"","text":"最近由于工作原因接触了docker，也就研究一下它的原理，主要看了阿里出的&lt;&lt;自己动手写docker&gt;&gt;，感觉蛮有意思，姑且记录一下。docker可以算是当前非常火热的技术了。我们知道docker基于Namespce和Cgroups，其中 Namespace主要用于隔离资源 Cgroups用来提供对一组进程以及将来子进程的资源限制 Cgrougps的三个组件cgrpups包含三个组件 控制组 一个cgroups包含一组进程，并可以在这个cgroups上增加Linux subsystem的各种参数配置，将一组进程和一组subsystem关联起来。 subsystem 子系统 是一组资源控制模块，可以通过lssubsys -a命令查看当前内核支持哪些subsystem。 1234567891011cpusetcpu,cpuacctblkiomemorydevicesfreezernet_cls,net_prioperf_eventhugetlbpidsrdma subsystem作用于hierarchy的cgroup节点，并控制节点中进程的资源占用。 hierarchy 层级树 主要功能是把cgroups串成一个树型结构，使cgruops可以做到继承。也就是说将cgroup通过树状结构串起来，通过虚拟文件系统的方式暴露给用户。 三个组件之前的关系cgroup中的组件是相互关联的 系统创建新的hierarchy之后，系统中所有的进程都会加入这个hierarchy的cgroup的根节点，这个cgroup根节点是hierarchy默认创建的，在这个hierarchy中创建的所有cgroup都是这个cgroup根节点的子节点。 一个subsystem只能附加到一个hierarchy上 一个hierarchy可以附加多个subsystem 一个进程可以作为多个cgroup的成员，但是这些cgroup必须在不同的hierarchy下 一个进程fork出子进程时，子进程和父进程是在同一个cgroup中的，根据需要也可以移动到其他的cgroup中 使用Cgroup创建挂载点我们知道kernel是通过一个虚拟树状文件系统来配置Cgroups的。我们首先需要创建并挂载一个hierarchy(cgroup树)。即先mkdir后mount。 123456readlnh@readlnh-Inspiron-3542:~$ sudo mount -t cgroup -o none,name=cgroup-test cgroup-test cgroup-test/readlnh@readlnh-Inspiron-3542:~$ ls ./ccgroup-test/ clone_test.creadlnh@readlnh-Inspiron-3542:~$ ls ./cgroup-test/cgroup.clone_children cgroup.sane_behavior release_agentcgroup.procs notify_on_release tasks 可以看到挂载后系统在目录下生成了一系列文件，这些文件其实就是根节点文件的配置项。 创建子cgroup创建cgroup-1，我们可以看到在cgroup文件夹下再创建文件夹，系统会将这个文件夹也标记为cgroup，并且它是上一个cgroup的子cgroup，它会继承父cgroup的属性 12345678910111213141516readlnh@readlnh-Inspiron-3542:~/cgroup-test$ sudo mkdir cgroup-1readlnh@readlnh-Inspiron-3542:~/cgroup-test$ tree.├── cgroup-1│ ├── cgroup.clone_children│ ├── cgroup.procs│ ├── notify_on_release│ └── tasks├── cgroup.clone_children├── cgroup.procs├── cgroup.sane_behavior├── notify_on_release├── release_agent└── tasks1 directory, 10 files 移动进程将终端进程移动到cgroup-1(只要将进程ID写到相应的cgroup的tasks文件) 123456789101112131415161718192021222324252627282930313233readlnh@readlnh-Inspiron-3542:~/cgroup-test/cgroup-1$ echo $$10644readlnh@readlnh-Inspiron-3542:~/cgroup-test/cgroup-1$ cat /proc/10644/cgroup 13:name=cgroup-test:/12:perf_event:/11:memory:/user.slice10:hugetlb:/9:cpuset:/8:pids:/user.slice/user-1000.slice/user@1000.service7:rdma:/6:devices:/user.slice5:freezer:/4:cpu,cpuacct:/user.slice3:net_cls,net_prio:/2:blkio:/user.slice1:name=systemd:/user.slice/user-1000.slice/user@1000.service/gnome-terminal-server.service0::/user.slice/user-1000.slice/user@1000.service/gnome-terminal-server.servicereadlnh@readlnh-Inspiron-3542:~/cgroup-test/cgroup-1$ sudo sh -c &quot;echo $$ &gt;&gt; tasks&quot;readlnh@readlnh-Inspiron-3542:~/cgroup-test/cgroup-1$ cat /proc/10644/cgroup 13:name=cgroup-test:/cgroup-112:perf_event:/11:memory:/user.slice10:hugetlb:/9:cpuset:/8:pids:/user.slice/user-1000.slice/user@1000.service7:rdma:/6:devices:/user.slice5:freezer:/4:cpu,cpuacct:/user.slice3:net_cls,net_prio:/2:blkio:/user.slice1:name=systemd:/user.slice/user-1000.slice/user@1000.service/gnome-terminal-server.service0::/user.slice/user-1000.slice/user@1000.service/gnome-terminal-server.service 可以看到现在终端进程已经在cgroup-1了 通过subsystem限制cgroups中的进程资源之前我们创建的cgroup是没有和任何subsystem相关联的，所以没法通过hierarchy中的cgroup节点限制资源。实际系统中已经默认为每个subsystem创建了一个默认的hierarchy，我们这里就直接在这个hierarchy下创建cgroup 12345678910111213141516171819202122readlnh@readlnh-Inspiron-3542:~/cgroup-test/test-limit-memory$ mount | grep memorycgroup on /sys/fs/cgroup/memory type cgroup (rw,nosuid,nodev,noexec,relatime,memory)readlnh@readlnh-Inspiron-3542:~/cgroup-test/test-limit-memory$ cd /sys/fs/cgroup/memory/readlnh@readlnh-Inspiron-3542:/sys/fs/cgroup/memory$ sudo mkdir test-limit-memoryreadlnh@readlnh-Inspiron-3542:/sys/fs/cgroup/memory$ cd test-limit-memory/readlnh@readlnh-Inspiron-3542:/sys/fs/cgroup/memory/test-limit-memory$ lscgroup.clone_children memory.limit_in_bytescgroup.event_control memory.max_usage_in_bytescgroup.procs memory.move_charge_at_immigratememory.failcnt memory.numa_statmemory.force_empty memory.oom_controlmemory.kmem.failcnt memory.pressure_levelmemory.kmem.limit_in_bytes memory.soft_limit_in_bytesmemory.kmem.max_usage_in_bytes memory.statmemory.kmem.slabinfo memory.swappinessmemory.kmem.tcp.failcnt memory.usage_in_bytesmemory.kmem.tcp.limit_in_bytes memory.use_hierarchymemory.kmem.tcp.max_usage_in_bytes notify_on_releasememory.kmem.tcp.usage_in_bytes tasksmemory.kmem.usage_in_bytesreadlnh@readlnh-Inspiron-3542:/sys/fs/cgroup/memory/test-limit-memory$ stress --vm-bytes 200m --vm-keep -m 1stress: info: [15357] dispatching hogs: 0 cpu, 0 io, 1 vm, 0 hdd 用top查看，发现内存为100m，实际上这里限制内存就是一个向memory_limit_in_bytes文件中写入100m这个操作，可以说相简单了 115358 readlnh 20 0 213044 100916 212 D 39.5 1.3 7:54.10 stress 从这里我们就可以猜测，docker实际上就是通过go语言挂载，创建cgroups再向相应文件写入相应条件来限制容器资源的。cgroup确实是一个很有意思也很方便的功能。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://readlnh.github.io/categories/Linux/"},{"name":"docker","slug":"Linux/docker","permalink":"http://readlnh.github.io/categories/Linux/docker/"}],"tags":[]},{"title":"docker技术分析 - linux namespce机制","slug":"Linux/docker/linux namespce机制初探","date":"2022-10-27T19:58:23.765Z","updated":"2022-10-27T19:58:23.765Z","comments":true,"path":"2022/10/27/Linux/docker/linux namespce机制初探/","link":"","permalink":"http://readlnh.github.io/2022/10/27/Linux/docker/linux%20namespce%E6%9C%BA%E5%88%B6%E5%88%9D%E6%8E%A2/","excerpt":"","text":"docker技术是近年来无比火热的技术，不管是哪个领域大家都在研究和使用docker。我们在使用docker的时候经常听人说，docker是基于linux内核的Namespace和Cgroup技术实现的。那么究竟什么是Namespace技术呢？ linux namespcelinux的namespce机制提供了一种资源隔离方案，它是Linux平台实现容器这种轻量级的虚拟化的基础。namespce使得PID，IPC，NetWork等系统资源不再是全局性，而是属于特定的namespace的，只需要在clone的时候指定相应的flag，就可以创建相应的namespce。大部分容器就是利用了这一技术实现了资源的隔离，不同容器内的进程属于不同的namespace，彼此透明互不干扰。 目前linux实现了以下6种Namespace Mount namespaces(2.4.19) UTS namespaces(2.6.19) IPC namespaces(2.6.19) PID namespaces(2.6.24) Network namespaces(2.6.29) User namespaces(3.8) Mount namespacesMount namespaces为一组进程隔离了一系列的文件系统挂载点。在不同Mount namespaces的进程有不同的文件系统层次视图。通过使用Mount namespaces，进程调用mount()和umount()函数时不再操作对所有进程可见的全局挂载点，而是只操作调用进程所关联的mount namespace。 使用Mount namespaces可以象chroot方式一样创建环境。但是，与使用chroot调用对比，Mount namespaces方式更加安全和灵活。 Mount namespaces是Linux中实现的第一种namespace(2002年)。 UTS namespacesUTS namespaces实现uname()系统调用返回的对两个系统描述符nodename和domainname的隔离（这两个值可以由sethostname()和setdomainname()系统调用来设置）。 在容器的上下文中，UTS namespaces允许每个容器有自己的hostname和NIS domain name。这对于基于这两个名字的初始化和配置脚本很有用。 PID namespacesPID namespaces实现进程间ID空间隔离。在不同PID namespaces中的进程可以有相同的PID。PID namespaces的一个主要好处是容器可以在不同的主机上移植，保持容器内部的进程ID不变。 PID namespaces还允许每个容器有自己的init进程，及PID为1的进程，这个进程是容器中所有进程的祖先。 NET namespacesNET namespaces提供对与网络相关的系统资源的隔离。每个Network namespace有自己的网络设备、IP地址、IP路由表、&#x2F;proc&#x2F;net目录，端口号等等。 也就是说同一台主机上的多个容器中的web服务器都可以绑定80端口。 User namespacesUser namespaces提供对用户id和组id号码空间的资源隔离。在一个user namespaces内部和外部，一个进程有不同的userid和groupid。 User namespace可以让一个进程在User namespace内有root权限，而在User namespace外则只有普通权限。 用go语言来操作namespace由于docker是用go语言实现的，故我这里也使用go语言来作为范例，创建一个utsnamespace。代码如下 12345678910111213141516171819202122package mainimport ( &quot;os&quot; &quot;os/exec&quot; &quot;syscall&quot; &quot;log&quot;)func main() &#123; cmd := exec.Command(&quot;sh&quot;) cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123; Cloneflags: syscall.CLONE_NEWUTS, &#125; cmd.Stdin = os.Stdin cmd.Stdout = os.Stdout cmd.Stderr = os.Stderr if err := cmd.Run(); err != nil &#123; log.Fatal(err) &#125;&#125; 这里go语言帮我们封装了对clone函数的调用，我们在这里指定了系统调用的参数Cloneflags: syscall.CLONE_NEWUTS，系统会根据该参数去创建一个UTC Namespace并进入到一个sh环境中。我们执行go build，再运行该程序，注意，这里我们需要以管理员权限来执行该程序，不然会提示如下错误。我们运行该程序后似乎什么都没有发生，实际上我们已经进入新的namespace了此时在终端输入hostname命令，发现和主机的hostname是一样的我们在新建的namespace里修改hostname，此时我们在宿主机上再启动一个终端，执行hostname命令，发现宿主机的hostname并没有改变，由此可见UTC Namespce可以拥有自己的hostname。这里我们只指定了一个参数，实际上我们可以在clone时同时指定多重命名空间，由此来达到进程的隔离，各位读者可以自行尝试。如果想使用c语言来进行尝试，只需要在调用clone()函数时指定相应参数即可，这里就不过多展开了。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://readlnh.github.io/categories/Linux/"},{"name":"docker","slug":"Linux/docker","permalink":"http://readlnh.github.io/categories/Linux/docker/"}],"tags":[]},{"title":"如何在docker中运行ubuntukylin桌面系统","slug":"Linux/docker/如何在docker中运行ubuntukylin桌面系统","date":"2022-10-27T19:58:23.765Z","updated":"2022-10-27T19:58:23.769Z","comments":true,"path":"2022/10/27/Linux/docker/如何在docker中运行ubuntukylin桌面系统/","link":"","permalink":"http://readlnh.github.io/2022/10/27/Linux/docker/%E5%A6%82%E4%BD%95%E5%9C%A8docker%E4%B8%AD%E8%BF%90%E8%A1%8Cubuntukylin%E6%A1%8C%E9%9D%A2%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"背景由于要和开源社合办一个活动，要求线上线下同时进行，需要使用对方的云平台，本来以为只需要提供iso镜像就行了，没想到对方只支持docker镜像。虽然之前用过docker，但是完全没想过docker里跑桌面。 思路调研和已有开源项目说实话，由于没怎么接触过docker，所以花了一上午时间看了下docker实践教程，但是对如何运行桌面还是没什么头绪。但是我之前在win10刚出wsl的时候好奇去尝试过，当时有一种使用ximage映射使wsl运行图形界面的方案，我猜测docker也可以通过这种类似远程桌面的方式来跑桌面。 同时我又寻找了一些开源项目，这里不得不吐槽下，大家似乎对在docker里启桌面都没什么兴趣，相关资料是真的少… 首先是kde neno，kde neno有docker镜像的试用，看了下发现采用的是xserver-xwphyr这个方案，但是对于docker镜像的细节并看不到，遂放弃。 然后我想到了deepin，似乎曾经听说过他们有相应的docker镜像，我抱着试试看的心态去找了找，发现确实有一个在docker里运行桌面的方案，然而是使用xdocker，这个显然不符合我的预期，只能放弃。 最后终于在github上找到了这个docker-ubuntu-vnc-desktop 这个项目是在docker里运行lxde桌面的ubuntu，并通过浏览器来访问。效果如下 效果相当不错，赶紧看看人家的dockerfile是如何构建的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115# Built with arch: amd64 flavor: lxde image: ubuntu:18.04 localbuild: 1################################################################################## base system################################################################################FROM ubuntu:18.04 as systemRUN sed -i &#x27;s#http://archive.ubuntu.com/#http://tw.archive.ubuntu.com/#&#x27; /etc/apt/sources.list; # built-in packagesENV DEBIAN_FRONTEND noninteractiveRUN apt update \\ &amp;&amp; apt install -y --no-install-recommends software-properties-common curl apache2-utils \\ &amp;&amp; apt update \\ &amp;&amp; apt install -y --no-install-recommends --allow-unauthenticated \\ supervisor nginx sudo net-tools zenity xz-utils \\ dbus-x11 x11-utils alsa-utils \\ mesa-utils libgl1-mesa-dri \\ &amp;&amp; apt autoclean -y \\ &amp;&amp; apt autoremove -y \\ &amp;&amp; rm -rf /var/lib/apt/lists/*# install debs error if combine togetherRUN add-apt-repository -y ppa:fcwu-tw/apps \\ &amp;&amp; apt update \\ &amp;&amp; apt install -y --no-install-recommends --allow-unauthenticated \\ xvfb x11vnc=0.9.16-1 \\ vim-tiny firefox chromium-browser ttf-ubuntu-font-family ttf-wqy-zenhei \\ &amp;&amp; add-apt-repository -r ppa:fcwu-tw/apps \\ &amp;&amp; apt autoclean -y \\ &amp;&amp; apt autoremove -y \\ &amp;&amp; rm -rf /var/lib/apt/lists/*RUN apt update \\ &amp;&amp; apt install -y --no-install-recommends --allow-unauthenticated \\ lxde gtk2-engines-murrine gnome-themes-standard gtk2-engines-pixbuf gtk2-engines-murrine arc-theme \\ &amp;&amp; apt autoclean -y \\ &amp;&amp; apt autoremove -y \\ &amp;&amp; rm -rf /var/lib/apt/lists/* # Additional packages require ~600MB# libreoffice pinta language-pack-zh-hant language-pack-gnome-zh-hant firefox-locale-zh-hant libreoffice-l10n-zh-tw# tini for subreapARG TINI_VERSION=v0.18.0ADD https://github.com/krallin/tini/releases/download/$&#123;TINI_VERSION&#125;/tini /bin/tiniRUN chmod +x /bin/tini# ffmpegRUN mkdir -p /usr/local/ffmpeg \\ &amp;&amp; curl -sSL https://johnvansickle.com/ffmpeg/releases/ffmpeg-release-amd64-static.tar.xz | tar xJvf - -C /usr/local/ffmpeg/ --strip 1# python libraryCOPY image/usr/local/lib/web/backend/requirements.txt /tmp/RUN apt-get update \\ &amp;&amp; dpkg-query -W -f=&#x27;$&#123;Package&#125;\\n&#x27; &gt; /tmp/a.txt \\ &amp;&amp; apt-get install -y python-pip python-dev build-essential \\ &amp;&amp; pip install setuptools wheel &amp;&amp; pip install -r /tmp/requirements.txt \\ &amp;&amp; dpkg-query -W -f=&#x27;$&#123;Package&#125;\\n&#x27; &gt; /tmp/b.txt \\ &amp;&amp; apt-get remove -y `diff --changed-group-format=&#x27;%&gt;&#x27; --unchanged-group-format=&#x27;&#x27; /tmp/a.txt /tmp/b.txt | xargs` \\ &amp;&amp; apt-get autoclean -y \\ &amp;&amp; apt-get autoremove -y \\ &amp;&amp; rm -rf /var/lib/apt/lists/* \\ &amp;&amp; rm -rf /var/cache/apt/* /tmp/a.txt /tmp/b.txt################################################################################# builder################################################################################FROM ubuntu:18.04 as builderRUN sed -i &#x27;s#http://archive.ubuntu.com/#http://tw.archive.ubuntu.com/#&#x27; /etc/apt/sources.list; RUN apt-get update \\ &amp;&amp; apt-get install -y --no-install-recommends curl ca-certificates gnupg patch# nodejsRUN curl -sL https://deb.nodesource.com/setup_8.x | bash - \\ &amp;&amp; apt-get install -y nodejs# yarnRUN curl -sS https://dl.yarnpkg.com/debian/pubkey.gpg | apt-key add - \\ &amp;&amp; echo &quot;deb https://dl.yarnpkg.com/debian/ stable main&quot; | tee /etc/apt/sources.list.d/yarn.list \\ &amp;&amp; apt-get update \\ &amp;&amp; apt-get install -y yarn# build frontendCOPY web /src/webRUN cd /src/web \\ &amp;&amp; yarn \\ &amp;&amp; npm run build################################################################################# merge################################################################################FROM systemLABEL maintainer=&quot;fcwu.tw@gmail.com&quot;COPY --from=builder /src/web/dist/ /usr/local/lib/web/frontend/COPY image /EXPOSE 80WORKDIR /rootENV HOME=/home/ubuntu \\ SHELL=/bin/bashHEALTHCHECK --interval=30s --timeout=5s CMD curl --fail http://127.0.0.1:6079/api/healthENTRYPOINT [&quot;/startup.sh&quot;] 发现这个镜像是从最基础的ubuntu18.04开始构建的，然后安装桌面对应的包。然后很关键的，安装了xvfb和x11vnc这两个包。xvfb是虚拟显卡，x11vnc则是用来提供x11服务的，以便主机通过x11客户端来访问桌面。 继续往下看，略过那些库，还有两个重要的操作，一个是把上下文中的web后端部署到docker中，但是我并不清楚开源社会采用什么方案，我理解里应该只需要提供相应的vnc端口即可，所以这一步没什么必要。另一个则是ADD https://github.com/krallin/tini/releases/download/$&#123;TINI_VERSION&#125;/tini /bin/tini我去到github项目主页下发现这是个用来初始化并启动系统的项目，但是似乎新版的docker已经自带这个功能？于是乎思路已经基本定了，在docker的系统中安装xvfb和x11vnc,用xvfb虚拟显卡，通过x11vnc提供显示服务。 制作过程等等，一般的docker镜像制作都是从基础镜像开始构建的，但是我并不清楚ubuntukylin需要哪些包…这下子尴尬了。好在docker可以通过导入tar包来制作镜像。我找了一台已经安卓ubuntukylin19.04增强版的机器，把根目录下除了启动时自动生成的那些目录打包到一个tar包里，最后导入到docker制作成镜像。 1tar -cvpf /tmp/system.tar --directory=/ --exclude=proc --exclude=sys --exclude=dev --exclude=run --exclude=boot . 其中&#x2F;proc、&#x2F;sys、&#x2F;run、&#x2F;dev这几个目录都是系统启动时自动生成的，虽然也属于文件系统一部分，但是他们每次开机都会有变化，所以打包的时候就应该忽略它们。然后执行 1cat system.tar | docker import - ubuntukylin:19.04 这样，镜像就制作完毕了。 接下来运行docker，恩？什么都没有发生？？？进入容器一看，发现ligtdm根本没有启动，这就很尴尬了…找了半天问题，没什么头绪，大概猜测和systemd有关，一不做二不休，手动启动ukui-session！恩？什么情况，我的桌面怎么没了，被docker内的ukui占用了，开始运行开机动画？我进到容器里查看，发现&#x2F;dev目录下挂载了宿主机的设备，去看了下runc的源码，最后得出的结论是systemd的改动，使得某些目录变成shared by default，所以主机显卡被docker占用了导致主机桌面挂掉了…吸取教训，先把&#x2F;dev的挂载点删了再启动…结果卡在登录进不去？？？然后同事说ukui-greeter出了bug，但是作者上周刚刚才离职了…行吧，不要登录锁屏了，直接把这个包卸载了。ok，终于成功的进了桌面，等等，窗口管理器怎么不见了，鼠标变成x了，想了想发现是自己头脑混乱了，在管理员权限下启动了桌面，用su lm(用户名),切换到普通用户lm，终于正常了。 但是我不能每次都手动去启动吧，必须在启动时自动执行脚本才行，于是在&#x2F;etc新建了一个rc.local脚本，每次先删除设备节点，然后通过xvfb创建虚拟显卡，设置显示区域，切换到普通用户并执行runsession脚本(chmod + x) 12345678910111213#!/bin/bashrm /dev/fb0rm -rf /dev/driexport DISPLAY=:1Xvfb :1 -screen 0 1024x768x16 &gt; /opt/xvfb.log 2&gt;&amp;1 &amp;su lm -c /home/lm/runsessionsleep 10su lm -c /home/lm/runukwm runsession脚本 12345678910111213141516#!/bin/shexport DISPLAY=:1DISPLAY=:1 x11vnc -display :1 -forever -bg -nopw -xkb#sleep 30export QT4_IM_MODULE=fcitx export QT_IM_MODULE=fcitx export XMODIFIERS=@im=fcitx export GTK_IM_MODULE=fcitx /usr/bin/fcitxQT4_IM_MODULE=fcitx QT_IM_MODULE=fcitx XMODIFIERS=@im=fcitx GTK_IM_MODULE=fcitx DISPLAY=:1 ukui-session &gt; /home/lm/ukui-session.log 2&gt;&amp;1 &amp; 12345#!/bin/bashexport DISPLAY=:1XDG_SESSION_TYPE=x11 DISPALY=:1 UKWM_VERBOSE=1 ukwm -r &gt; /home/lm/ukwm.log 2&gt;&amp;1 &amp; 脚本里主要就是启动了x11vnc设置了一些默认参数，最后启动ukui-session。这里要注意的是，rc.local执行脚本的时候会缺失很多环境变量，必须在脚本里指定，否则会导致一些异常行为。 禁用plymouth相关服务 1find -name *plymouth*.service 全删了即可 至此，docker镜像完成了。 运行结果执行 1docker run --name test1(容器名) --cap-add ALL --privileged=true -td readlnh/ubuntukylin-vnc-docker:19.04 /sbin/init 创建并启动容器使用如下命令查看ip地址 1docker inspect test1(容器名) 最后通过vncview来连接 1vncviewer 172.17.0.2(容器ip):5900(默认端口) 效果如下","categories":[{"name":"Linux","slug":"Linux","permalink":"http://readlnh.github.io/categories/Linux/"},{"name":"docker","slug":"Linux/docker","permalink":"http://readlnh.github.io/categories/Linux/docker/"}],"tags":[]},{"title":"How to use local unpublished crate in Rust by cargo","slug":"Rust/local_unpublished_crate_in_Rust","date":"2020-09-22T19:21:00.000Z","updated":"2022-10-27T19:58:23.769Z","comments":true,"path":"2020/09/22/Rust/local_unpublished_crate_in_Rust/","link":"","permalink":"http://readlnh.github.io/2020/09/22/Rust/local_unpublished_crate_in_Rust/","excerpt":"","text":"Cargo is configured to look for dependencies on crates.io by defalut. However I want to use a local crate. Fortunately, cargo supports to use libraries ont only on crates.io, but also ther registries, git repositories or subdirectories on our local file system. create a libFirstly, create a new package: 1$ cargo new test_crate --lib Here we pass --lib because we’re making a library. Then the cargo generates: 12345678.├── Cargo.lock├── Cargo.toml└── src └── lib.rs1 directory, 3 files Let’s do something in lib.rs. 123456789pub fn public_function_in_test_crate() &#123; println!(&quot;called `public_function_in_test_crate`&quot;);&#125;pub mod cool &#123; pub fn cool_function() &#123; println!(&quot;called `cool::cool_function`&quot;); &#125;&#125; set Cargo.tomlThen we create a new binary program use cargo new test_extern_crate and add a dependency section to our executable’s Cargo.toml and sepcify the path: 12[dependencies]test_crate = &#123;path = &quot;../test_crate&quot;&#125; or 12[dependencies.test_crate]path = &quot;../test_crate&quot; Now we can use our local crate test_crate as folliwing: main.rs: 123456789extern crate test_crate;use test_crate::cool;fn main() &#123; test_crate::public_function_in_test_crate(); test_crate::cool::cool_function(); cool::cool_function();&#125; more details in more detals in Cargo book .","categories":[{"name":"Rust","slug":"Rust","permalink":"http://readlnh.github.io/categories/Rust/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"http://readlnh.github.io/tags/Rust/"},{"name":"cargo","slug":"cargo","permalink":"http://readlnh.github.io/tags/cargo/"},{"name":"crate","slug":"crate","permalink":"http://readlnh.github.io/tags/crate/"}]},{"title":"ref in Rust","slug":"Rust/ref_in_rust","date":"2020-09-22T19:21:00.000Z","updated":"2022-10-27T19:58:23.769Z","comments":true,"path":"2020/09/22/Rust/ref_in_rust/","link":"","permalink":"http://readlnh.github.io/2020/09/22/Rust/ref_in_rust/","excerpt":"","text":"When doing pattern matching or destructuring via let binding, the ref keyword can be used to take references to the field of a struct&#x2F;tuple. A ref borrow on the left side of an assignment is equivalent to an &amp; borrow on the right side. 12345678910111213fn main() &#123; let i = 3; &#123; let borrow1 = &amp;i; println!(&quot;borrow1: &#123;&#125;&quot;, borrow1); &#125; &#123; let ref borrow2 = i; println!(&quot;borrow2: &#123;&#125;&quot;, borrow2); &#125;&#125; Destructuring a struct: 1234567891011121314struct Point &#123; x: i32, y: i32&#125;fn main() &#123; let point = Point&#123;x: 1, y: 2&#125;; let Point&#123;x: xx, y: yy&#125; = point; println!(&quot;&#123;&#125; &#123;&#125;&quot;, xx, yy); let Point&#123;x: ref xx, y: ref yy&#125; = point; println!(&quot;&#123;&#125; &#123;&#125;&quot;, *xx, *yy);&#125;","categories":[{"name":"Rust","slug":"Rust","permalink":"http://readlnh.github.io/categories/Rust/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"http://readlnh.github.io/tags/Rust/"},{"name":"ref","slug":"ref","permalink":"http://readlnh.github.io/tags/ref/"}]},{"title":"Returning Traits with `dyn`","slug":"Rust/returning_traits_with_dyn","date":"2020-09-22T19:21:00.000Z","updated":"2022-10-27T19:58:23.769Z","comments":true,"path":"2020/09/22/Rust/returning_traits_with_dyn/","link":"","permalink":"http://readlnh.github.io/2020/09/22/Rust/returning_traits_with_dyn/","excerpt":"","text":"Let’s see the following codes: 1234567891011121314151617181920212223242526272829303132333435363738394041424344use rand::prelude::*;struct Sheep &#123;&#125;struct Cow &#123;&#125;trait Animal &#123; fn noise(&amp;self) -&gt; &amp;&#x27;static str;&#125;impl Animal for Sheep &#123; fn noise(&amp;self) -&gt; &amp;&#x27;static str &#123; &quot;baaaaaah!&quot; &#125;&#125;impl Animal for Cow &#123; fn noise(&amp;self) -&gt; &amp;&#x27;static str &#123; &quot;mooooooo!&quot; &#125;&#125;fn random_animal(random_number: f64) -&gt; Box&lt;dyn Animal&gt; &#123; if random_number &lt; 0.5 &#123; Box::new(Sheep &#123;&#125;) &#125; else &#123; Box::new(Cow &#123;&#125;) &#125;&#125;fn choose_cow(random_number: f64) -&gt; impl Animal &#123; println!(&quot;choose_cow::The number is &#123;&#125;.&quot;, random_number); Cow &#123; &#125;&#125;fn main() &#123; let mut rng = rand::thread_rng(); let random_number = rng.gen(); let animal = random_animal(random_number); println!(&quot;You&#x27;ve randomly chosen an animal, and it says &#123;&#125;&quot;, animal.noise()); let animal = choose_cow(random_number); println!(&quot;You&#x27;ve chosen a cow, and it says &#123;&#125;&quot;, animal.noise());&#125; As the codes saying, if we’re returning a single type for our functions, we can use impl Trait, just as: 12345fn choose_cow(random_number: f64) -&gt; impl Animal &#123; println!(&quot;choose_cow::The number is &#123;&#125;.&quot;, random_number); Cow &#123; &#125;&#125; However, if function returns multiable types, it doesn’t work. Because the Rust compiler needs to know how much space every functions’s return type requiers. This means the return type of a function must have a statically known size. We can’t write a function that returns Animal, because the different implementions will need different amounts of memory. Instead of returning a trait object directly, our functions return a Box which contains some Animal. A box is just a reference to some memory in the heap. Because a reference has a statically-known size, and the compiler can guarantee it points to a heap-allocated Animal, we can return a trait from our function! Rust tries to be as explicit as possible whenever it allocates memory on the heap. So if your function returns a pointer-to-trait-on-heap in this way, you need to write the return type with the dyn keyword, e.g. Box&lt;dyn Animal&gt;.","categories":[{"name":"Rust","slug":"Rust","permalink":"http://readlnh.github.io/categories/Rust/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"http://readlnh.github.io/tags/Rust/"},{"name":"dyn","slug":"dyn","permalink":"http://readlnh.github.io/tags/dyn/"},{"name":"trait","slug":"trait","permalink":"http://readlnh.github.io/tags/trait/"}]},{"title":"笔记1-独立的Rust应用","slug":"Rust/blog_os notes/note_01","date":"2020-09-22T19:11:00.000Z","updated":"2022-10-27T19:58:23.769Z","comments":true,"path":"2020/09/22/Rust/blog_os notes/note_01/","link":"","permalink":"http://readlnh.github.io/2020/09/22/Rust/blog_os%20notes/note_01/","excerpt":"","text":"第一步，先通过cargo创建一个新项目： 1cargo new rtoyos 项目结构如下： 123├── Cargo.toml├── src│ ├── main.rs 但是Rust项目默认都会链接到std标准库，而标准库会用到很多操作系统的功能，诸如线程，文件，网络等。所以我们要做的第一步就是实现一个不依赖于任何操作系统功能的Rust程序（裸机程序）。 禁用标准库我们可以通过![no_std]来禁用std库。 12345#![no_std]fn main() &#123; println!(&quot;Hello, world!&quot;);&#125; 运行cargo build，可以看到如下错误： 1234567891011error: cannot find macro `println` in this scope --&gt; src/main.rs:4:5 |4 | println!(&quot;Hello, world!&quot;); | ^^^^^^^error: `#[panic_handler]` function required, but not founderror: language item required, but not found: `eh_personality`error: aborting due to 3 previous errors println! 宏println!宏依赖于std库，这里我们就先不使用它了。 panic 处理函数第二个错误说需要一个#[panic_handler]函数，这个函数会在程序panic的时候被调用。默认情况下，std中有panic的实现，然而由于我们是在[no_std]环境中，只能自己实现一个panic函数了。 123456use core::panic::PanicInfo;#[panic_handler]fn panic(_info: &amp;PanicInfo) -&gt; ! &#123; loop &#123;&#125;&#125; 这里我们用了core库，这个库不需要操作系统支持。PanicInfo类型的参数会包含panic发生的文件，代码行数等错误信息。另外!标记表示这个函数的返回类型为never type，即永远不会返回。 eh_personality 语义项语义项是编译器内部所需的特殊函数或类型，例如Copy trait（#[lang = &quot;copy&quot;]），又或是之前的panic_handler。eh_personality是用来标记函数实现堆栈展开的语义项，该语义与panic有关。 堆栈展开 (Stack Unwinding) 通常当程序出现了异常时，从异常点开始会沿着 caller 调用栈一层一层回溯，直到找到某个函数能够捕获这个异常或终止程序。这个过程称为堆栈展开。 当程序出现异常时，我们需要沿着调用栈一层层回溯上去回收每个 caller 中定义的局部变量（这里的回收包括 C++ 的 RAII 的析构以及 Rust 的 drop 等）避免造成捕获异常并恢复后的内存溢出。 而在 Rust 中，panic 证明程序出现了错误，我们则会对于每个 caller 函数调用依次这个被标记为堆栈展开处理函数的函数进行清理。 这个处理函数是一个依赖于操作系统的复杂过程，在标准库中实现。但是我们禁用了标准库使得编译器找不到该过程的实现函数了。 为了简单起见，我们将堆栈展开禁用，在panic发生时直接abort而不是依次获取堆栈信息。 在Cargo.toml中进行配置： 12345[profile.dev]panic = &quot;abort&quot;[profile.release]panic = &quot;abort&quot; 现在,错误信息变成了： 1error: requires `start` lang_item 移除C运行时依赖大部分语言都有一个运行时（Runtime），这个运行时会在main函数之前被调用。以Rust为例，一个典型的链接了标准库的Rust程序会先跳转到C语言运行时环境crt0（C runtime zero），crt0会接着跳转到Rust运行时的入口点，这个入口点是被start语义所标记的。最后，Rust的运行时会调用main函数。 由于我们的程序无法访问标准库也就无法访问crt0和Rust运行时，所以我们需要定义我们自己的入口点。这里即使覆写start语义也是没用的，因为它仍然需要crt0的支持，所以我们要做的是直接覆写整个ctr0入口点。 123456789101112131415#![no_std]#![no_main]use core::panic::PanicInfo;#[panic_handler]fn panic(_info: &amp;PanicInfo) -&gt; ! &#123; loop &#123;&#125;&#125;#[no_mangle]pub extern &quot;C&quot; fn _start() -&gt; ! &#123; loop &#123;&#125;&#125; 我们使用#![no_main]属性来告诉编译器我们不使用常规入口点，并使用_start函数作为新的入口点（_start是大部分系统的默认入口点）。这里我们使用#[no_mangle]标记来禁用编译时的重命名，保证编译器生成的函数名仍然为_start，并使用extern &quot;C&quot;表示这是一个C语言函数。 此时我们再编译，发现错误变成了链接错误。 解决链接错误链接器（Linker）是一个程序，它将生成的目标文件组合为一个可执行文件。不同的操作系统如 Windows、macOS 或 Linux，规定了不同的可执行文件格式，因此也各有自己的链接器，抛出不同的错误；但这些错误的根本原因还是相同的：链接器的默认配置假定程序依赖于 C 语言的运行时环境，但我们的程序并不依赖于它。以x86-64-linux为例，错误如下： 12345error: linking with `cc` failed: exit code: 1 | = note: &quot;cc&quot; &quot;-Wl,--as-needed&quot; &quot;-Wl,-z,noexecstack&quot; &quot;-m64&quot; ... collect2: error: ld returned 1 exit status 我们只需要使用-C link-argflag（cargo rustc -- -C link-arg=-nostartfiles）或是干脆选择编译为裸机目标（例如：cargo build --target thumbv7em-none-eabihf）即可。","categories":[{"name":"Rust","slug":"Rust","permalink":"http://readlnh.github.io/categories/Rust/"},{"name":"blog_os notes","slug":"Rust/blog-os-notes","permalink":"http://readlnh.github.io/categories/Rust/blog-os-notes/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"http://readlnh.github.io/tags/Rust/"},{"name":"os","slug":"os","permalink":"http://readlnh.github.io/tags/os/"}]},{"title":"Modules","slug":"Rust/Rust-by-example-notes/Modules","date":"2020-06-20T17:32:00.000Z","updated":"2022-10-27T19:58:23.769Z","comments":true,"path":"2020/06/20/Rust/Rust-by-example-notes/Modules/","link":"","permalink":"http://readlnh.github.io/2020/06/20/Rust/Rust-by-example-notes/Modules/","excerpt":"","text":"A module is a colletction of items: functions structs traits impl blocks other modules featuresSplit code in logical units(modules), manage visibility(public&#x2F;private) between them. VisibilityBy default, the items in a module have private visibility, but this can be overridden with pub. Only the public items of a module can be accessed from outside the module scope. 123456789101112131415161718192021222324mod my_mod &#123; // Items in modules default to private visibility. fn private_function() &#123; println!(&quot;called `my_mod::private_function()`&quot;); &#125; // Use the `pub` modifier to override default visibility. pub fn function() &#123; println!(&quot;called `my_mod::function()`&quot;); &#125; // Items can access other items in the same module, // even when private. pub fn indirect_access() &#123; print!(&quot;called `my_mod::indirect_access()`, that\\n&gt; &quot;); private_function(); &#125; pub mod nested &#123; pub fn function() &#123; println!(&quot;called `my_mod::nested::function()`&quot;); &#125; &#125;&#125; Public items, including those inside nested modules, can be accessed from outside the parent module. 12345fn main() &#123; my_mod::function(); my_mod::indirect_access(); my_mod::nested::function();&#125; pub(crate)Functions declared using pub(crate) syntax are only visible within the current crate. 12345678910mod my_mod &#123; pub(crate) fn public_function_in_crate() &#123; ... &#125;&#125;fn main() &#123; ... my_mod::public_function_in_crate();&#125; pub(crate) can be called from anywhere in the same module. pub(in path)Functions declared by pub(in path) syntax are only visible within the given path. path must be a parent or ancestor module. 123456789mod my_mod &#123; ... pub mod nested &#123; ... pub(in crate::my_mod) fn public_function_in_my_mod() &#123; print!(&quot;called `my_mod::nested::public_function_in_my_mod()`, that\\n&gt; &quot;); &#125; &#125;&#125; pub(crate) items can only be called from within the module specified. 12345fn main() &#123; ... // Error `public_function_in_my_mod()` is private. // my_mod::nested::public_function_in_my_mod();&#125; pub(self)Functions declared by pub(self) syntax are only visible within the current module, which is same as leaving them private. pub(super)Functions declared using pub(super) syntax are only visible within the parent module. private moduleNested modules follow the same rules for visibility. 1234567891011121314151617my_mod &#123; ... // Nested modules follow the same rules for visibility mod private_nested &#123; #[allow(dead_code)] pub fn function() &#123; println!(&quot;called `my_mod::private_nested::function()`&quot;); &#125; // Private parent items will still restrict the visibility of a child item, // even if it is declared as visible within a bigger scope. #[allow(dead_code)] pub(crate) fn restricted_function() &#123; println!(&quot;called `my_mod::private_nested::restricted_function()`&quot;); &#125; &#125;&#125; struct visibilityStructs have an extra level of visibility with their fields. The visibility defaults to private, and can be overridden with pub modifier. use and asThe use declaration can be used to bind a full path to a new name, and the as keywords can bind imports to a different name. 1234567use xxx::yyy::function1;use xxx::yyy::function2 as f2;fn main() &#123; function1(); f2();&#125; super and selfThe super keyword refers to the parent scope, the self keyword refers to the current module scope - in the following case mod1. Note we can use self to access another module inside mod1(in this case mod2). 123456789101112131415161718192021222324252627282930fn f() &#123; println!(&quot;called `f()`&quot;);&#125;mod mod1 &#123; pub fn test_super() &#123; super::f(); &#125; fn test_self() &#123; println!(&quot;called `test_self()`&quot;); &#125; mod mod2 &#123; pub fn function_in_mod2() &#123; println!(&quot;called `function_in_mod2()`&quot;); &#125; &#125; pub fn test_all() &#123; test_super(); test_self(); self::test_self(); self::mod2::function_in_mod2(); &#125;&#125;fn main() &#123; mod1::test_all();&#125; File heirarchyModules can be mapped to a file&#x2F;directory. For example: 12345.├── main.rs└── my_mod ├── mod.rs └── nested_mod.rs main.rs: 1234567mod my_mod;fn main() &#123; my_mod::function(); my_mod::nested_mod::function(); println!(&quot;Hello, world!&quot;);&#125; Note the mod my_mod, this declaration will look for a file named my_mod.rs or my_mod/mod.rs and will insert its contents inside a module named my_mod under this scope. mod.rs: 12345pub mod nested_mod;pub fn function() &#123; println!(&quot;called `my_mod::function()`&quot;);&#125; Same as before. pub mod nested_mod; will locate the nested_mod.rs and insert it here under their respective modules. Note it follows the same rules for visibility. For instance, if we remove pub from pub mod nested_mod, we couldn’t call my_mod::nested_mod::function(); in main.rs.","categories":[{"name":"Rust","slug":"Rust","permalink":"http://readlnh.github.io/categories/Rust/"},{"name":"Rust-by-example-notes","slug":"Rust/Rust-by-example-notes","permalink":"http://readlnh.github.io/categories/Rust/Rust-by-example-notes/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"http://readlnh.github.io/tags/Rust/"},{"name":"Modules","slug":"Modules","permalink":"http://readlnh.github.io/tags/Modules/"}]},{"title":"Bonding in darwinia and substrate","slug":"Rust/substrate/bond_in_darwinia_and_substrate","date":"2020-01-03T16:25:00.000Z","updated":"2022-10-27T19:58:23.769Z","comments":true,"path":"2020/01/03/Rust/substrate/bond_in_darwinia_and_substrate/","link":"","permalink":"http://readlnh.github.io/2020/01/03/Rust/substrate/bond_in_darwinia_and_substrate/","excerpt":"","text":"What does the bond mean? Somehow it can be translated as building up a strong binding relationship with a PoS network. If you want to put your tokens “at stake”, you must bond them first. But what does the bond actually do? What’s the difference between substrate and darwinia-network? Account abstractions for bond – Stash and Controller Stash Key: The Stash account is meant to hold large amounts of funds. Its private key should be as secure as possible in a cold wallet. Controller Key: The Controller account signals choices on behalf of the Stash account, like payout preferences, but should only hold a minimal amount of funds to pay transaction fees. Its private key should be secure as it can affect validator settings, but will be used somewhat regularly for validator maintenance. Bond in SubstrateLet’s have a look at the following codes: 1234567891011121314151617181920212223242526272829303132fn bond(origin, controller: &lt;T::Lookup as StaticLookup&gt;::Source, #[compact] value: BalanceOf&lt;T&gt;, payee: RewardDestination ) &#123; let stash = ensure_signed(origin)?; if &lt;Bonded&lt;T&gt;&gt;::exists(&amp;stash) &#123; return Err(&quot;stash already bonded&quot;) &#125; let controller = T::Lookup::lookup(controller)?; if &lt;Ledger&lt;T&gt;&gt;::exists(&amp;controller) &#123; return Err(&quot;controller already paired&quot;) &#125; // reject a bond which is considered to be _dust_. if value &lt; T::Currency::minimum_balance() &#123; return Err(&quot;can not bond with value less than minimum balance&quot;) &#125; // You&#x27;re auto-bonded forever, here. We might improve this by only bonding when // you actually validate/nominate and remove once you unbond __everything__. &lt;Bonded&lt;T&gt;&gt;::insert(&amp;stash, &amp;controller); &lt;Payee&lt;T&gt;&gt;::insert(&amp;stash, payee); let stash_balance = T::Currency::free_balance(&amp;stash); let value = value.min(stash_balance); let item = StakingLedger &#123; stash, total: value, active: value, unlocking: vec![] &#125;; Self::update_ledger(&amp;controller, &amp;item); &#125; It’s really simple. Take the origin account as a stash and lock up value of its balance. controller will be the account that controls it. value must be more than the minimum_balance specified by T::Currency. The dispatch origin for this call must be Signed by the stash account. As we all know, “Verify First, Write Last” should be obeyed on Substrate, so verify wheather stash has been bonded and wheather controller has been paired already First. Make sure the value is bigger than the minimum_balance or the account would be a dust account that should be cleaned. Then bond the stash and the controller. 1&lt;Bonded&lt;T&gt;&gt;::insert(&amp;stash, &amp;controller); Set the Reward Destination: 1&lt;Payee&lt;T&gt;&gt;::insert(&amp;stash, payee); Fianlly update the ledger. 1234let stash_balance = T::Currency::free_balance(&amp;stash);let value = value.min(stash_balance);let item = StakingLedger &#123; stash, total: value, active: value, unlocking: vec![] &#125;;Self::update_ledger(&amp;controller, &amp;item); Note if value is larger than stash_balance, the bond should not faill and will bond all the balances in the stash account to the controller. bond doesn’t mean transfer tokens to the controller account. The tokens are still at the stash account. Howerever, the Staking Ledger’s active item will become the minium between the value and the stash_balance. Bond in DarwiniaThe bond operation in darwinia-network is almost the same as the bond operation in substrate. However, there are also something different between them. As darwinia has two tokens – ring and kton, the bond operation should be able to handle both tokens. 12345678910111213141516171819202122232425262728match value &#123; StakingBalances::RingBalance(r) =&gt; &#123; let stash_balance = T::Ring::free_balance(&amp;stash); let value = r.min(stash_balance); Self::bond_helper_in_ring(&amp;stash, &amp;controller, value, promise_month, ledger); &lt;RingPool&lt;T&gt;&gt;::mutate(|r| *r += value); &lt;Module&lt;T&gt;&gt;::deposit_event(RawEvent::Bond( StakingBalances::RingBalance(value.saturated_into()), now, promise_month, )); &#125;, StakingBalances::KtonBalance(k) =&gt; &#123; let stash_balance = T::Kton::free_balance(&amp;stash); let value = k.min(stash_balance); Self::bond_helper_in_kton(&amp;controller, value, ledger); &lt;KtonPool&lt;T&gt;&gt;::mutate(|k| *k += value); &lt;Module&lt;T&gt;&gt;::deposit_event(RawEvent::Bond( StakingBalances::KtonBalance(value.saturated_into()), now, promise_month, )); &#125;,&#125; There are also a special rule in darwinia-network: Users can choose to lock RING for 3-36 months in the process of Staking, and the system will offer a KTON token as reward for users participating in Staking. So we need bond_helper_in_ring and bond_helper_in_kton. 12345678910111213141516171819202122232425262728fn bond_helper_in_ring( stash: &amp;T::AccountId, controller: &amp;T::AccountId, value: RingBalance&lt;T&gt;, promise_month: Moment, mut ledger: StakingLedger&lt;T::AccountId, RingBalance&lt;T&gt;, KtonBalance&lt;T&gt;, T::Moment&gt;, ) &#123; // if stash promise to a extra-lock // there will be extra reward, kton, which // can also be use to stake. if promise_month &gt;= 3 &#123; ledger.active_deposit_ring += value; // for now, kton_return is free // mint kton let kton_return = inflation::compute_kton_return::&lt;T&gt;(value, promise_month); let kton_positive_imbalance = T::Kton::deposit_creating(&amp;stash, kton_return); T::KtonReward::on_unbalanced(kton_positive_imbalance); let now = &lt;timestamp::Module&lt;T&gt;&gt;::now(); ledger.deposit_items.push(TimeDepositItem &#123; value, start_time: now, expire_time: now + T::Moment::saturated_from((promise_month * MONTH_IN_MILLISECONDS).into()), &#125;); &#125; ledger.active_ring = ledger.active_ring.saturating_add(value); Self::update_ledger(&amp;controller, &amp;mut ledger, StakingBalances::RingBalance(value)); &#125; As the code shows, bond_helper_in_ring computes the kton should return and update the ledger. bond_helper_in_kton is simper, it just updates the ledger. 123456789fn bond_helper_in_kton( controller: &amp;T::AccountId, value: KtonBalance&lt;T&gt;, mut ledger: StakingLedger&lt;T::AccountId, RingBalance&lt;T&gt;, KtonBalance&lt;T&gt;, T::Moment&gt;, ) &#123; ledger.active_kton += value; Self::update_ledger(&amp;controller, &amp;mut ledger, StakingBalances::KtonBalance(value)); &#125;","categories":[{"name":"Rust","slug":"Rust","permalink":"http://readlnh.github.io/categories/Rust/"},{"name":"substrate","slug":"Rust/substrate","permalink":"http://readlnh.github.io/categories/Rust/substrate/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"http://readlnh.github.io/tags/Rust/"},{"name":"Substrate","slug":"Substrate","permalink":"http://readlnh.github.io/tags/Substrate/"},{"name":"blcokchain","slug":"blcokchain","permalink":"http://readlnh.github.io/tags/blcokchain/"}]},{"title":"Darwinia Eth-Backing","slug":"Rust/substrate/darwinia_eth_backing_notes","date":"2019-12-20T17:37:00.000Z","updated":"2022-10-27T19:58:23.769Z","comments":true,"path":"2019/12/20/Rust/substrate/darwinia_eth_backing_notes/","link":"","permalink":"http://readlnh.github.io/2019/12/20/Rust/substrate/darwinia_eth_backing_notes/","excerpt":"","text":"这几天在写Darwinia的eth-backing模块的测试，遇到不少问题，写个记录。 概述eth-backing模块的主要负责以太坊的跨链功能，darwinia跨链的思路大致如下：我在以太坊上建立相应的智能合约，以太坊上的token和darwinia上的token应该是可以1:1兑换的。一笔钱当然不能花两次，所以以太坊上的钱转移到darwinia上时，以太坊上的token就应该被销毁。所以总体逻辑应该是: 以太坊上销毁这笔token 将销毁的证据proof发给darwinia darwinia解析proof并在darwinia网络上生成token 这个过程在darwinia上被称为redeem。 redeem实际上，在darwinia上有两种原生资产： ring kton 所以理论上redeem应该有这两种对象。但是由于darwinia中锁定ring可以得到kton，所以ring有两种状态，一种是锁定中的，一种是普通的。如此一来redeem的对象又多了一个，对于锁定中的ring，我们可以认为它是被存在银行里，所以有一个存单deposit。故，redeem的对象如下： ring kton deposit storage链上存储的数据大致可以分为三类： Redeem地址，即proof提交的地址，测试时需要预设 RingRedeemAddress get(ring_redeem_address) config(): EthAddress; KtonRedeemAddress get(kton_redeem_address) config(): EthAddress; DepositRedeemAddress get(deposit_redeem_address) config(): EthAddress; 链上初始抵押的ring和kton，每次redemm后就减掉 RingLocked get(fn ring_locked) config(): RingBalanceOf; KtonLocked get(fn kton_locked) config(): KtonBalanceOf; ProofVerifed，用来存储已经redeem的proof，保证一个proof不会redeem两次 RingProofVerified get(ring_proof_verfied): map (H256, u64) &#x3D;&gt; Option; KtonProofVerified get(kton_proof_verfied): map (H256, u64) &#x3D;&gt; Option; DepositProofVerified 实现前两者的实现其实非常简单，就是检查proof，解析proof，token转账，保存proof信息等等。比较特殊的是deposit的redeem。因为deposit里面的ring是locked的ring，所以需要先将ring转入账户中然后再锁定起来，但是要注意的是这时候锁定是没有kton的，因为在之前就已经奖励过了。这里似乎用到了support回调？不知道具体为何可以这么做。 测试测试部分由于不熟悉substrate的测试，所以浪费了很多时间。 mock首先是mock，主要就是引入模块，以及初始化，初始化构造如下 1234567891011121314151617impl ExtBuilder &#123; pub fn build(self) -&gt; runtime_io::TestExternalities &#123; let mut t = system::GenesisConfig::default().build_storage::&lt;Test&gt;().unwrap(); let _ = GenesisConfig::&lt;Test&gt; &#123; ring_redeem_address: hex![&quot;dbc888d701167cbfb86486c516aafbefc3a4de6e&quot;].into(), kton_redeem_address: hex![&quot;dbc888d701167cbfb86486c516aafbefc3a4de6e&quot;].into(), deposit_redeem_address: hex![&quot;6ef538314829efa8386fc43386cb13b4e0a67d1e&quot;].into(), ring_locked: 20000000000000, kton_locked: 5000000000000, &#125; .assimilate_storage(&amp;mut t) .unwrap(); t.into() &#125;&#125; tests测试主要就是对比信息，这里没有太多的难点，主要就是需要调用一些辅助的api来帮助找出原始数据。另外就是关于调用其他模块的private函数的问题。 Some apis(tools) for darwinia_eth_backing development ropsten https://ropsten.etherscan.io/tx/0x59c6758bd2b93b2f060e471df8d6f4d901c453d2c2c012ba28088acfb94f821 api for proof https://alpha.evolution.land/api/darwinia/receipt?tx=0x59c6758bd2b93b2f060e471df8d6f4d901c453d2c2c012ba28088acfb94f8216 tx &#x3D; Transaction Hash Just change Transaction Hash index proof header_hash api for all informationhttp://api-ropsten.etherscan.io/api?module=proxy&amp;action=eth_getBlockByNumber&amp;tag=0x6a910b&amp;boolean=true&amp;apikey=YourApiKeyToken Just replace the blocknumber(hex) Calling Private Dispatchable Functions具体可参见Extending Substrate Runtime Modules 12345678assert_ok!( staking::Call::&lt;Test&gt;::bond( controller.clone(), StakingBalances::Ring(1), RewardDestination::Controller, 0).dispatch(Origin::signed(expect_account_id.clone()) )); 这里需要调用bond函数，因为只有参与staking的token才可以lock，而参与staking需要controller。","categories":[{"name":"Rust","slug":"Rust","permalink":"http://readlnh.github.io/categories/Rust/"},{"name":"substrate","slug":"Rust/substrate","permalink":"http://readlnh.github.io/categories/Rust/substrate/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"http://readlnh.github.io/tags/Rust/"},{"name":"Substrate","slug":"Substrate","permalink":"http://readlnh.github.io/tags/Substrate/"},{"name":"blcokchain","slug":"blcokchain","permalink":"http://readlnh.github.io/tags/blcokchain/"},{"name":"darwinia","slug":"darwinia","permalink":"http://readlnh.github.io/tags/darwinia/"}]},{"title":"Closure","slug":"Rust/Rust-by-example-notes/Closure","date":"2019-11-27T17:44:00.000Z","updated":"2022-10-27T19:58:23.769Z","comments":true,"path":"2019/11/27/Rust/Rust-by-example-notes/Closure/","link":"","permalink":"http://readlnh.github.io/2019/11/27/Rust/Rust-by-example-notes/Closure/","excerpt":"","text":"About closureClosure in Rust, also called lamba expressions or lambdas, are functions that can capture the enclosing environment. Some characterisitics of closures include: using || instead of () around input variables. optional body delimination &#123;&#125; for a single expression (mandatory otherwise). the ability to capture the outer environment variables example 123456789101112fn main() &#123; let closure_annotated = |i: i32| -&gt; i32 &#123; i + 1 &#125;; let closure_inferred = |i| i + 1; println!(&quot;&#123;&#125;&quot;, closure_annotated(1)); println!(&quot;&#123;&#125;&quot;, closure_inferred(2)); let x = || &#123; println!(&quot;Hi xxxx&quot;); &#125;; x();&#125; CapturingCapturing can flexibly adapt to the use case, sometimes moving and sometimes borrowing. Closures can capture variables: by reference: &amp;T by mutable reference: &amp;mut T by value: T Closures preferentially capture variables by reference and only go lower when required. example 12345678910111213141516171819202122232425262728fn main() &#123; use std::mem; // &amp;T let color = &quot;red&quot;; let print = || println!(&quot;color is &#123;&#125;&quot;, color); print(); print(); // &amp;mut T let mut count = 0; let mut inc = || &#123; count += 1; println!(&quot;count is &#123;&#125;&quot;, count); &#125;; inc(); inc(); println!(&quot;count: &#123;&#125;&quot;, count); // A non-copy type let movable = Box::new(3); let consume = || &#123; println!(&quot;movable: &#123;:?&#125;&quot;, movable); mem::drop(movable); &#125;; consume(); //consume();&#125; Howerver, if we do this: 123456789101112fn main() &#123; use std::mem; // A non-copy type let movable = Box::new(3); let consume = || &#123; println!(&quot;movable: &#123;:?&#125;&quot;, movable); mem::drop(movable); &#125;; consume(); consume();&#125; We would get: 1234567891011121314151617181920error[E0382]: use of moved value: `consume` --&gt; src/main.rs:11:5 |10 | consume(); | ------- value moved here11 | consume(); | ^^^^^^^ value used here after move |note: closure cannot be invoked more than once because it moves the variable `movable` out of its environment --&gt; src/main.rs:8:19 |8 | mem::drop(movable); | ^^^^^^^error: aborting due to previous errorFor more information about this error, try `rustc --explain E0382`.error: Could not compile `capturing_test`.To learn more, run the command again with --verbose. mem::drop requires T so this mut take by value. A copy type would copy into the closure leaving the original untouched. A non-copy mut move and so movable immediately moves into the closure. moveUsing move before vertical pipes forces closures to take ownership of captured variables: example 123456789fn main() &#123; let vec = vec![1, 2, 3]; let contains = move |needle| vec.contains(needle); println!(&quot;&#123;&#125;&quot;, contains(&amp;1)); println!(&quot;&#123;&#125;&quot;, contains(&amp;2));&#125; output 12truetrue If we call vec.len() later: 12345678910fn main() &#123; let vec = vec![1, 2, 3]; let contains = move |needle| vec.contains(needle); println!(&quot;&#123;&#125;&quot;, contains(&amp;1)); println!(&quot;&#123;&#125;&quot;, contains(&amp;2)); println!(&quot;&#123;&#125;&quot;, vec.len());&#125; We would get: 123456789101112131415161718error[E0382]: borrow of moved value: `vec` --&gt; src/main.rs:9:20 |2 | let vec = vec![1, 2, 3]; | --- move occurs because `vec` has type `std::vec::Vec&lt;i32&gt;`, which does not implement the `Copy` trait3 | 4 | let contains = move |needle| vec.contains(needle); | ------------- --- variable moved due to use in closure | | | value moved into closure here...9 | println!(&quot;&#123;&#125;&quot;, vec.len()); | ^^^ value borrowed here after moveerror: aborting due to previous errorFor more information about this error, try `rustc --explain E0382`.error: Could not compile `movable_closure_test`. It’s no doubt that vec has been moved into the closure. As input parametersWhile Rust choose how to capture variables on the fly mostly without type annotaions, this ambiguity is not allowed when writing functions. When taking a closure as an input parameter, the closure’s complete type must be annotated using one of a few traits. In order of decreasing restriction, they are: Fn: the closure captures by reference(&amp;T) FnMut: the closure captures by mutable reference(&amp;mut T) FnOnce: the closure captures by value(T) For instance, consider a parameter annotated as FnOnce. This specifies that the closure may caputure by &amp;T, &amp;mutT, or T, but ultimately choose based on how the captured variables are used in the closure. This is because if a move is possible, then any type of borrow should also be possible. Note that reverse is not true. If the paramenter is annotated as Fn, then capturing varibales by &amp;mut T or T are not allowed. example 12345678910111213141516171819202122232425262728293031323334353637fn apply&lt;F&gt;(f: F) where F: FnOnce() &#123; f();&#125;fn apply_to_3&lt;F&gt;(f: F) -&gt; i32 where F: Fn(i32) -&gt; i32 &#123; f(3)&#125;fn main() &#123; use std::mem; let greeting = &quot;hello&quot;; let mut farewell = &quot;goodbye&quot;.to_owned(); let dairy = || &#123; // greeting is by reference: requries Fn println!(&quot;I said &#123;&#125;&quot;, greeting); // Mutation forces `farewell` to be captured by mutable reference // Now require FnMut farewell.push_str(&quot;!!!&quot;); println!(&quot;Then I screamed &#123;&#125;&quot;, farewell); // Now require FnOnce mem::drop(farewell); &#125;; apply(dairy); let double = |x| x * 2; println!(&quot;&#123;&#125;&quot;, apply_to_3(double)); &#125; Type anonymityUsing a closure as a parameter requires generics.This is necessary because of how thet are defined: 12345// `F` must be generic.fn apply&lt;F&gt;(f: F) where F: FnOnce() &#123; f();&#125; When a closure is defined, the compiler implicitly creates a new anonymous structure to store the captured variables inside, meanwhile implementing the functionality via one of the traits: Fn, FnMut or FnOnce for this unknown type. This type is assigned to the variable which is stored until calling. Since this new type if of unknown type, any usage in a function will require generics. However, an unbounded type parameter would still be ambigious and not be allowed. Thus, bounding by one of the traits: Fn, FnMut or FnOnce(which it implements) is sufficient to specify its type. Input functionsIf you declare a function that takes a closure as a parameter, then any function that satisfies the trait bound of that closure can be passed as parameter. example 12345678910111213141516fn call_me&lt;F&gt;(f: F) where F: Fn()&#123; f();&#125;fn function() &#123; println!(&quot;Hi, I&#x27;m a function.&quot;);&#125;fn main() &#123; let closure = | | println!(&quot;Hi, I&#x27;m a closure.&quot;); call_me(closure); call_me(function);&#125; function could also be used as a parameter as the same as closure. As output parametersReturning closures as output parameters are also possible. However, anoymous closure types are, by definition, unknown, so we have to use impl Trait to return them. example 12345678910111213141516fn create_fn() -&gt; impl Fn() &#123; let text = &quot;Fn&quot;.to_owned(); move || println!(&quot;&#123;&#125;&quot;, text)&#125;fn create_fnmut() -&gt; impl FnMut() &#123; let text = &quot;FnMut&quot;.to_owned(); move || println!(&quot;&#123;&#125;&quot;, text)&#125;fn main() &#123; let fn_plain = create_fn(); let mut fn_mut = create_fnmut(); fn_plain(); fn_mut();&#125; Note: impl xxTrait means a type that implements xxTrait.","categories":[{"name":"Rust","slug":"Rust","permalink":"http://readlnh.github.io/categories/Rust/"},{"name":"Rust-by-example-notes","slug":"Rust/Rust-by-example-notes","permalink":"http://readlnh.github.io/categories/Rust/Rust-by-example-notes/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"http://readlnh.github.io/tags/Rust/"},{"name":"closure","slug":"closure","permalink":"http://readlnh.github.io/tags/closure/"}]},{"title":"How to setup environment for loongson LS1C0300B(mipsel) on Ubuntu18.04","slug":"Linux/loongson/loongson_on_ubuntu","date":"2019-11-27T14:48:00.000Z","updated":"2022-10-27T19:58:23.769Z","comments":true,"path":"2019/11/27/Linux/loongson/loongson_on_ubuntu/","link":"","permalink":"http://readlnh.github.io/2019/11/27/Linux/loongson/loongson_on_ubuntu/","excerpt":"","text":"This article is about setting up an environment for enbedded Linux application development for loongson. The resulting environment enables cross-platform application development for Loongson mipsel-based SOMs&#x2F;COMs using Ubuntu18.04 for application development. Communicate with loongson development board using USB cableThe first thing we need to do is communicating with hardware using USB cable.The boards are equipped with PL2303-based device. To be able to talk to an application, our machine must have appropriate PL2303 drivers. Fortunately, Ubuntu18.04 is default equipped with the PL2030 drivers(we could use lsmod | grep pl2303 to check it). The only thing necessary is to check whether the Ubuntu machine can communicate over USB with the attached loongson development board. To do this: Connect the PC via an USB cable to the USB UART port of the loongson development board. Turn the board on. Note the correspondence between the colored cable and thier pinout: Black wire(GND) Green wire(RX) White wire(TX) Use lsusb command to list the usb devices connected to our machine. The output text of this command in terminal is something like this: 12345678Bus 001 Device 007: ID 0bda:0129 Realtek Semiconductor Corp. RTS5129 Card Reader ControllerBus 001 Device 008: ID 0cf3:0036 Atheros Communications, Inc. Bus 001 Device 005: ID 0c45:6a04 Microdia Bus 001 Device 004: ID 17ef:6050 Lenovo Bus 001 Device 010: ID 046d:c326 Logitech, Inc. Bus 001 Device 011: ID 067b:2303 Prolific Technology, Inc. PL2303 Serial PortBus 001 Device 002: ID 8087:8000 Intel Corp. Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub This shows that the PL2303 devices on the development board has been detected and that the drivers on the PC are running. To find out what RS232(UART) port is used by the USB driver, type: 1dmesg | grep -ie PL2303 The return message: 1234[ 8907.910272] usbcore: registered new interface driver pl2303[ 8907.910924] usbserial: USB Serial support registered for pl2303[ 8907.911054] pl2303 1-1.1:1.0: pl2303 converter detected[ 8907.913355] usb 1-1.1: pl2303 converter now attached to ttyUSB0 The message tells us where the driver connects to a TTY port, in this case, usb 1-1.1: pl2303 converter now attached to ttyUSB0. picocomPicocom is a minimal dumb-terminal emulation program that is great for accessing a serial port based Linux console; which is typical done when developing an embedded Linux based product. Install picocom with this command: 1sudo apt-get install picocom Now, we know the serial port, set the speed to 115200 baud. 1sudo picocom -b 115200 /dev/ttyUSB0 Now, we can communicate with the board. 123456789101112131415161718192021222324picocom v2.2port is : /dev/ttyUSB0flowcontrol : nonebaudrate is : 115200parity is : nonedatabits are : 8stopbits are : 1escape is : C-alocal echo is : nonoinit is : nonoreset is : nonolock is : nosend_cmd is : sz -vvreceive_cmd is : rz -vv -Eimap is : omap is : emap is : crcrlf,delbs,Type [C-a] [C-h] to see available commandsTerminal ready[root@Loongson:/]# Cross CompileNow we should install the cross tool chain. I download the mips-loongson-gcc4.9-2019.08-05.linux-gnu.tar.gz from the loongson website. Unpack the tar.xz file and move it to the /opt. Export the environment variables by adding the following lines into the ~/.bashrc: 12export PATH=&quot;/opt/gcc-4.3-ls232/bin:$PATH&quot;export PATH=&quot;home/readlnh/Application/mipsel-linux-musl-cross/bin:$PATH&quot; Don’t forget to run command source ~/.bashrc. Now, we could compile a.c: 1$ mipsel-linux-gnu-gcc a.c tftp serverOn ubuntu, run sudo apt-get install tftpd-hpa tftp-hpa. Then edit the /etc/default/tftpd-hap: 12345# /etc/default/tftpd-hpa TFTP_USERNAME=&quot;tftp&quot; TFTP_DIRECTORY=&quot;/home/readlnh/tftpboot&quot; TFTP_ADDRESS=&quot;0.0.0.0:69&quot; TFTP_OPTIONS=&quot;-l -c -s&quot; Create file /etc/xinetd.d/tftp with the following contents: 123456789101112service tftp&#123; disable = no socket_type = dgram protocol = udp wait = yes user = root server = /usr/sbin/in.tftpd server_args = -s /home/readlnh/tftpboot -c per_source = 11 cps = 100 2&#125; Create directory /home/readlnh/tftpboot and set its permissions: 123$ sudo mkdir /home/readlnh/tftpboot$ sudo chmod -R 777 /home/readlnh/tftpboot$ sudo chown -R nobody /home/readlnh/tftpboot Restart the xinetd service: 1$ sudo service xinetd restart We could use ifconfig to get the ip address of our host machine. Make sure that ethernet cable is plugged into the board and a dhcp server is running in either your host machine or your router. In this case, my host machine’s ip address is 192.168.1.230. Run ifconfig to set the ip address of the board to make sure the address fall into the same subnet, here I set it 192.168.1.108. Now, we could ping our host machine by ping 192.168.1.230: 123456789PING 192.168.1.230 (192.168.1.230): 56 data bytes64 bytes from 192.168.1.230: seq=0 ttl=64 time=5.054 ms64 bytes from 192.168.1.230: seq=1 ttl=64 time=4.140 ms64 bytes from 192.168.1.230: seq=2 ttl=64 time=0.843 ms64 bytes from 192.168.1.230: seq=3 ttl=64 time=3.813 ms64 bytes from 192.168.1.230: seq=4 ttl=64 time=3.727 ms64 bytes from 192.168.1.230: seq=5 ttl=64 time=0.562 ms64 bytes from 192.168.1.230: seq=6 ttl=64 time=3.749 ms... Download the a.out we compiled before by tftp -r a.out -g 192.168.1.230: 1a.out 100% |*******************************| 7796 0:00:00 ETA Run the a.out: 123[root@Loongson:/]#chmod u+x a.out [root@Loongson:/]#./a.outHello World! HintsLoongson only provide gcc4.9 for LSC1C0300B, howerver, the mipsel-linux-gnu-gcc in Ubuntu apt source also works well. Reference Communicate with hardware using USB cable for Ubuntu TFTP Boot using u-boot","categories":[{"name":"Linux","slug":"Linux","permalink":"http://readlnh.github.io/categories/Linux/"},{"name":"loongson","slug":"Linux/loongson","permalink":"http://readlnh.github.io/categories/Linux/loongson/"}],"tags":[{"name":"loognson","slug":"loognson","permalink":"http://readlnh.github.io/tags/loognson/"},{"name":"mipsel","slug":"mipsel","permalink":"http://readlnh.github.io/tags/mipsel/"},{"name":"cross-compile","slug":"cross-compile","permalink":"http://readlnh.github.io/tags/cross-compile/"}]},{"title":"Substrate-workshop notes","slug":"Rust/substrate/substrate-workshop_notes","date":"2019-11-22T11:13:00.000Z","updated":"2022-10-27T19:58:23.769Z","comments":true,"path":"2019/11/22/Rust/substrate/substrate-workshop_notes/","link":"","permalink":"http://readlnh.github.io/2019/11/22/Rust/substrate/substrate-workshop_notes/","excerpt":"","text":"RuntimeThe Runtime is block execution logic of a blockchain, sometimes referred to as the state transition function STF. In Substrate, this is stored on-chain in an implementation-neutal(语言无关的), machine-executable(机器可执行的) format as a WebAssembly binary. Other system Ethereum(human-readable format) Bitcoin(not at all) The runtime is composed of multiple features and functionalities which work together to power your blockchain. Things like: Account Management Token Balances Governance Runtime Upgrades and more… Creating a ModuleFirst, we need to create a module for our runtime. For that we will work with an empty module template which we will place in a new substratekitties.rs file: 1234567891011substratekitties|+-- runtime | +-- src | +-- lib.rs | +-- * substratekitties.rs | +-- template.rs substratekitties.rs 1234567891011121314151617use support::&#123;decl_storage, decl_module&#125;;pub trait Trait: system::Trait&#123; &#125;decl_storage! &#123; trait Store for Module&lt;T: Trait&gt; as KittyStorage &#123; // Declare storge and getter functions here &#125;&#125;decl_module! &#123; pub struct Module&lt;T: Trait&gt; for enum Call where origin: T::Origin &#123; // Declare public functions here &#125;&#125; This template allows us to start writing the most basic parts of our module, the public functions and the storage. Note: The line trait Store for Module&lt;T: Trait&gt; as NAME is macro magic. That line as written is not valid Rust, but it gets converted to valid Rust code through the decl_storage! macro. Updating our RuntimeFor each module, we should: Import the Rust file containing the module Implement its trait Include the module into the construct_runtime! macro Firstly, import the substratekitties.rs.We should add this line into the lib.rs. 12345678910// lib.rs/// Index of a block number in the chain.pub type BlockNumber = u64;/// Index of an account&#x27;s extrinsic in the chain.pub type Nonce = u64;// Add this linemod substratekitties; Secondlly, implement the traits. Our Triat implementation is very simple, because we haven’t defined anything in it yet. 1234567891011// lib.rsimpl sudo::Trait for Runtime &#123; /// The uniquitous event type. type Event = Event; type Proposal = Call;&#125;// Add the implementation hereimpl substratekitties::Trait for Runtime &#123;&#125; Finally, add this line at the end of our construct_runtime! definition: 1234567891011121314151617181920// lib.rsconstruct_runtime!( pub enum Runtime with Log(InternalLog: DigestItem&lt;Hash, AuthorityId, AuthoritySignature&gt;) where Block = Block, NodeBlock = opaque::Block, UncheckedExtrinsic = UncheckedExtrinsic &#123; System: system::&#123;default, Log(ChangesTrieRoot)&#125;, Timestamp: timestamp::&#123;Module, Call, Storage, Config&lt;T&gt;, Inherent&#125;, Consensus: consensus::&#123;Module, Call, Storage, Config&lt;T&gt;, Log(AuthoritiesChange), Inherent&#125;, Aura: aura::&#123;Module&#125;, Indices: indices, Balances: balances, Sudo: sudo, // Add this line Substratekitties: substratekitties::&#123;Module, Call, Storage&#125;, &#125;); Note than we have added three types to this definition(Module, Call, Storage), all of which are produced by the macros defined in our template. Creating a Storage ValueLet’s add a function which stores a variable. Substrate natively supports all the primitive types avaliable in Rust(bool, u8, u32, etc..) and custom types sepcific to Substrate(AccountIdm BlockNumber, Hash, etc.. ) We can declare a simple storage item like this: 123456decl_storage! &#123; trait Store for Module&lt;T: Trait&gt; as Example &#123; MyU32: u32; MyBool get(my_bool_getter): bool; &#125;&#125; Here we have defined two variables: a u32 and a bool with a getter function named my_bool_getter. The get parameter is optional, but if you add it to your storage item it will expose a getter function with the name specified(fn getter_name() -&gt; Type). To store these basic values, we need to import the support::StorageValue module. The function used to access a StorageValue are defined in StorageValue. Now, create a storage value called Value which stores as u64. 123456decl_storage! &#123; trait Store for Module&lt;T: Trait&gt; as KittyStorage &#123; // Declare storage and getter functions here Value: u64; &#125;&#125; Storing a ValueNow that we have our storage value declared in our runtime, we can actually create a function to push a value to it. Declaring a public functionWe need to define runtime functions that will set and modify our storage values. This can be done within our decl_module! macro, which declares all the entry points that your module handles. 1234567891011121314151617// Add these imports: //use support::&#123;dispatch::Result, StorageValue&#125;;use system::ensure_signed;decl_module! &#123; pub struct Module&lt;T: Trait&gt; for enum Call where origin: T::Origin &#123; // Declare public functions here fn set_value(origin, value: u64) -&gt; Result &#123; let _sender = ensure_signed(origin)?; &lt;Value&lt;T&gt;&gt;::put(value); Ok(()) &#125; &#125;&#125; Function StructureModule functions exposed here should always take the form: 1fn foo(origin, bar: Bar, baz: Baz, ...) -&gt; Result; OriginThe first argument of these function is always origin. origin contains information about where the call originated from. This is generally split into three groups: Public calls that are signed by an external account. Root calls that are allowed to be made only by the governance system. Inherent calls that are allowed to be made only by the block authors and validators. Checking for a Signed MessageThe first argument in any of these module functions is the origin. There are three convenience call in system that do the matching for your and return a convenient result: ensure_signed, ensure_root and ensire_inherent. You should always match against them as the first thing you do in your function. We can use the ensure_signed() function from system::ensure_signed to check the origin, and “ensure” that the messaged is signed by a valid account. Storage MappingOur last runtime only allowed us to store a single value across all users of our blockchain. As we start thinking toward our collectables chain, it makes sense to add support to have their own value stored. To enable this, we will replace our single value storage with a storage mapping. The functions used to access a StorageMap are in StorageMap Now our storage example is updated to store a map from AccountId to a u64. 1234567891011121314// change `StorageValue` to `StorageMap`decl_module! &#123; pub struct Module&lt;T: Trait&gt; for enum Call where origin: T::Origin &#123; // Declare public functions here fn set_value(origin, value: u64) -&gt; Result &#123; let sender = ensure_signed(origin)?; &lt;Value&lt;T&gt;&gt;::insert(sender, value); Ok(()) &#125; &#125;&#125; Storing a StructureWe can define a struct for digital kitties and store them in our runtime storage like so: 12345678#[derive(Encode, Decode, Default, Clone, PartialEq)]#[cfg_attr(feature = &quot;std&quot;, derive(Debug))]pub struct Kitty&lt;Hash, Balance&gt; &#123; id: Hash, dna: Hash, price: Balance, gen: u64,&#125; Note: To use the custom Encode and Decode traits, you will need to import them from the parity_codec crate: 1use parity_codec::&#123;Encode, Decode&#125;; We define our example struct using a generic as one of the types that we store. This will be important when trying to use custom Substrate types like AccountId or Balance within our struct as we wil need to pass in these types every time we use our struct. So, if we wanted to store a Balance in some_generic and Hash in some_other_generic, we wiuld need to define our storage item like this: 12345decl_storage! &#123; trait Store for Module&lt;T: Trait&gt; as Example &#123; MyItem: map T::AccountId =&gt; MyStruct&lt;T::Balance, T::Hash&gt;; &#125;&#125; For the purpose of clarity, we will name a generic type for T::AccountId as AccountId and T::Balance as Balance. Read More For our example: 123456decl_storage! &#123; trait Store for Module&lt;T: Trait&gt; as KittyStorage &#123; // Declare storage and getter functions here OwnedKitty get(kitty_of_owner): map T::AccountId =&gt; Kitty&lt;T::Hash, T::Balance&gt;; &#125;&#125; We update the storage item to sotre a Kitty&lt;T::Hash, T::Balance&gt;, add a getter function named kitty_of_owner. Now, we have initialized our custom struct in our runtime storage, we can now push values and modify it. 1234567891011121314151617181920decl_module! &#123; pub struct Module&lt;T: Trait&gt; for enum Call where origin: T::Origin &#123; // Declare public functions here fn create_kitty(origin) -&gt; Result &#123; let sender = ensure_signed(origin)?; let new_kitty = Kitty &#123; id: &lt;T as system::Trait&gt;::Hashing::hash_of(&amp;0), dna: &lt;T as system::Trait&gt;::Hashing::hash_of(&amp;0), price: &lt;T::Balance as As&lt;u64&gt;&gt;::sa(0), gen: 0, &#125;; &lt;OwnedKitty&lt;T&gt;&gt;::insert(sender, new_kitty); Ok(()) &#125; &#125;&#125; Generating Random DataNow, we allowed each user to create their own kitty. However, they weren’t very unique. Let’s fix that. Generating a Random SeedIn order to tell these kitties apart, we need to generate a unique id for each kitty and some random dna. We can securely fetch some randomness from our chain using the system module: 1&lt;system::Module&lt;T&gt;&gt;::random_seed() Substrate uses a safe mixing algorithm that uses the entropy of previous blocks to generate new random data for each subsequent block. However, since it is dependent on previous blocks, it can take over 80 blocks to fully warm up, and you may notice the seed will not change until then. Using a NonceSince the random seed does not change for multiple transactions in the same block, and since it may not even generate a random seed for the first 80 blocks, it is important that we also introduce a nonce which our module can manage. Furthermore, we can also user a user specific property like the AccountId to introduce a bit more entropy. Hashing DataA random number generator: 12345let sender = ensure_signed(origin)?; let nonce = &lt;Nonce&lt;T&gt;&gt;::get(); let random_seed = &lt;system::Module&lt;T&gt;&gt;::random_seed(); let random_hash = (random_seed, &amp;sender, nonce).using_encoded(&lt;T as system::Trait&gt;::Hashing::hash); We can use this random_hash to populate both the id and dna for our kitty. using_encoded: Convert self to a slice and then invoke the given closure with it. Checking for CollisionThe id on the Kitty should be unique. We can do this with a new storage item Kitties which will be a mapping from id(Hash) to the Kitty object. 1Kitties: map T::Hash =&gt; Kitty&lt;T::Hash, T::Balance&gt;; For this object, we can easily check for collisions by simply checking whether this storage item already contains a mapping using a particular id. 1ensure!(!&lt;Kitties&lt;T&gt;&gt;::exists(random_hash), &quot;This id is already exists&quot;); Updating the codeSo we should update our storage module. First, we should add tewo new kitty storage item. Kitties point from our kitty’s id to the Kitty object KittyOwner point from our kitty’s id to the owner Then update the OwnedKitty storage below to store the kitty’s id rather than the Kitty object. Finally, add a u64 value named Nonce. 1234567891011decl_storage! &#123; trait Store for Module&lt;T: Trait&gt; as KittyStorage &#123; // Declare storage and getter functions here Kitties: map T::Hash =&gt; Kitty&lt;T::Hash, T::Balance&gt;; KittyOwner: map T::Hash =&gt; Option&lt;T::AccountId&gt;; OwnedKitty get(kitty_of_owner): map T::AccountId =&gt; T::Hash; Nonce: u64; &#125;&#125; The create_kitty should be updated too: 1234567891011121314151617181920212223242526272829303132decl_module! &#123; pub struct Module&lt;T: Trait&gt; for enum Call where origin: T::Origin &#123; // Declare public functions here fn create_kitty(origin) -&gt; Result &#123; let sender = ensure_signed(origin)?; let nonce = &lt;Nonce&lt;T&gt;&gt;::get(); let random_seed = &lt;system::Module&lt;T&gt;&gt;::random_seed(); let random_hash = (random_seed, &amp;sender, nonce).using_encoded(&lt;T as system::Trait&gt;::Hashing::hash); ensure!(!&lt;Kitties&lt;T&gt;&gt;::exists(random_hash), &quot;This id is already exists&quot;); &lt;Nonce&lt;T&gt;&gt;::mutate(|n| *n += 1); let new_kitty = Kitty &#123; id: random_hash, dna: random_hash, price: &lt;T::Balance as As&lt;u64&gt;&gt;::sa(0), gen: 0, &#125;; &lt;Kitties&lt;T&gt;&gt;::insert(random_hash, new_kitty); &lt;KittyOwner&lt;T&gt;&gt;::insert(random_hash, &amp;sender); &lt;OwnedKitty&lt;T&gt;&gt;::insert(&amp;sender, random_hash); Ok(()) &#125; &#125;&#125; Nonce will be a new item in our storage which we will simply increment whenever we use it. Creating an EventOn Substrate, even though a transaction may be finalized, it does not necessarily imply that the function executed by that transaction fully succeed. To know that, we should emit an Event at the end of the function to not only report success, but to tell the “off-chain world” that some particular state transition has happened. Declaring an Eventdecl_event! macro, example of an event declaration: 12345678910decl_event!( pub enum Event&lt;T&gt; where &lt;T as system::Trait&gt;::AccountId, &lt;T as system::Trait&gt;::Balance &#123; MyEvent(u32, Balance), MyOtherEvent(Balance, AccountId), &#125;); In our kitty-example: 123456789decl_event! &#123; pub enum Event&lt;T&gt; where &lt;T as system::Trait&gt;::AccountId, &lt;T as system::Trait&gt;::Hash, &#123; Created(AccountId, Hash), &#125;&#125; If we want to use some custom Substrate types, we need to integerate generics into our event definition. Adding an EventThe decl_event! macro will generate a new Event type which you will need to expose in your module. This type will need to inherit some traits like so: 123pub trait Trait: balances::Trait &#123; type Event: From&lt;Event&lt;Self&gt;&gt; + Into&lt;&lt;Self as system::Trait&gt;::Event&gt;;&#125; Depositing an EventIn order to use events within your runtime, you need to add a function which deposits those events. The decl_module! macro can automatically add a default implementation of this to your module. Add this to the decl_module: 1fn deposit_event&lt;T&gt;() = default; If you do not use any generics: 1fn deposit_event() = default; Calling deposit_event()Just provide the values that go along with our Event definition at the end of our function. 1234let my_value = 1337;let my_balance = &lt;T::Balance as As&lt;u64&gt;&gt;::sa(1337);Self::deposit_event(RawEvent::MyEvent(my_value, my_balance)); So to our projects: 1Self::deposit_event(RawEvent::Created(sender, random_hash)); Updating lib.rs to Include EventsIn the module Trait implementation: 12345// `lib.rs`impl mymodule::Trait for Runtime &#123; type Event = Event;&#125; Include the Event or Event&lt;T&gt; type to the module’s definition in the construct_runtime! macro. 12345678910construct_runtime!( pub enum Runtime with Log(InternalLog: DigestItem&lt;Hash, Ed25519AuthorityId&gt;) where Block = Block, NodeBlock = opaque::Block, InherentData = BasicInherentData &#123; ... MyModule: mymodule::&#123;Module, Call, Storage, Event&lt;T&gt;&#125;, &#125;); Why we need events?Followings are some of my understandings: Substrate runtime module does not support println! macros for us to check the output from Substrate. However, we can deposit events from our substrate code and see it in polkadot.js apps. In extrinsics menu, we make a extrinsic which we built from our runtime and see events in the explorer menu. Tracking All KittiesVerify First, Write LastThere’s big difference between Substrate and Etherenum. On Ethereum, if at any point your transaction fails (error, out of gas, etc…), the state of your smart contract will be unaffected. Howerver, on Substrate this is not the case. As soon as a transaction starts to modify the storage of the blockchain, those changes are parmanent, even if the transaction would fail at a later time during runtime execution. As a Substrate runtime developer, we must follow “Verify first, write last” pattern. Creating a ListSubstrate does support lists in the form of an EnumerableStorageMap. In runtime development, list iteration is, generally speaking, dangerous. Unless explicitly guarded against, runtime functions which enumerate a list will add O(N) complexity, but only charge O(1) fees. As a result, the chain can be vulnerable to attacks. Furthermore, if the lists you iterate over are large or even unbounded, your runtime may need more time to process the list than what is allocated between blocks. This means that a block producer may not even be able to create new blocks! For this reason, we will not use any list iteration in our runtime logic. Instead, we will emulate an enumerable map with a mapping and a counter like so: 12345678910decl_storage! &#123; trait Store for Module&lt;T: Trait&gt; as KittyStorage &#123; ... AllKittiesArray get(kitty_by_index): map u64 =&gt; T::Hash; AllKittiesCount get(all_kitties_count): u64; ... &#125;&#125; Here we are storing a list of kitty in our runtime represented by T::Hash. (有了这两个item以后，我们可以通过all_kitties_count来获得当前的kitty数，然后根据index(最后一个索引index = count - 1)去索引对应的kitty，就可以追踪到所有的kitty了，即遍历0 ~ count -1的index就可以遍历所有的kitty了)。 Checking for Overflow&#x2F;UnderflowOverflow and underflows are an easy way to cause our runtime to panic or for our storage to get messed up. We must always be proactive about checking for possible runtime errors before we make changes to our state. Ulike Ethereum, when a transaction fails, the state is NOT reverted back to before the transaction, so it is your responsibility to ensure that there are no side effect on error. Fortuanately, checking for these kinds of errors are quite simple in Rust where primitive number types have checked_add() and checked_sub() functions. 12let all_kitties_count = Self::all_kitties_count();let new_all_kitties_count = all_kitties_count.checked_add(1).ok_or(&quot;Overflow adding a new kitty&quot;)?; Using ok_or is the same as writing: 1234let new_all_kitties_count = match all_kitties_count.check_add(1) &#123; Some(x) =&gt; x, Err(&quot;Overflow adding a new kitty&quot;),&#125;; Make sure to remember the ? at the end. Updating our List in StorageNow that we have checked that we can safely increament our list, we can finally push changes to our storage. Remember that when you update your list, the “last index” of your list is one less than the count. For example, in a list with 2 items, the first item is index 0, and the second item is index 1. 1234567891011121314151617fn create_kitty(origin) -&gt; Result &#123; let sender = ensure_signed(origin)?; let all_kitties_count = Self::all_kitties_count(); let new_all_kitties_count = all_kitties_count.checked_add(1).ok_or(&quot;Overflow addina new kitty&quot;)? ... // (`index` is `count - 1` = `new_all_kitties_count 1` = `all_kitties_count`) &lt;AllKittiesArray&lt;T&gt;&gt;::insert(all_kitties_count, random_hash); &lt;AllKittiesCount&lt;T&gt;&gt;::put(new_all_kitties_count); &lt;AllKittiesIndex&lt;T&gt;&gt;::insert(random_hash, all_kitties_count) ... Ok(())&#125; First, we get the current AllKittiesCount value and store it in all_kitties_count. Then create a new_all_kitties_count by doing a checked_add() to increment all_kitties_count. We also map the index(all_kitties_count &#x3D; new_kitties_count -1, remember the index is count -1 ) to the kitty(random_hash). Deleting From Our ListOne problem that this map and count pattern introduces is holes in our list when we try to remove elements from the middle. Fortunately, the order of the list we want to manage in our example is not important, so we can use a “swap and pop” method to efficiently mitigate this issue. The “swap and pop” method switches the position of the item we want to remove and the last item in our list. Then, we can simply remove the last item without introducing any holes to our list. Rather than run a loop to find the index of the item we want to remove each time we remove an item, we will use a little extra storage to keep track of each item and its position in our list. 1AllKittiesIndex: map T::Hash =&gt; u64; （简单来讲其实就是每次先交换要删除的kitty和整个list里最后一个kitty，交换完后把最后一个kitty删掉就好，这样一来就不会因为删除在list里留下空缺。同时，我们用AllKittiesIndex这个数据结构来映射kitty和index，这样就不需要每次删除kitty的时候还要遍历整个list去找它的index） Owning Multiple KittiesRight now our storage can only track one kitty per user, howerver one user can own multiple kitties. Note: 其实这种说法并不准确，虽然对于每个user只能看到最新的一只kitty，但是实际上通过某只kitty还是可以追踪到它的owner的。 (Though every user can only check the last kitty he has, we can find the kitty’s owner by KittyOwner.) Using tuples to emulate higher order arraysWe could use a tuple to represent ownership of multiple items across multiple users. Here is how we could build a “kitty list” unique to each person using such a structure: 12OwnedKittiesArray get(kitty_of_owner_by_index): map (T::AccountId, u64) =&gt; T::Hash;OwnedKittiesCount get(owned_kitty_count): map T::AccountId =&gt; u64; This should emulate a more standard two-dimensional array like: 1OwnedKittiesArray[AccountId][index] -&gt; (one)kitty Also we can get the number of kitties for a user like: 1OwnedKittiesArray[AccountId].length() = owned_kitty_count() = OwnedKittiesCount[AccountId] Relative IndexJust as before, we can optimize the computational work our runtime needs to do by indexing the location of items. The general approach to this would be to reserve the mapping of OwnedKittiesArray: 12// (T::AccountId, T::Hash) -&gt; `index` in `OwnedKittiesArray`OwnedKittiesIndex: map (T::AccountId, T::Hash) =&gt; u64; Howerver, our kitties all have unique identifiers as a Hash, and cannot be owned by more than one user, we can actually simplify this structure: 1OwnedKittiesIndex: map T::Hash =&gt; u64; This index tells us for a given kitty, where to look in the owners array for that item. Refactoring our codeWithin our runtime, we are able to include an implementation of our runtime module like so: 123impl&lt;T: Trait&gt; Module&lt;T&gt; &#123; // our function here &#125; Functions in this block are usually public interfaces or private functions. Public interfaces should be labeled pub and generally fall into inspector functions that do not write to storage and operation functions that do. Private functions are your usual private utilities unavailable to other modules. You can call functions defined here using the Self::function_name() pattern you have seen before. Here is an intentionally overcomplicated example: 123456789101112131415161718192021222324decl_module! &#123; pub struct Module&lt;T: Trait&gt; for enum Call where origin: T::Origin &#123; fn adder_to_storage(origin, num1: u32, num2: u32) -&gt; Result &#123; let _sender = ensure_signed(origin)?; let result = Self::_adder(num1, num2); Self::_store_value(result)?; Ok(()) &#125; &#125;&#125;impl&lt;T: Trait&gt; Module&lt;T&gt; &#123; fn _adder(num1: u32, num2: u32) -&gt; u32 &#123; let final_answer = num1.checked_add(num2).ok_or(&quot;Overflow when adding&quot;)?; &#125; fn _store_value(value: u32) -&gt; Result &#123; &lt;myStorage&lt;T&gt;&gt;::put(value); Ok(()) &#125;&#125; Remember that we still need to follow a “verify first, write last” pattern, so it is important to not daisy chain private functions which do writes to storage where there is a chance one will throw an error. So, in our example, we moved most of the logic to the function mint: 12345678910111213141516171819202122232425impl&lt;T: Trait&gt; Module&lt;T&gt; &#123; fn mint(to: T::AccountId, kitty_id: T::Hash, new_kitty: Kitty&lt;T::Hash, T::Balance&gt;) -&gt; Result &#123; let owned_kitty_count = Self::owned_kitty_count(&amp;to); let new_owned_kitty_count = owned_kitty_count.checked_add(1).ok_or(&quot;Overflow adding a new kitty to account Balance&quot;)?; let all_kitties_count = Self::all_kitties_count(); let new_all_kitties_count = all_kitties_count.checked_add(1).ok_or(&quot;Overflow adding a new kitty&quot;)?; &lt;Kitties&lt;T&gt;&gt;::insert(kitty_id, new_kitty); &lt;KittyOwner&lt;T&gt;&gt;::insert(kitty_id, &amp;to); // (`index` is `count - 1` = `new_all_kitties_count - 1` = `all_kitties_count`,) &lt;AllKittiesArray&lt;T&gt;&gt;::insert(all_kitties_count, kitty_id); &lt;AllKittiesCount&lt;T&gt;&gt;::put(new_all_kitties_count); &lt;AllKittiesIndex&lt;T&gt;&gt;::insert(kitty_id, all_kitties_count); &lt;OwnedKittiesArray&lt;T&gt;&gt;::insert((to.clone(), owned_kitty_count), kitty_id); &lt;OwnedKittiesCount&lt;T&gt;&gt;::insert(&amp;to, new_owned_kitty_count); &lt;OwnedKittiesIndex&lt;T&gt;&gt;::insert(kitty_id, owned_kitty_count); &lt;OwnedKitty&lt;T&gt;&gt;::insert(&amp;to, kitty_id); Self::deposit_event(RawEvent::Created(to, kitty_id)); Ok(()) &#125;&#125; Set the price of a KittyNow, every kitty has a price attribute that we have set it to 0 as defalut. If we want to set the price of a kitty, we will need to pull down the Kitty object, update the price, and push it back into the storage. Sanity ChecksBefore doing this, we need to do sanity checks. Since we are going to start letting users call public functions that our runtime exposes, and that means opportunity for our users to give poor input or even maliciously. So if we are creating a function which updates the value of an object, the first thing we better do is make sure the object exists at all. 1ensure!(&lt;Kitties&lt;T&gt;&gt;::exists(kitty_id), &quot;This kitty does not exists.&quot;); Permissioned FunctionsAlthough everyone could call our create_kitty() function with a message, only the owner of the kitty is allowed to set the price. For modifying a Kitty, we need to get the owner of the kitty, and ensure that it is the same as the sender. KittyOwner stores a mapping to an Option&lt;T::AccountId&gt; since a given Hash may not point to a generated and owned Kitty yet. This means, whenever we fetch the owner of a kitty, we need to resolve the possibility that it returns None. This could be caused by bad user input or even some sort of problem with our runtime, but checking will help prevent these kinds of problems. 其实这里说的不是很准确，每个kitty应该都有owner，如果是输入错误那么实际上在第一次检查的时候，就已经发现这个kitty不存在了。(In fact, every kitty should have its owner, if it does not have a owner, it should not exist.) 123// kitty&#x27;s ownerlet owner = Self::owner_of(kitty_id).ok_or(&quot;No owner for this kitty&quot;)?;ensure!(owner == sender, &quot;You are not the owner of the kitty&quot;); So the set_price function looks like: 1234567891011121314151617fn set_price(origin, kitty_id: T::Hash, new_price: T::Balance) -&gt; Result &#123; let sender = ensure_signed(origin)?; ensure!(&lt;Kitties&lt;T&gt;&gt;::exists(kitty_id), &quot;This kitty does not exists.&quot;) // kitty&#x27;s owner let owner = Self::owner_of(kitty_id).ok_or(&quot;No owner for this kitty&quot;)?; ensure!(owner == sender, &quot;You are not the owner of the kitty&quot;) let mut kitty = Self::kitty(kitty_id); kitty.price = new_price &lt;Kitties&lt;T&gt;&gt;::insert(kitty_id, kitty) Self::deposit_event(RawEvent::PriceSet(sender, kitty_id, new_price)); Ok(())&#125; Transferring a KittyOwnership is entirely managed by our storage, so a transfer_kitty function is really only modifying our existing storage to reflect the state. Here are the storage items we need to update: Change the global kitty owner Change the owned kitty count of each user Change the owned kitty index of the kitty Change the owned kitty map for each user 12345678910fn transfer(origin, to: T::AccountId, kitty_id: T::Hash) -&gt; Result &#123; let sender = ensure_signed(origin)?; let owner = Self::owner_of(kitty_id).ok_or(&quot;No owner for this kitty&quot;)?; ensure!(owner == sender, &quot;You are not the owner of this kitty&quot;); Self::transfer_from(sender, to, kitty_id)?; Ok(())&#125; 12345678910111213141516171819202122232425262728fn buy_kitty(origin, kitty_id: T::Hash, max_price: T::Balance) -&gt; Result &#123; let sender = ensure_signed(origin)?; ensure!(&lt;Kitties&lt;T&gt;&gt;::exists(kitty_id), &quot;This kitty does not exists.&quot;); let owner = Self::owner_of(kitty_id).ok_or(&quot;No owner for this kitty&quot;)?; let mut kitty = Self::kitty(kitty_id); let kitty_price = kitty.price; ensure!(!kitty_price.is_zero(), &quot;Price is zero.&quot;); ensure!(kitty_price &lt;= max_price, &quot;The cat you want to by cost more than your max price&quot;); &lt;balances::Module&lt;T&gt; as Currency&lt;_&gt;&gt;::transfer(&amp;sender, &amp;owner, kitty_price)?; Self::transfer_from(owner.clone(), sender.clone(), kitty_id) .expect(&quot;`owner` is shown to own the kitty; \\ `owner` must have greater than 0 kitties, so transfer cannot cause underflow; \\ `all_kitty_count` shares the same type as `owned_kitty_count` \\ and minting ensure there won&#x27;t ever be more than `max()` kitties, \\ which means transfer cannot cause an overflow; \\ qed&quot;); kitty.price = &lt;T::Balance as As&lt;u64&gt;&gt;::sa(0); Self::deposit_event(RawEvent::Bought(sender, owner, kitty_id, kitty_price)); Ok(()) &#125; Buying a KittyFirst, make sure that the kitty is indeed for sale. To simplified our problem, just define that any kitty with default price of 0 is not for sale. Then, we need to make a payment. So far our chain has been completely independent of our internal currency provided by the Balances module. The Balances module gives us access to completely manage the internal currency of every user, which means we need to be careful how we use it. Fortunately, the Balances module expose a trait called Currency which implements a function called transfer() which allows you to safely transfer units from one account to another, checking for enough balance, overflow, underflow, and even account creation as a result of getting tokens. 1&lt;balances::Module&lt;T&gt; as Currency&lt;_&gt;&gt;::transfer(&amp;sender, &amp;owner, kitty_price)?; Breeding a KittyProbably the most unique part of the origina; CryptoKitties game is the ability to breed new kitties from existing ones. We have prepared our Kitty object with this in mind, introducing dna and gen which will be used in forming brand new kitty offspring. In our runtime, DNA is a 256 bit hash, which is represented by as a bytearray in our code, and a hexadecimal string in our upcoming UI. This means that there are 32 elements, each of which can be a value from 0 - 255. We will use these elements to determine which traits our kitties have. For example, the first index of the byte array can determine the color of our kitty(from a range of 256 colors); the nex element could represent the eye shape, etc… 123456789101112131415161718192021222324252627fn breed_kitty(origin, kitty_id_1: T::Hash, kitty_id_2: T::Hash) -&gt; Result &#123; let sender = ensure_signed(origin)? ensure!(&lt;Kitties&lt;T&gt;&gt;::exists(kitty_id_1), &quot;Kitty1 doenot exist&quot;); ensure!(&lt;Kitties&lt;T&gt;&gt;::exists(kitty_id_2), &quot;Kitty2 doenot exist&quot;) let nonce = &lt;Nonce&lt;T&gt;&gt;::get(); let random_hash = (&lt;system::Module&lt;T&gt;&gt;::random_seed(),sender, nonce).using_encoded(&lt;T asystem::Trait&gt;::Hashing::hash); let kitty_1 = Self::kitty(kitty_id_1); let kitty_2 = Self::kitty(kitty_id_2) let mut final_dna = kitty_1.dna; // &#x27;Zips up&#x27; two iterators into a single iterator opairs. tuple for (i, (dna_2_element, r)) in kitty_2.dna.as_ref().it().zip(random_hash.as_ref().iter()).enumerate() &#123; if r % 2 == 0 &#123; final_dna.as_mut()[i] = *dna_2_element; &#125; let new_kitty = Kitty &#123; id: random_hash, dna: final_dna, price: &lt;T::Balance as As&lt;u64&gt;&gt;::sa(0), gen: cmp::max(kitty_1.gen, kitty_2.gen) + 1, &#125; Self::mint(sender, random_hash, new_kitty)? &lt;Nonce&lt;T&gt;&gt;::mutate(|n| *n += 1); Ok(())&#125;","categories":[{"name":"Rust","slug":"Rust","permalink":"http://readlnh.github.io/categories/Rust/"},{"name":"substrate","slug":"Rust/substrate","permalink":"http://readlnh.github.io/categories/Rust/substrate/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"http://readlnh.github.io/tags/Rust/"},{"name":"Substrate","slug":"Substrate","permalink":"http://readlnh.github.io/tags/Substrate/"},{"name":"blcokchain","slug":"blcokchain","permalink":"http://readlnh.github.io/tags/blcokchain/"}]},{"title":"Primitives","slug":"Rust/Rust-by-example-notes/Primitives","date":"2019-11-05T14:11:00.000Z","updated":"2022-10-27T19:58:23.769Z","comments":true,"path":"2019/11/05/Rust/Rust-by-example-notes/Primitives/","link":"","permalink":"http://readlnh.github.io/2019/11/05/Rust/Rust-by-example-notes/Primitives/","excerpt":"","text":"Rust by examples notes about primitives. PrimitivesRust provides access to a wide variety of primitives. scalar Types signed integers: i8, i16, i32, i64 and isize(pointer size) unsigned integers: u8, u16, u32, u64 and usize(pointer size) floating point: f32, f64 char Unicode scalar values like &#39;a&#39;, &#39;α&#39; and &#39;∞&#39;(4 bytes each) bool either true and false and the unit type (), whose only possible value is an empty tuple: () note: Despite the value of a unit type being a tuple, it is not considered a compound type because it does not contain multiple values. Compound Types arrys like [1, 2, 3] tuples like (1, true) TuplesA tuple is a collection of values of different types. Tuples are constructed using parenthese (), and each tuple itself is a value with type signature (T1, T2, ...), where T1, T2 are the types of its members.Functions can use tuples to return multiple values, as tuples can hold any number of values. 123456#[derive(Debug)]struct Matrix(f32, f32, f32, f32);let long_tuple = (1u8, 2u16, 3u32, 4u64, -1i8, -2i16, -3i32, -4i64, 0.1f32, 0.2f64, &#x27;a&#x27;, true); Values can be extracted from the tuple using tuple indexing,such aslong_tuple.0,long_tuple.1 Tuples can be tuple members 1let tuple_of_tuples = ((1u8, 2u16, 2u32), (4u64, -1i8), -2i16); let can be used to bind the members of a tuple to variables. 12let tuple = (1, true, 1.2);let (a , b, c) = tuple; Display for tuples 12345678910111213141516171819202122use std::fmt::&#123;Display, Formatter, Result&#125;;struct Matrix(f32, f32, f32, f32);fn transpose(x: &amp;Matrix) -&gt; Matrix &#123; Matrix(x.0, x.2, x.1, x.3)&#125;impl Display for Matrix &#123; fn fmt(&amp;self, f: &amp;mut Formatter&lt;&#x27;_&gt;) -&gt; Result &#123; write!(f, &quot;( &#123;&#125; &#123;&#125; )\\n&quot;, &amp;self.0, &amp;self.1)?; write!(f, &quot;( &#123;&#125; &#123;&#125; )&quot;, &amp;self.2, &amp;self.3) &#125;&#125;fn main() &#123; let matrix = Matrix(1.1, 1.2, 2.1, 2.2); println!(&quot;Matrix:\\n&#123;&#125;&quot;, matrix); println!(&quot;Transpose:\\n&#123;&#125;&quot;, transpose(&amp;matrix)); println!(&quot;Matrix:\\n&#123;&#125;&quot;, matrix);&#125; output 123456789Matrix:( 1.1 1.2 )( 2.1 2.2 )Transpose:( 1.1 2.1 )( 1.2 2.2 )Matrix:( 1.1 1.2 )( 2.1 2.2 ) Arrays and SlicesAn array is a collection of objects of the same type T, stored in contiguous memory. Arrays are created using brackets [], and their size, which is know at compile time, is part of their signature [T; size]. Slices are similar to arrays, but their size is not know at compile time. Instead, a slice is a two-word object, the first word is a pointer to the data, the second word is the length of the slice. The word size is the same as usize, determined by archiecture eg 64 bits on x86-64.Slices can be used to borrow a section of an array, and have type signature &amp;[T]. elements can be initalized to the same value 1let x: [i32; 500] = [0; 500] Custom TypesRust custom data types are formed mainly through the two keywords: struct: define a structure enum: define an enumeration StructuresThere are three types of structures (“struct”) that can be created using the struct keyword: Tuple structs, which are, basically, named tuples. 1234struct Pair(i32, i32);let pair = Pair(1, 2);// Destructure a tuple struct let Pair(integer, decimal) = pair; The classic C structs.1234567struct Point &#123; x: f32, y: f32,&#125;let point = Point &#123; 1, 1.1&#125;;// Destructure the point using a `let` bindinglet Point &#123; x: my_x, y: my_y &#125; = point; Unit structs, which are field-less, are useful for generics. 12struct Nil;let _nil = Nil; Note: Structs can be reused as fields of another struct. rectangle struct example 123456789101112131415161718192021222324252627282930313233struct Point &#123; x: f64, y: f64,&#125;#[allow(dead_code)]struct Rectangle &#123; p1: Point, p2: Point,&#125;fn rect_area(rectangle: &amp;Rectangle) -&gt; f64 &#123; let Rectangle &#123; p1: Point &#123;x: x1, y: y1&#125;, p2: Point &#123;x: x2, y: y2&#125; &#125; = rectangle; //println!(&quot;&#123;&#125; &#123;&#125; &#123;&#125;&quot;, y2, y1, y2 - y1); ((x2 - x1) * (y2 - y1))&#125;fn square(p: &amp;Point, x: f64) -&gt; Rectangle &#123; Rectangle &#123; p1: Point &#123; x: p.x, y: p.y, &#125;, p2: Point &#123; x: p.x + x, y: p.y + x, &#125;, &#125;&#125;fn main() &#123; let point: Point = Point &#123; x: 0.3, y: 0.4 &#125;; let x = 0.5; let rectangle = square(&amp;point, x); println!(&quot;&#123;&#125;&quot;,rect_area(&amp;rectangle));&#125; output 10.5 EnumsThe enum keyword allows the creation of a type which may be one of a few different variants. Any variant which is valid as a struct is also valid as enum. example 1234567891011121314// Create an `enum` to classify a web event. Note how both// names and type information together specify the variant:// `PageLoad != PageUnload` and `KeyPress(char) != Paste(String)`.// Each is different and independent.enum WebEvent &#123; // An `enum` may either be `unit-like`, PageLoad, PageUnload, // like tuple structs, KeyPress(char), Paste(String), // or c-like structures. Click &#123; x: i64, y: i64 &#125;,&#125; useThe use declaration can be used so manual scoping isn’t needed: 1234enum Status &#123; A, B,&#125; no use 1let status = Status::A; use 12use crate::Status::&#123;A, B&#125;;let status = A; C-likeenum can also be used as C-like enums. 12345678910111213141516171819202122232425// An attribute to hide warnings for unused code.#![allow(dead_code)]// enum with implicit discriminator (starts at 0)enum Number &#123; Zero, One, Two,&#125;// enum with explicit discriminatorenum Color &#123; Red = 0xff0000, Green = 0x00ff00, Blue = 0x0000ff,&#125;fn main() &#123; // `enums` can be cast as integers. println!(&quot;zero is &#123;&#125;&quot;, Number::Zero as i32); println!(&quot;one is &#123;&#125;&quot;, Number::One as i32); println!(&quot;roses are #&#123;:06x&#125;&quot;, Color::Red as i32); println!(&quot;violets are #&#123;:06x&#125;&quot;, Color::Blue as i32);&#125; Linked-listCons: Tuple struct that wraps an element and a pointer to the next node 12345678910111213141516171819202122232425262728293031323334353637383940414243444546use crate::List::*;#[derive(Debug)]enum List &#123; Cons(u32, Box&lt;List&gt;), Nil,&#125;impl List &#123; fn new() -&gt; List &#123; Nil &#125; fn prepend(self, elem: u32) -&gt; List &#123; Cons(elem, Box::new(self)) &#125; fn len(&amp;self) -&gt; u32 &#123; match *self &#123; Cons(_, ref tail) =&gt; 1 + tail.len(), Nil =&gt; 0, &#125; &#125; fn stringify(&amp;self) -&gt; String &#123; match *self &#123; Cons(head, ref tail) =&gt; &#123; format!(&quot;&#123;&#125;, &#123;&#125;&quot;, head, tail.stringify()) &#125;, Nil =&gt; &#123; format!(&quot;Nil&quot;) &#125;, &#125; &#125;&#125;fn main() &#123; let mut list = List::new(); list = list.prepend(1); list = list.prepend(2); list = list.prepend(3); println!(&quot;&#123;&#125;&quot;, list.len()); println!(&quot;&#123;&#125;&quot;, list.stringify());&#125; constantsRust has two different types of constants which can be declared in any scope including global. Both require explicit type annotation: const: An unchanged value (the common case). static: A possibly mutable variable with &#39;static lifetime. The staic lifetime is inferred and does not have to be specified. Accessing or modifying a mutable static variable is unsafe. Type conversationThe generic conversations will use the From and Into traits. From and IntoFrom and Into traits are inherently linked. If your are able to convert type A from type B, then it should be easy to believe that we should be able to convert type B to type A. The From trait allows for a type to define how to create itself from another type, hence providing a very simple mechanism for converting between several types. 12let my_str = &quot;hi&quot;;let my_string = String::from(my_str); The Into trait is simply the reciprocal of the From trait. That is, if you have implemented the From trait for your type you get the Into implementation for free. 1234567891011121314151617181920use std::convert::From;#[derive(Debug)]struct Number &#123; value: i32,&#125;impl From&lt;i32&gt; for Number &#123; fn from(item: i32) -&gt; Self &#123; Number &#123; value: item &#125; &#125;&#125;fn main() &#123; let num = Number::from(100); println!(&quot;&#123;:?&#125;&quot;, num); let int = 5; let num: Number = int.into(); println!(&quot;&#123;:?&#125;&quot;, num);&#125; To and from StringsConverting to StringTo convert any type to String is as simple as implenting the ToString trait for the type. Rather than doing so directly, you should implement the fmt::Display trait which automagically provides ToString and also allows printing the types as discussed in the section on print!. Parsing a String1234567fn main() &#123; let parsed: i32 = &quot;5&quot;.parse().unwrap(); let turbo_parsed = &quot;10&quot;.parse::&lt;i32&gt;().unwrap(); let sum = parsed + turbo_parsed; println!(&quot;Sum: &#123;:?&#125;&quot;, sum);&#125;","categories":[{"name":"Rust","slug":"Rust","permalink":"http://readlnh.github.io/categories/Rust/"},{"name":"Rust-by-example-notes","slug":"Rust/Rust-by-example-notes","permalink":"http://readlnh.github.io/categories/Rust/Rust-by-example-notes/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"http://readlnh.github.io/tags/Rust/"},{"name":"Type","slug":"Type","permalink":"http://readlnh.github.io/tags/Type/"}]},{"title":"Formatting","slug":"Rust/Rust-by-example-notes/Formatting","date":"2019-11-01T18:35:00.000Z","updated":"2022-10-27T19:58:23.769Z","comments":true,"path":"2019/11/01/Rust/Rust-by-example-notes/Formatting/","link":"","permalink":"http://readlnh.github.io/2019/11/01/Rust/Rust-by-example-notes/Formatting/","excerpt":"","text":"Some notes with Rust by example about formatting. Formatted printPrinting is handle by a series of macros defined in std::fmt some of which include: format!: write formatted text to String print!: print fotmatted text to the console(io::stdout) println!: same as print! but a newline is appended eprint : same as format!, but the text if printed to the santard error(io::stderr) eprintln: smae as eprint, but a newline is appended std::fmt contains many traits which govern the display of text. The base form of two important ones are listed below: fmt::Debug: Uses the &#123;:?&#125; marker. Format text for debugging purpoes fmt::Display: Uses the &#123;&#125; marker. Format text in a more elegant, user friendly fashion. Note: Implementing the fmt::Display trait automatically implements the ToString trait which allows us to convert the type to String. DebugAll types which want to use std::fmt formatting traits require an implementation to be printable. Automatic implementations are only provided for types such as in the std library. All others must be* maually* implemented somehow. All types can derive(automatically create) the fmt::Debug implementation. This is not true for fmt::Display which must be manually implemented. 1234567// cannot be printed either with `fmt::Display` or with `fmt::Debug`struct UnPrintable(i32);// The `derive` attribute automatically creates the implementation // required to make this `struct` printable with `fmt::Debug` #[derive(Debug)]struct DebugUnPrintable(i32); fmt::Debug definitely makes this printable but scarifices some elegance.Rust also provides pretty printing with &#123;:#?&#125; One can manually implemnet fmt::Debug instead of derive. 123456789101112131415161718192021222324252627282930313233343536373839404142use std::fmt::&#123;self, Debug, Formatter&#125;;struct TestDebug &#123; v1: i32, v2: i32,&#125;#[derive(Debug)]struct TestDebugauto &#123; v1: i32, v2: i32,&#125;impl TestDebugauto &#123; fn new(x: i32, y: i32) -&gt; Self &#123; TestDebugauto &#123; v1: x, v2: y, &#125; &#125;&#125;impl TestDebug &#123; fn new(x: i32, y: i32) -&gt; Self &#123; TestDebug &#123; v1: x, v2: y, &#125; &#125;&#125;impl Debug for TestDebug &#123; fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; fmt::Result &#123; write!(f, &quot;TestDebug: &#123;&#125; &#123;&#125;&quot;, self.v1, self.v2) &#125;&#125;fn main() &#123; let t = TestDebug::new(1, 2); let t2 = TestDebugauto::new(1, 2); println!(&quot;&#123;:?&#125;\\n&#123;:?&#125;&quot;, t, t2);&#125; output 12345 Compiling debug_manually v0.1.0 (/home/readlnh/workspace/rust_workspace/rust-by-example/debug_manually) Finished dev [unoptimized + debuginfo] target(s) in 0.29s Running `target/debug/debug_manually`TestDebug: 1 2TestDebugauto &#123; v1: 1, v2: 2 &#125; DisplayOne can manually implement fmt::Display to control the display,same as fmt::Debug. 1234567891011121314151617181920212223242526272829303132use std::fmt;struct TestDisplay &#123; v1: i32, v2: i32,&#125;impl TestDisplay &#123; fn new(x: i32, y: i32) -&gt; Self &#123; TestDisplay &#123; v1: x, v2: y, &#125; &#125;&#125;impl fmt::Display for TestDisplay &#123; fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result &#123; // Write strictly the two elements into the supplied output // stream: `f`. Returns `fmt::Result` which indicates whether the // operation succeeded or failed. Note that `write!` uses syntax which // is very similar to `println!`. write!(f, &quot;TestDebug: &#123;&#125; &#123;&#125;&quot;, self.v1, self.v2) &#125;&#125;fn main() &#123; let t = TestDisplay::new(1, 2); println!(&quot;&#123;&#125;&quot;, t);&#125; output 1234 Compiling display_manually v0.1.0 (/home/readlnh/workspace/rust_workspace/rust-by-example/display_manually) Finished dev [unoptimized + debuginfo] target(s) in 0.28s Running `target/debug/display_manually`TestDebug: 1 2 example for Complex structure 1234567891011121314151617181920212223242526272829303132use std::fmt;struct Complex &#123; x: f64, y: f64,&#125;impl Complex &#123; fn new(x: f64, y: f64) -&gt; Self &#123; Complex &#123; x, y, &#125; &#125;&#125;impl fmt::Display for Complex &#123; fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;&#x27;_&gt;) -&gt; fmt::Result &#123; write!(f, &quot;&#123;&#125; + &#123;&#125;i&quot;, self.x, self.y) &#125;&#125;impl fmt::Debug for Complex &#123; fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;&#x27;_&gt;) -&gt; fmt::Result &#123; write!(f, &quot;Complex &#123;&#123; real: &#123;&#125; imag: &#123;&#125; &#125;&#125;&quot;, self.x , self.y) &#125;&#125;fn main() &#123; let t = Complex::new(3.3, 7.2); println!(&quot;&#123;&#125;\\n&#123;:?&#125;&quot;, t, t);&#125; output 1234 Finished dev [unoptimized + debuginfo] target(s) in 0.01s Running `target/debug/complex_display`3.3 + 7.2iComplex &#123; real: 3.3 imag: 7.2 &#125; Each write! generates a fmt::Result.Proper handing of this requires dealing with all the results.Rust provides ? operater for exactly this purpose. display for vector 12345678910111213141516171819202122232425use std::fmt;struct List(Vec&lt;i32&gt;);impl fmt::Display for List &#123; fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;&#x27;_&gt;) -&gt; fmt::Result &#123; // Extract the value using the type indexing let vec = &amp;self.0; write!(f, &quot;[&quot;)?; for (index, v) in vec.iter().enumerate() &#123; if index != 0 &#123; write!(f, &quot;, &quot;)?; &#125; write!(f, &quot;&#123;&#125;: &#123;&#125;&quot;, index, v)?; &#125; write!(f, &quot;]&quot;) &#125;&#125;fn main() &#123; let v = List(vec![1, 2, 3]); println!(&quot;&#123;&#125;&quot;, v);&#125; output 1[0: 1, 1: 2, 2: 3] FormattingFormatting is specified via a format string: format!(&quot;&#123;&#125;&quot;, foo) -&gt; &quot;3735928559&quot; format!(&quot;0x&#123;:X&#125;&quot;, foo) -&gt; &quot;0xDEADBEEF&quot; format!(&quot;0o&#123;:o&#125;&quot;, foo) -&gt; &quot;0o33653337357&quot; We can pad with zeros to a width of 6 with :06 example code Color 1234567891011121314151617181920212223242526use std::fmt;struct Color &#123; r: i32, g: i32, b: i32,&#125;impl Color &#123; fn new(r: i32, g: i32, b: i32) -&gt; Self &#123; Color &#123; r, g, b&#125; &#125;&#125;impl fmt::Display for Color &#123; fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;&#x27;_&gt;) -&gt; fmt::Result &#123; write!(f, &quot;RGB (&#123;&#125;, &#123;&#125;, &#123;&#125;) 0x&#123;:06X&#125;&quot;, self.r, self.g, self.b, self.r * (1 &lt;&lt; 16) + self.g * (1 &lt;&lt; 8) + self.b ) &#125;&#125;fn main() &#123; let t1 = Color::new(128, 255, 90); let t2 = Color::new(0, 3, 254); let t3 = Color::new(0, 0, 0); println!(&quot;&#123;&#125;\\n&#123;&#125;\\n&#123;&#125;&quot;, t1, t2, t3);&#125;","categories":[{"name":"Rust","slug":"Rust","permalink":"http://readlnh.github.io/categories/Rust/"},{"name":"Rust-by-example-notes","slug":"Rust/Rust-by-example-notes","permalink":"http://readlnh.github.io/categories/Rust/Rust-by-example-notes/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"http://readlnh.github.io/tags/Rust/"}]}],"categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://readlnh.github.io/categories/OpenGL/"},{"name":"Linux","slug":"Linux","permalink":"http://readlnh.github.io/categories/Linux/"},{"name":"APUE","slug":"Linux/APUE","permalink":"http://readlnh.github.io/categories/Linux/APUE/"},{"name":"docker","slug":"Linux/docker","permalink":"http://readlnh.github.io/categories/Linux/docker/"},{"name":"Rust","slug":"Rust","permalink":"http://readlnh.github.io/categories/Rust/"},{"name":"blog_os notes","slug":"Rust/blog-os-notes","permalink":"http://readlnh.github.io/categories/Rust/blog-os-notes/"},{"name":"Rust-by-example-notes","slug":"Rust/Rust-by-example-notes","permalink":"http://readlnh.github.io/categories/Rust/Rust-by-example-notes/"},{"name":"substrate","slug":"Rust/substrate","permalink":"http://readlnh.github.io/categories/Rust/substrate/"},{"name":"loongson","slug":"Linux/loongson","permalink":"http://readlnh.github.io/categories/Linux/loongson/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"http://readlnh.github.io/tags/Rust/"},{"name":"cargo","slug":"cargo","permalink":"http://readlnh.github.io/tags/cargo/"},{"name":"crate","slug":"crate","permalink":"http://readlnh.github.io/tags/crate/"},{"name":"ref","slug":"ref","permalink":"http://readlnh.github.io/tags/ref/"},{"name":"dyn","slug":"dyn","permalink":"http://readlnh.github.io/tags/dyn/"},{"name":"trait","slug":"trait","permalink":"http://readlnh.github.io/tags/trait/"},{"name":"os","slug":"os","permalink":"http://readlnh.github.io/tags/os/"},{"name":"Modules","slug":"Modules","permalink":"http://readlnh.github.io/tags/Modules/"},{"name":"Substrate","slug":"Substrate","permalink":"http://readlnh.github.io/tags/Substrate/"},{"name":"blcokchain","slug":"blcokchain","permalink":"http://readlnh.github.io/tags/blcokchain/"},{"name":"darwinia","slug":"darwinia","permalink":"http://readlnh.github.io/tags/darwinia/"},{"name":"closure","slug":"closure","permalink":"http://readlnh.github.io/tags/closure/"},{"name":"loognson","slug":"loognson","permalink":"http://readlnh.github.io/tags/loognson/"},{"name":"mipsel","slug":"mipsel","permalink":"http://readlnh.github.io/tags/mipsel/"},{"name":"cross-compile","slug":"cross-compile","permalink":"http://readlnh.github.io/tags/cross-compile/"},{"name":"Type","slug":"Type","permalink":"http://readlnh.github.io/tags/Type/"}]}